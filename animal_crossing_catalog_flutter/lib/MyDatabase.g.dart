// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'MyDatabase.dart';

// **************************************************************************
// MoorGenerator
// **************************************************************************

// ignore_for_file: type=lint
class AcgcCarpetData extends DataClass implements Insertable<AcgcCarpetData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  AcgcCarpetData(
      {this.index, this.selected, this.name, this.status, this.from});
  factory AcgcCarpetData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcCarpetData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcgcCarpetCompanion toCompanion(bool nullToAbsent) {
    return AcgcCarpetCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcgcCarpetData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcCarpetData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcgcCarpetData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from}) =>
      AcgcCarpetData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcCarpetData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcCarpetData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from);
}

class AcgcCarpetCompanion extends UpdateCompanion<AcgcCarpetData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  const AcgcCarpetCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcgcCarpetCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcgcCarpetData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
    });
  }

  AcgcCarpetCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from}) {
    return AcgcCarpetCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcCarpetCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcgcCarpet extends Table with TableInfo<AcgcCarpet, AcgcCarpetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcCarpet(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, status, from];
  @override
  String get aliasedName => _alias ?? 'acgc_carpet';
  @override
  String get actualTableName => 'acgc_carpet';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcCarpetData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcCarpetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcCarpetData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcCarpet createAlias(String alias) {
    return AcgcCarpet(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcWallpaperData extends DataClass
    implements Insertable<AcgcWallpaperData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  AcgcWallpaperData(
      {this.index, this.selected, this.name, this.status, this.from});
  factory AcgcWallpaperData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcWallpaperData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcgcWallpaperCompanion toCompanion(bool nullToAbsent) {
    return AcgcWallpaperCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcgcWallpaperData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcWallpaperData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcgcWallpaperData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from}) =>
      AcgcWallpaperData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcWallpaperData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcWallpaperData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from);
}

class AcgcWallpaperCompanion extends UpdateCompanion<AcgcWallpaperData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  const AcgcWallpaperCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcgcWallpaperCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcgcWallpaperData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
    });
  }

  AcgcWallpaperCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from}) {
    return AcgcWallpaperCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcWallpaperCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcgcWallpaper extends Table
    with TableInfo<AcgcWallpaper, AcgcWallpaperData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcWallpaper(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, status, from];
  @override
  String get aliasedName => _alias ?? 'acgc_wallpaper';
  @override
  String get actualTableName => 'acgc_wallpaper';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcWallpaperData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcWallpaperData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcWallpaperData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcWallpaper createAlias(String alias) {
    return AcgcWallpaper(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcFishData extends DataClass implements Insertable<AcgcFishData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? from;
  final String? times;
  AcgcFishData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.from,
      this.times});
  factory AcgcFishData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcFishData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcgcFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcFishCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcgcFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcFishData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcgcFishData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? from,
          String? times}) =>
      AcgcFishData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcFishData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, price, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcFishData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.from == this.from &&
          other.times == this.times);
}

class AcgcFishCompanion extends UpdateCompanion<AcgcFishData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> times;
  const AcgcFishCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcgcFishCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcgcFishData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AcgcFishCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? times}) {
    return AcgcFishCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcFishCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcgcFish extends Table with TableInfo<AcgcFish, AcgcFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, from, times];
  @override
  String get aliasedName => _alias ?? 'acgc_fish';
  @override
  String get actualTableName => 'acgc_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcFish createAlias(String alias) {
    return AcgcFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcFossilData extends DataClass implements Insertable<AcgcFossilData> {
  final int? index;
  final int? selected;
  final String? name;
  AcgcFossilData({this.index, this.selected, this.name});
  factory AcgcFossilData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcFossilData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    return map;
  }

  AcgcFossilCompanion toCompanion(bool nullToAbsent) {
    return AcgcFossilCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
    );
  }

  factory AcgcFossilData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcFossilData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
    };
  }

  AcgcFossilData copyWith({int? index, int? selected, String? name}) =>
      AcgcFossilData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcFossilData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcFossilData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name);
}

class AcgcFossilCompanion extends UpdateCompanion<AcgcFossilData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  const AcgcFossilCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  AcgcFossilCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  static Insertable<AcgcFossilData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
    });
  }

  AcgcFossilCompanion copyWith(
      {Value<int?>? index, Value<int?>? selected, Value<String?>? name}) {
    return AcgcFossilCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcFossilCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class AcgcFossil extends Table with TableInfo<AcgcFossil, AcgcFossilData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcFossil(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name];
  @override
  String get aliasedName => _alias ?? 'acgc_fossil';
  @override
  String get actualTableName => 'acgc_fossil';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcFossilData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcFossilData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcFossilData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcFossil createAlias(String alias) {
    return AcgcFossil(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcGyroidData extends DataClass implements Insertable<AcgcGyroidData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcgcGyroidData({this.index, this.selected, this.name, this.from});
  factory AcgcGyroidData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcGyroidData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcgcGyroidCompanion toCompanion(bool nullToAbsent) {
    return AcgcGyroidCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcgcGyroidData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcGyroidData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcgcGyroidData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcgcGyroidData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcGyroidData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcGyroidData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcgcGyroidCompanion extends UpdateCompanion<AcgcGyroidData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcgcGyroidCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcgcGyroidCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcgcGyroidData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcgcGyroidCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcgcGyroidCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcGyroidCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcgcGyroid extends Table with TableInfo<AcgcGyroid, AcgcGyroidData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcGyroid(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acgc_gyroid';
  @override
  String get actualTableName => 'acgc_gyroid';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcGyroidData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcGyroidData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcGyroidData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcGyroid createAlias(String alias) {
    return AcgcGyroid(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcInsectData extends DataClass implements Insertable<AcgcInsectData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? from;
  final String? times;
  AcgcInsectData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.from,
      this.times});
  factory AcgcInsectData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcInsectData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcgcInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcInsectCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcgcInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcInsectData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcgcInsectData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? from,
          String? times}) =>
      AcgcInsectData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcInsectData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, price, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcInsectData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.from == this.from &&
          other.times == this.times);
}

class AcgcInsectCompanion extends UpdateCompanion<AcgcInsectData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> times;
  const AcgcInsectCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcgcInsectCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcgcInsectData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AcgcInsectCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? times}) {
    return AcgcInsectCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcInsectCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcgcInsect extends Table with TableInfo<AcgcInsect, AcgcInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, from, times];
  @override
  String get aliasedName => _alias ?? 'acgc_insect';
  @override
  String get actualTableName => 'acgc_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcInsect createAlias(String alias) {
    return AcgcInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcShirtData extends DataClass implements Insertable<AcgcShirtData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? season;
  AcgcShirtData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.season});
  factory AcgcShirtData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcShirtData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      season: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Season']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || season != null) {
      map['Season'] = Variable<String?>(season);
    }
    return map;
  }

  AcgcShirtCompanion toCompanion(bool nullToAbsent) {
    return AcgcShirtCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      season:
          season == null && nullToAbsent ? const Value.absent() : Value(season),
    );
  }

  factory AcgcShirtData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcShirtData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      season: serializer.fromJson<String?>(json['Season']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Season': serializer.toJson<String?>(season),
    };
  }

  AcgcShirtData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? season}) =>
      AcgcShirtData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        season: season ?? this.season,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcShirtData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('season: $season')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, season);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcShirtData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.season == this.season);
}

class AcgcShirtCompanion extends UpdateCompanion<AcgcShirtData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> season;
  const AcgcShirtCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.season = const Value.absent(),
  });
  AcgcShirtCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.season = const Value.absent(),
  });
  static Insertable<AcgcShirtData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? season,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (season != null) 'Season': season,
    });
  }

  AcgcShirtCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? season}) {
    return AcgcShirtCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      season: season ?? this.season,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (season.present) {
      map['Season'] = Variable<String?>(season.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcShirtCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('season: $season')
          ..write(')'))
        .toString();
  }
}

class AcgcShirt extends Table with TableInfo<AcgcShirt, AcgcShirtData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcShirt(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seasonMeta = const VerificationMeta('season');
  late final GeneratedColumn<String?> season = GeneratedColumn<String?>(
      'Season', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, season];
  @override
  String get aliasedName => _alias ?? 'acgc_shirt';
  @override
  String get actualTableName => 'acgc_shirt';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcShirtData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Season')) {
      context.handle(_seasonMeta,
          season.isAcceptableOrUnknown(data['Season']!, _seasonMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcShirtData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcShirtData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcShirt createAlias(String alias) {
    return AcgcShirt(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcSongData extends DataClass implements Insertable<AcgcSongData> {
  final int? index;
  final int? selected;
  final String? name;
  AcgcSongData({this.index, this.selected, this.name});
  factory AcgcSongData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcSongData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    return map;
  }

  AcgcSongCompanion toCompanion(bool nullToAbsent) {
    return AcgcSongCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
    );
  }

  factory AcgcSongData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcSongData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
    };
  }

  AcgcSongData copyWith({int? index, int? selected, String? name}) =>
      AcgcSongData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcSongData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcSongData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name);
}

class AcgcSongCompanion extends UpdateCompanion<AcgcSongData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  const AcgcSongCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  AcgcSongCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  static Insertable<AcgcSongData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
    });
  }

  AcgcSongCompanion copyWith(
      {Value<int?>? index, Value<int?>? selected, Value<String?>? name}) {
    return AcgcSongCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcSongCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class AcgcSong extends Table with TableInfo<AcgcSong, AcgcSongData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcSong(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name];
  @override
  String get aliasedName => _alias ?? 'acgc_song';
  @override
  String get actualTableName => 'acgc_song';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcSongData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcSongData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcSongData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcSong createAlias(String alias) {
    return AcgcSong(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcStationeryData extends DataClass
    implements Insertable<AcgcStationeryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcgcStationeryData({this.index, this.selected, this.name, this.from});
  factory AcgcStationeryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcStationeryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcgcStationeryCompanion toCompanion(bool nullToAbsent) {
    return AcgcStationeryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcgcStationeryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcStationeryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcgcStationeryData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcgcStationeryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcStationeryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcStationeryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcgcStationeryCompanion extends UpdateCompanion<AcgcStationeryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcgcStationeryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcgcStationeryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcgcStationeryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcgcStationeryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcgcStationeryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcStationeryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcgcStationery extends Table
    with TableInfo<AcgcStationery, AcgcStationeryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcStationery(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acgc_stationery';
  @override
  String get actualTableName => 'acgc_stationery';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcStationeryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcStationeryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcStationeryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcStationery createAlias(String alias) {
    return AcgcStationery(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcToolData extends DataClass implements Insertable<AcgcToolData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcgcToolData({this.index, this.selected, this.name, this.from});
  factory AcgcToolData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcToolData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcgcToolCompanion toCompanion(bool nullToAbsent) {
    return AcgcToolCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcgcToolData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcToolData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcgcToolData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcgcToolData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcToolData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcToolData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcgcToolCompanion extends UpdateCompanion<AcgcToolData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcgcToolCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcgcToolCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcgcToolData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcgcToolCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcgcToolCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcToolCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcgcTool extends Table with TableInfo<AcgcTool, AcgcToolData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcTool(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acgc_tool';
  @override
  String get actualTableName => 'acgc_tool';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcToolData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcToolData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcToolData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcTool createAlias(String alias) {
    return AcgcTool(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwAccessoryData extends DataClass
    implements Insertable<AcwwAccessoryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  AcwwAccessoryData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price});
  factory AcwwAccessoryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwAccessoryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    return map;
  }

  AcwwAccessoryCompanion toCompanion(bool nullToAbsent) {
    return AcwwAccessoryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
    );
  }

  factory AcwwAccessoryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwAccessoryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
    };
  }

  AcwwAccessoryData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price}) =>
      AcwwAccessoryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwAccessoryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, price);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwAccessoryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price);
}

class AcwwAccessoryCompanion extends UpdateCompanion<AcwwAccessoryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  const AcwwAccessoryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  AcwwAccessoryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  static Insertable<AcwwAccessoryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
    });
  }

  AcwwAccessoryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price}) {
    return AcwwAccessoryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwAccessoryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }
}

class AcwwAccessory extends Table
    with TableInfo<AcwwAccessory, AcwwAccessoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwAccessory(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price];
  @override
  String get aliasedName => _alias ?? 'acww_accessory';
  @override
  String get actualTableName => 'acww_accessory';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwAccessoryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwAccessoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwAccessoryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwAccessory createAlias(String alias) {
    return AcwwAccessory(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwCarpetData extends DataClass implements Insertable<AcwwCarpetData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? series;
  AcwwCarpetData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.series});
  factory AcwwCarpetData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwCarpetData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcwwCarpetCompanion toCompanion(bool nullToAbsent) {
    return AcwwCarpetCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcwwCarpetData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwCarpetData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcwwCarpetData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? series}) =>
      AcwwCarpetData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwCarpetData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, price, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwCarpetData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.series == this.series);
}

class AcwwCarpetCompanion extends UpdateCompanion<AcwwCarpetData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> series;
  const AcwwCarpetCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcwwCarpetCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcwwCarpetData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (series != null) 'Series': series,
    });
  }

  AcwwCarpetCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? series}) {
    return AcwwCarpetCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwCarpetCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcwwCarpet extends Table with TableInfo<AcwwCarpet, AcwwCarpetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwCarpet(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price, series];
  @override
  String get aliasedName => _alias ?? 'acww_carpet';
  @override
  String get actualTableName => 'acww_carpet';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwCarpetData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwCarpetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwCarpetData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwCarpet createAlias(String alias) {
    return AcwwCarpet(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwFishData extends DataClass implements Insertable<AcwwFishData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? size;
  final String? shadow;
  final String? from;
  final String? times;
  AcwwFishData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.size,
      this.shadow,
      this.from,
      this.times});
  factory AcwwFishData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwFishData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      size: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Size']),
      shadow: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Shadow']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || size != null) {
      map['Size'] = Variable<String?>(size);
    }
    if (!nullToAbsent || shadow != null) {
      map['Shadow'] = Variable<String?>(shadow);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcwwFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwFishCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      shadow:
          shadow == null && nullToAbsent ? const Value.absent() : Value(shadow),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcwwFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwFishData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      size: serializer.fromJson<String?>(json['Size']),
      shadow: serializer.fromJson<String?>(json['Shadow']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'Size': serializer.toJson<String?>(size),
      'Shadow': serializer.toJson<String?>(shadow),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcwwFishData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? size,
          String? shadow,
          String? from,
          String? times}) =>
      AcwwFishData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        size: size ?? this.size,
        shadow: shadow ?? this.shadow,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwFishData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, size, shadow, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwFishData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.size == this.size &&
          other.shadow == this.shadow &&
          other.from == this.from &&
          other.times == this.times);
}

class AcwwFishCompanion extends UpdateCompanion<AcwwFishData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> size;
  final Value<String?> shadow;
  final Value<String?> from;
  final Value<String?> times;
  const AcwwFishCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcwwFishCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcwwFishData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? size,
    Expression<String?>? shadow,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (size != null) 'Size': size,
      if (shadow != null) 'Shadow': shadow,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AcwwFishCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? size,
      Value<String?>? shadow,
      Value<String?>? from,
      Value<String?>? times}) {
    return AcwwFishCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      size: size ?? this.size,
      shadow: shadow ?? this.shadow,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (size.present) {
      map['Size'] = Variable<String?>(size.value);
    }
    if (shadow.present) {
      map['Shadow'] = Variable<String?>(shadow.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwFishCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcwwFish extends Table with TableInfo<AcwwFish, AcwwFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _sizeMeta = const VerificationMeta('size');
  late final GeneratedColumn<String?> size = GeneratedColumn<String?>(
      'Size', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _shadowMeta = const VerificationMeta('shadow');
  late final GeneratedColumn<String?> shadow = GeneratedColumn<String?>(
      'Shadow', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, size, shadow, from, times];
  @override
  String get aliasedName => _alias ?? 'acww_fish';
  @override
  String get actualTableName => 'acww_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Size')) {
      context.handle(
          _sizeMeta, size.isAcceptableOrUnknown(data['Size']!, _sizeMeta));
    }
    if (data.containsKey('Shadow')) {
      context.handle(_shadowMeta,
          shadow.isAcceptableOrUnknown(data['Shadow']!, _shadowMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwFish createAlias(String alias) {
    return AcwwFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwFossilData extends DataClass implements Insertable<AcwwFossilData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? color1;
  final String? color2;
  AcwwFossilData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.color1,
      this.color2});
  factory AcwwFossilData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwFossilData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcwwFossilCompanion toCompanion(bool nullToAbsent) {
    return AcwwFossilCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcwwFossilData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwFossilData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcwwFossilData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? color1,
          String? color2}) =>
      AcwwFossilData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwFossilData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwFossilData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcwwFossilCompanion extends UpdateCompanion<AcwwFossilData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcwwFossilCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcwwFossilCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcwwFossilData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcwwFossilCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcwwFossilCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwFossilCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcwwFossil extends Table with TableInfo<AcwwFossil, AcwwFossilData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwFossil(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acww_fossil';
  @override
  String get actualTableName => 'acww_fossil';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwFossilData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwFossilData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwFossilData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwFossil createAlias(String alias) {
    return AcwwFossil(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwFurnitureData extends DataClass
    implements Insertable<AcwwFurnitureData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? color1;
  final String? color2;
  final String? concept1;
  final String? concept2;
  AcwwFurnitureData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.color1,
      this.color2,
      this.concept1,
      this.concept2});
  factory AcwwFurnitureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwFurnitureData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    return map;
  }

  AcwwFurnitureCompanion toCompanion(bool nullToAbsent) {
    return AcwwFurnitureCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
    );
  }

  factory AcwwFurnitureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwFurnitureData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
    };
  }

  AcwwFurnitureData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? color1,
          String? color2,
          String? concept1,
          String? concept2}) =>
      AcwwFurnitureData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwFurnitureData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, price,
      color1, color2, concept1, concept2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwFurnitureData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2 &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2);
}

class AcwwFurnitureCompanion extends UpdateCompanion<AcwwFurnitureData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  final Value<String?> concept1;
  final Value<String?> concept2;
  const AcwwFurnitureCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
  });
  AcwwFurnitureCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
  });
  static Insertable<AcwwFurnitureData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
    });
  }

  AcwwFurnitureCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2,
      Value<String?>? concept1,
      Value<String?>? concept2}) {
    return AcwwFurnitureCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwFurnitureCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2')
          ..write(')'))
        .toString();
  }
}

class AcwwFurniture extends Table
    with TableInfo<AcwwFurniture, AcwwFurnitureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwFurniture(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        index,
        selected,
        name,
        status,
        from,
        price,
        color1,
        color2,
        concept1,
        concept2
      ];
  @override
  String get aliasedName => _alias ?? 'acww_furniture';
  @override
  String get actualTableName => 'acww_furniture';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwFurnitureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwFurnitureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwFurnitureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwFurniture createAlias(String alias) {
    return AcwwFurniture(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwGyroidData extends DataClass implements Insertable<AcwwGyroidData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? color1;
  final String? color2;
  AcwwGyroidData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.color1,
      this.color2});
  factory AcwwGyroidData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwGyroidData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcwwGyroidCompanion toCompanion(bool nullToAbsent) {
    return AcwwGyroidCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcwwGyroidData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwGyroidData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcwwGyroidData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? color1,
          String? color2}) =>
      AcwwGyroidData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwGyroidData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwGyroidData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcwwGyroidCompanion extends UpdateCompanion<AcwwGyroidData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcwwGyroidCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcwwGyroidCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcwwGyroidData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcwwGyroidCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcwwGyroidCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwGyroidCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcwwGyroid extends Table with TableInfo<AcwwGyroid, AcwwGyroidData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwGyroid(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acww_gyroid';
  @override
  String get actualTableName => 'acww_gyroid';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwGyroidData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwGyroidData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwGyroidData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwGyroid createAlias(String alias) {
    return AcwwGyroid(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwInsectData extends DataClass implements Insertable<AcwwInsectData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? absent;
  final String? price;
  final String? size;
  final String? from;
  final String? times;
  AcwwInsectData(
      {this.index,
      this.selected,
      this.name,
      this.absent,
      this.price,
      this.size,
      this.from,
      this.times});
  factory AcwwInsectData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwInsectData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      absent: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Absent']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      size: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Size']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || absent != null) {
      map['Absent'] = Variable<String?>(absent);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || size != null) {
      map['Size'] = Variable<String?>(size);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcwwInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwInsectCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      absent:
          absent == null && nullToAbsent ? const Value.absent() : Value(absent),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcwwInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwInsectData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      absent: serializer.fromJson<String?>(json['Absent']),
      price: serializer.fromJson<String?>(json['Price']),
      size: serializer.fromJson<String?>(json['Size']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Absent': serializer.toJson<String?>(absent),
      'Price': serializer.toJson<String?>(price),
      'Size': serializer.toJson<String?>(size),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcwwInsectData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? absent,
          String? price,
          String? size,
          String? from,
          String? times}) =>
      AcwwInsectData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        absent: absent ?? this.absent,
        price: price ?? this.price,
        size: size ?? this.size,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwInsectData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('absent: $absent, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, absent, price, size, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwInsectData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.absent == this.absent &&
          other.price == this.price &&
          other.size == this.size &&
          other.from == this.from &&
          other.times == this.times);
}

class AcwwInsectCompanion extends UpdateCompanion<AcwwInsectData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> absent;
  final Value<String?> price;
  final Value<String?> size;
  final Value<String?> from;
  final Value<String?> times;
  const AcwwInsectCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.absent = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcwwInsectCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.absent = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcwwInsectData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? absent,
    Expression<String?>? price,
    Expression<String?>? size,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (absent != null) 'Absent': absent,
      if (price != null) 'Price': price,
      if (size != null) 'Size': size,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AcwwInsectCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? absent,
      Value<String?>? price,
      Value<String?>? size,
      Value<String?>? from,
      Value<String?>? times}) {
    return AcwwInsectCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      absent: absent ?? this.absent,
      price: price ?? this.price,
      size: size ?? this.size,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (absent.present) {
      map['Absent'] = Variable<String?>(absent.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (size.present) {
      map['Size'] = Variable<String?>(size.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwInsectCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('absent: $absent, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcwwInsect extends Table with TableInfo<AcwwInsect, AcwwInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _absentMeta = const VerificationMeta('absent');
  late final GeneratedColumn<String?> absent = GeneratedColumn<String?>(
      'Absent', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _sizeMeta = const VerificationMeta('size');
  late final GeneratedColumn<String?> size = GeneratedColumn<String?>(
      'Size', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, absent, price, size, from, times];
  @override
  String get aliasedName => _alias ?? 'acww_insect';
  @override
  String get actualTableName => 'acww_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Absent')) {
      context.handle(_absentMeta,
          absent.isAcceptableOrUnknown(data['Absent']!, _absentMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Size')) {
      context.handle(
          _sizeMeta, size.isAcceptableOrUnknown(data['Size']!, _sizeMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwInsect createAlias(String alias) {
    return AcwwInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwShirtData extends DataClass implements Insertable<AcwwShirtData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? season;
  final String? price;
  final String? style;
  AcwwShirtData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.season,
      this.price,
      this.style});
  factory AcwwShirtData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwShirtData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      season: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Season']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || season != null) {
      map['Season'] = Variable<String?>(season);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcwwShirtCompanion toCompanion(bool nullToAbsent) {
    return AcwwShirtCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      season:
          season == null && nullToAbsent ? const Value.absent() : Value(season),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcwwShirtData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwShirtData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      season: serializer.fromJson<String?>(json['Season']),
      price: serializer.fromJson<String?>(json['Price']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Season': serializer.toJson<String?>(season),
      'Price': serializer.toJson<String?>(price),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcwwShirtData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? season,
          String? price,
          String? style}) =>
      AcwwShirtData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        season: season ?? this.season,
        price: price ?? this.price,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwShirtData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('season: $season, ')
          ..write('price: $price, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, season, price, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwShirtData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.season == this.season &&
          other.price == this.price &&
          other.style == this.style);
}

class AcwwShirtCompanion extends UpdateCompanion<AcwwShirtData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> season;
  final Value<String?> price;
  final Value<String?> style;
  const AcwwShirtCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.season = const Value.absent(),
    this.price = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcwwShirtCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.season = const Value.absent(),
    this.price = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcwwShirtData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? season,
    Expression<String?>? price,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (season != null) 'Season': season,
      if (price != null) 'Price': price,
      if (style != null) 'Style': style,
    });
  }

  AcwwShirtCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? season,
      Value<String?>? price,
      Value<String?>? style}) {
    return AcwwShirtCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      season: season ?? this.season,
      price: price ?? this.price,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (season.present) {
      map['Season'] = Variable<String?>(season.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwShirtCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('season: $season, ')
          ..write('price: $price, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcwwShirt extends Table with TableInfo<AcwwShirt, AcwwShirtData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwShirt(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seasonMeta = const VerificationMeta('season');
  late final GeneratedColumn<String?> season = GeneratedColumn<String?>(
      'Season', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, season, price, style];
  @override
  String get aliasedName => _alias ?? 'acww_shirt';
  @override
  String get actualTableName => 'acww_shirt';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwShirtData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Season')) {
      context.handle(_seasonMeta,
          season.isAcceptableOrUnknown(data['Season']!, _seasonMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwShirtData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwShirtData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwShirt createAlias(String alias) {
    return AcwwShirt(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwSongData extends DataClass implements Insertable<AcwwSongData> {
  final int? index;
  final int? selected;
  final String? name;
  AcwwSongData({this.index, this.selected, this.name});
  factory AcwwSongData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwSongData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    return map;
  }

  AcwwSongCompanion toCompanion(bool nullToAbsent) {
    return AcwwSongCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
    );
  }

  factory AcwwSongData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwSongData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
    };
  }

  AcwwSongData copyWith({int? index, int? selected, String? name}) =>
      AcwwSongData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwSongData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwSongData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name);
}

class AcwwSongCompanion extends UpdateCompanion<AcwwSongData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  const AcwwSongCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  AcwwSongCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  static Insertable<AcwwSongData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
    });
  }

  AcwwSongCompanion copyWith(
      {Value<int?>? index, Value<int?>? selected, Value<String?>? name}) {
    return AcwwSongCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwSongCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class AcwwSong extends Table with TableInfo<AcwwSong, AcwwSongData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwSong(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name];
  @override
  String get aliasedName => _alias ?? 'acww_song';
  @override
  String get actualTableName => 'acww_song';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwSongData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwSongData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwSongData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwSong createAlias(String alias) {
    return AcwwSong(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwStationeryData extends DataClass
    implements Insertable<AcwwStationeryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  AcwwStationeryData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price});
  factory AcwwStationeryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwStationeryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    return map;
  }

  AcwwStationeryCompanion toCompanion(bool nullToAbsent) {
    return AcwwStationeryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
    );
  }

  factory AcwwStationeryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwStationeryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
    };
  }

  AcwwStationeryData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price}) =>
      AcwwStationeryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwStationeryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, price);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwStationeryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price);
}

class AcwwStationeryCompanion extends UpdateCompanion<AcwwStationeryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  const AcwwStationeryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  AcwwStationeryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  static Insertable<AcwwStationeryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
    });
  }

  AcwwStationeryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price}) {
    return AcwwStationeryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwStationeryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }
}

class AcwwStationery extends Table
    with TableInfo<AcwwStationery, AcwwStationeryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwStationery(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price];
  @override
  String get aliasedName => _alias ?? 'acww_stationery';
  @override
  String get actualTableName => 'acww_stationery';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwStationeryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwStationeryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwStationeryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwStationery createAlias(String alias) {
    return AcwwStationery(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwToolData extends DataClass implements Insertable<AcwwToolData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  AcwwToolData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price});
  factory AcwwToolData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwToolData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    return map;
  }

  AcwwToolCompanion toCompanion(bool nullToAbsent) {
    return AcwwToolCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
    );
  }

  factory AcwwToolData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwToolData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
    };
  }

  AcwwToolData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price}) =>
      AcwwToolData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwToolData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, price);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwToolData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price);
}

class AcwwToolCompanion extends UpdateCompanion<AcwwToolData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  const AcwwToolCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  AcwwToolCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  static Insertable<AcwwToolData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
    });
  }

  AcwwToolCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price}) {
    return AcwwToolCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwToolCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }
}

class AcwwTool extends Table with TableInfo<AcwwTool, AcwwToolData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwTool(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price];
  @override
  String get aliasedName => _alias ?? 'acww_tool';
  @override
  String get actualTableName => 'acww_tool';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwToolData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwToolData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwToolData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwTool createAlias(String alias) {
    return AcwwTool(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwWallpaperData extends DataClass
    implements Insertable<AcwwWallpaperData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? series;
  AcwwWallpaperData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.series});
  factory AcwwWallpaperData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwWallpaperData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcwwWallpaperCompanion toCompanion(bool nullToAbsent) {
    return AcwwWallpaperCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcwwWallpaperData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwWallpaperData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcwwWallpaperData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? series}) =>
      AcwwWallpaperData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwWallpaperData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, price, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwWallpaperData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.series == this.series);
}

class AcwwWallpaperCompanion extends UpdateCompanion<AcwwWallpaperData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> series;
  const AcwwWallpaperCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcwwWallpaperCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcwwWallpaperData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (series != null) 'Series': series,
    });
  }

  AcwwWallpaperCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? series}) {
    return AcwwWallpaperCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwWallpaperCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcwwWallpaper extends Table
    with TableInfo<AcwwWallpaper, AcwwWallpaperData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwWallpaper(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price, series];
  @override
  String get aliasedName => _alias ?? 'acww_wallpaper';
  @override
  String get actualTableName => 'acww_wallpaper';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwWallpaperData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwWallpaperData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwWallpaperData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwWallpaper createAlias(String alias) {
    return AcwwWallpaper(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfAccessoryData extends DataClass
    implements Insertable<AccfAccessoryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? color1;
  final String? color2;
  final String? style;
  final String? look;
  AccfAccessoryData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.color1,
      this.color2,
      this.style,
      this.look});
  factory AccfAccessoryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfAccessoryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
      look: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Look']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    if (!nullToAbsent || look != null) {
      map['Look'] = Variable<String?>(look);
    }
    return map;
  }

  AccfAccessoryCompanion toCompanion(bool nullToAbsent) {
    return AccfAccessoryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
      look: look == null && nullToAbsent ? const Value.absent() : Value(look),
    );
  }

  factory AccfAccessoryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfAccessoryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
      style: serializer.fromJson<String?>(json['Style']),
      look: serializer.fromJson<String?>(json['Look']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
      'Style': serializer.toJson<String?>(style),
      'Look': serializer.toJson<String?>(look),
    };
  }

  AccfAccessoryData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? color1,
          String? color2,
          String? style,
          String? look}) =>
      AccfAccessoryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
        style: style ?? this.style,
        look: look ?? this.look,
      );
  @override
  String toString() {
    return (StringBuffer('AccfAccessoryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('style: $style, ')
          ..write('look: $look')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, from, price, color1, color2, style, look);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfAccessoryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2 &&
          other.style == this.style &&
          other.look == this.look);
}

class AccfAccessoryCompanion extends UpdateCompanion<AccfAccessoryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  final Value<String?> style;
  final Value<String?> look;
  const AccfAccessoryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.style = const Value.absent(),
    this.look = const Value.absent(),
  });
  AccfAccessoryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.style = const Value.absent(),
    this.look = const Value.absent(),
  });
  static Insertable<AccfAccessoryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
    Expression<String?>? style,
    Expression<String?>? look,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
      if (style != null) 'Style': style,
      if (look != null) 'Look': look,
    });
  }

  AccfAccessoryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2,
      Value<String?>? style,
      Value<String?>? look}) {
    return AccfAccessoryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
      style: style ?? this.style,
      look: look ?? this.look,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    if (look.present) {
      map['Look'] = Variable<String?>(look.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfAccessoryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('style: $style, ')
          ..write('look: $look')
          ..write(')'))
        .toString();
  }
}

class AccfAccessory extends Table
    with TableInfo<AccfAccessory, AccfAccessoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfAccessory(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _lookMeta = const VerificationMeta('look');
  late final GeneratedColumn<String?> look = GeneratedColumn<String?>(
      'Look', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price, color1, color2, style, look];
  @override
  String get aliasedName => _alias ?? 'accf_accessory';
  @override
  String get actualTableName => 'accf_accessory';
  @override
  VerificationContext validateIntegrity(Insertable<AccfAccessoryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    if (data.containsKey('Look')) {
      context.handle(
          _lookMeta, look.isAcceptableOrUnknown(data['Look']!, _lookMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfAccessoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfAccessoryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfAccessory createAlias(String alias) {
    return AccfAccessory(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfCarpetData extends DataClass implements Insertable<AccfCarpetData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? series;
  AccfCarpetData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.series});
  factory AccfCarpetData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfCarpetData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AccfCarpetCompanion toCompanion(bool nullToAbsent) {
    return AccfCarpetCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AccfCarpetData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfCarpetData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AccfCarpetData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? series}) =>
      AccfCarpetData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AccfCarpetData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, price, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfCarpetData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.series == this.series);
}

class AccfCarpetCompanion extends UpdateCompanion<AccfCarpetData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> series;
  const AccfCarpetCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  AccfCarpetCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AccfCarpetData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (series != null) 'Series': series,
    });
  }

  AccfCarpetCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? series}) {
    return AccfCarpetCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfCarpetCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AccfCarpet extends Table with TableInfo<AccfCarpet, AccfCarpetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfCarpet(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price, series];
  @override
  String get aliasedName => _alias ?? 'accf_carpet';
  @override
  String get actualTableName => 'accf_carpet';
  @override
  VerificationContext validateIntegrity(Insertable<AccfCarpetData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfCarpetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfCarpetData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfCarpet createAlias(String alias) {
    return AccfCarpet(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfFossilData extends DataClass implements Insertable<AccfFossilData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? color1;
  final String? color2;
  AccfFossilData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.color1,
      this.color2});
  factory AccfFossilData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfFossilData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AccfFossilCompanion toCompanion(bool nullToAbsent) {
    return AccfFossilCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AccfFossilData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfFossilData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AccfFossilData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? color1,
          String? color2}) =>
      AccfFossilData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AccfFossilData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfFossilData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AccfFossilCompanion extends UpdateCompanion<AccfFossilData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  const AccfFossilCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AccfFossilCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AccfFossilData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AccfFossilCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AccfFossilCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfFossilCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AccfFossil extends Table with TableInfo<AccfFossil, AccfFossilData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfFossil(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, color1, color2];
  @override
  String get aliasedName => _alias ?? 'accf_fossil';
  @override
  String get actualTableName => 'accf_fossil';
  @override
  VerificationContext validateIntegrity(Insertable<AccfFossilData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfFossilData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfFossilData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfFossil createAlias(String alias) {
    return AccfFossil(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfFishData extends DataClass implements Insertable<AccfFishData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? size;
  final String? shadow;
  final String? from;
  final String? times;
  AccfFishData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.size,
      this.shadow,
      this.from,
      this.times});
  factory AccfFishData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfFishData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      size: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Size']),
      shadow: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Shadow']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || size != null) {
      map['Size'] = Variable<String?>(size);
    }
    if (!nullToAbsent || shadow != null) {
      map['Shadow'] = Variable<String?>(shadow);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AccfFishCompanion toCompanion(bool nullToAbsent) {
    return AccfFishCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      shadow:
          shadow == null && nullToAbsent ? const Value.absent() : Value(shadow),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AccfFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfFishData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      size: serializer.fromJson<String?>(json['Size']),
      shadow: serializer.fromJson<String?>(json['Shadow']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'Size': serializer.toJson<String?>(size),
      'Shadow': serializer.toJson<String?>(shadow),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AccfFishData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? size,
          String? shadow,
          String? from,
          String? times}) =>
      AccfFishData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        size: size ?? this.size,
        shadow: shadow ?? this.shadow,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AccfFishData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, size, shadow, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfFishData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.size == this.size &&
          other.shadow == this.shadow &&
          other.from == this.from &&
          other.times == this.times);
}

class AccfFishCompanion extends UpdateCompanion<AccfFishData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> size;
  final Value<String?> shadow;
  final Value<String?> from;
  final Value<String?> times;
  const AccfFishCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AccfFishCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AccfFishData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? size,
    Expression<String?>? shadow,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (size != null) 'Size': size,
      if (shadow != null) 'Shadow': shadow,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AccfFishCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? size,
      Value<String?>? shadow,
      Value<String?>? from,
      Value<String?>? times}) {
    return AccfFishCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      size: size ?? this.size,
      shadow: shadow ?? this.shadow,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (size.present) {
      map['Size'] = Variable<String?>(size.value);
    }
    if (shadow.present) {
      map['Shadow'] = Variable<String?>(shadow.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfFishCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AccfFish extends Table with TableInfo<AccfFish, AccfFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _sizeMeta = const VerificationMeta('size');
  late final GeneratedColumn<String?> size = GeneratedColumn<String?>(
      'Size', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _shadowMeta = const VerificationMeta('shadow');
  late final GeneratedColumn<String?> shadow = GeneratedColumn<String?>(
      'Shadow', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, size, shadow, from, times];
  @override
  String get aliasedName => _alias ?? 'accf_fish';
  @override
  String get actualTableName => 'accf_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Size')) {
      context.handle(
          _sizeMeta, size.isAcceptableOrUnknown(data['Size']!, _sizeMeta));
    }
    if (data.containsKey('Shadow')) {
      context.handle(_shadowMeta,
          shadow.isAcceptableOrUnknown(data['Shadow']!, _shadowMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfFish createAlias(String alias) {
    return AccfFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfFurnitureData extends DataClass
    implements Insertable<AccfFurnitureData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? color1;
  final String? color2;
  final String? concept1;
  final String? concept2;
  AccfFurnitureData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.color1,
      this.color2,
      this.concept1,
      this.concept2});
  factory AccfFurnitureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfFurnitureData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    return map;
  }

  AccfFurnitureCompanion toCompanion(bool nullToAbsent) {
    return AccfFurnitureCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
    );
  }

  factory AccfFurnitureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfFurnitureData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
    };
  }

  AccfFurnitureData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? color1,
          String? color2,
          String? concept1,
          String? concept2}) =>
      AccfFurnitureData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
      );
  @override
  String toString() {
    return (StringBuffer('AccfFurnitureData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, price,
      color1, color2, concept1, concept2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfFurnitureData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2 &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2);
}

class AccfFurnitureCompanion extends UpdateCompanion<AccfFurnitureData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  final Value<String?> concept1;
  final Value<String?> concept2;
  const AccfFurnitureCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
  });
  AccfFurnitureCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
  });
  static Insertable<AccfFurnitureData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
    });
  }

  AccfFurnitureCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2,
      Value<String?>? concept1,
      Value<String?>? concept2}) {
    return AccfFurnitureCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfFurnitureCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2')
          ..write(')'))
        .toString();
  }
}

class AccfFurniture extends Table
    with TableInfo<AccfFurniture, AccfFurnitureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfFurniture(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        index,
        selected,
        name,
        status,
        from,
        price,
        color1,
        color2,
        concept1,
        concept2
      ];
  @override
  String get aliasedName => _alias ?? 'accf_furniture';
  @override
  String get actualTableName => 'accf_furniture';
  @override
  VerificationContext validateIntegrity(Insertable<AccfFurnitureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfFurnitureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfFurnitureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfFurniture createAlias(String alias) {
    return AccfFurniture(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfGyroidData extends DataClass implements Insertable<AccfGyroidData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? color1;
  final String? color2;
  AccfGyroidData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.color1,
      this.color2});
  factory AccfGyroidData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfGyroidData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AccfGyroidCompanion toCompanion(bool nullToAbsent) {
    return AccfGyroidCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AccfGyroidData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfGyroidData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AccfGyroidData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? color1,
          String? color2}) =>
      AccfGyroidData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AccfGyroidData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfGyroidData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AccfGyroidCompanion extends UpdateCompanion<AccfGyroidData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  const AccfGyroidCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AccfGyroidCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AccfGyroidData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AccfGyroidCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AccfGyroidCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfGyroidCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AccfGyroid extends Table with TableInfo<AccfGyroid, AccfGyroidData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfGyroid(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, color1, color2];
  @override
  String get aliasedName => _alias ?? 'accf_gyroid';
  @override
  String get actualTableName => 'accf_gyroid';
  @override
  VerificationContext validateIntegrity(Insertable<AccfGyroidData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfGyroidData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfGyroidData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfGyroid createAlias(String alias) {
    return AccfGyroid(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfInsectData extends DataClass implements Insertable<AccfInsectData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? absent;
  final String? price;
  final String? size;
  final String? from;
  final String? times;
  AccfInsectData(
      {this.index,
      this.selected,
      this.name,
      this.absent,
      this.price,
      this.size,
      this.from,
      this.times});
  factory AccfInsectData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfInsectData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      absent: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Absent']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      size: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Size']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || absent != null) {
      map['Absent'] = Variable<String?>(absent);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || size != null) {
      map['Size'] = Variable<String?>(size);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AccfInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfInsectCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      absent:
          absent == null && nullToAbsent ? const Value.absent() : Value(absent),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AccfInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfInsectData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      absent: serializer.fromJson<String?>(json['Absent']),
      price: serializer.fromJson<String?>(json['Price']),
      size: serializer.fromJson<String?>(json['Size']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Absent': serializer.toJson<String?>(absent),
      'Price': serializer.toJson<String?>(price),
      'Size': serializer.toJson<String?>(size),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AccfInsectData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? absent,
          String? price,
          String? size,
          String? from,
          String? times}) =>
      AccfInsectData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        absent: absent ?? this.absent,
        price: price ?? this.price,
        size: size ?? this.size,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AccfInsectData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('absent: $absent, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, absent, price, size, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfInsectData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.absent == this.absent &&
          other.price == this.price &&
          other.size == this.size &&
          other.from == this.from &&
          other.times == this.times);
}

class AccfInsectCompanion extends UpdateCompanion<AccfInsectData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> absent;
  final Value<String?> price;
  final Value<String?> size;
  final Value<String?> from;
  final Value<String?> times;
  const AccfInsectCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.absent = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AccfInsectCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.absent = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AccfInsectData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? absent,
    Expression<String?>? price,
    Expression<String?>? size,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (absent != null) 'Absent': absent,
      if (price != null) 'Price': price,
      if (size != null) 'Size': size,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AccfInsectCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? absent,
      Value<String?>? price,
      Value<String?>? size,
      Value<String?>? from,
      Value<String?>? times}) {
    return AccfInsectCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      absent: absent ?? this.absent,
      price: price ?? this.price,
      size: size ?? this.size,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (absent.present) {
      map['Absent'] = Variable<String?>(absent.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (size.present) {
      map['Size'] = Variable<String?>(size.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfInsectCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('absent: $absent, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AccfInsect extends Table with TableInfo<AccfInsect, AccfInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _absentMeta = const VerificationMeta('absent');
  late final GeneratedColumn<String?> absent = GeneratedColumn<String?>(
      'Absent', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _sizeMeta = const VerificationMeta('size');
  late final GeneratedColumn<String?> size = GeneratedColumn<String?>(
      'Size', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, absent, price, size, from, times];
  @override
  String get aliasedName => _alias ?? 'accf_insect';
  @override
  String get actualTableName => 'accf_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Absent')) {
      context.handle(_absentMeta,
          absent.isAcceptableOrUnknown(data['Absent']!, _absentMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Size')) {
      context.handle(
          _sizeMeta, size.isAcceptableOrUnknown(data['Size']!, _sizeMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfInsect createAlias(String alias) {
    return AccfInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfPaintingData extends DataClass
    implements Insertable<AccfPaintingData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? color1;
  final String? color2;
  AccfPaintingData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.color1,
      this.color2});
  factory AccfPaintingData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfPaintingData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AccfPaintingCompanion toCompanion(bool nullToAbsent) {
    return AccfPaintingCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AccfPaintingData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfPaintingData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AccfPaintingData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? color1,
          String? color2}) =>
      AccfPaintingData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AccfPaintingData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, price, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfPaintingData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AccfPaintingCompanion extends UpdateCompanion<AccfPaintingData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  const AccfPaintingCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AccfPaintingCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AccfPaintingData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AccfPaintingCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AccfPaintingCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfPaintingCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AccfPainting extends Table
    with TableInfo<AccfPainting, AccfPaintingData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfPainting(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price, color1, color2];
  @override
  String get aliasedName => _alias ?? 'accf_painting';
  @override
  String get actualTableName => 'accf_painting';
  @override
  VerificationContext validateIntegrity(Insertable<AccfPaintingData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfPaintingData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfPaintingData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfPainting createAlias(String alias) {
    return AccfPainting(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfShirtData extends DataClass implements Insertable<AccfShirtData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? season;
  final String? price;
  final String? color1;
  final String? color2;
  final String? style;
  final String? look;
  AccfShirtData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.season,
      this.price,
      this.color1,
      this.color2,
      this.style,
      this.look});
  factory AccfShirtData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfShirtData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      season: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Season']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
      look: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Look']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || season != null) {
      map['Season'] = Variable<String?>(season);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    if (!nullToAbsent || look != null) {
      map['Look'] = Variable<String?>(look);
    }
    return map;
  }

  AccfShirtCompanion toCompanion(bool nullToAbsent) {
    return AccfShirtCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      season:
          season == null && nullToAbsent ? const Value.absent() : Value(season),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
      look: look == null && nullToAbsent ? const Value.absent() : Value(look),
    );
  }

  factory AccfShirtData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfShirtData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      season: serializer.fromJson<String?>(json['Season']),
      price: serializer.fromJson<String?>(json['Price']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
      style: serializer.fromJson<String?>(json['Style']),
      look: serializer.fromJson<String?>(json['Look']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Season': serializer.toJson<String?>(season),
      'Price': serializer.toJson<String?>(price),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
      'Style': serializer.toJson<String?>(style),
      'Look': serializer.toJson<String?>(look),
    };
  }

  AccfShirtData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? season,
          String? price,
          String? color1,
          String? color2,
          String? style,
          String? look}) =>
      AccfShirtData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        season: season ?? this.season,
        price: price ?? this.price,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
        style: style ?? this.style,
        look: look ?? this.look,
      );
  @override
  String toString() {
    return (StringBuffer('AccfShirtData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('season: $season, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('style: $style, ')
          ..write('look: $look')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, season,
      price, color1, color2, style, look);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfShirtData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.season == this.season &&
          other.price == this.price &&
          other.color1 == this.color1 &&
          other.color2 == this.color2 &&
          other.style == this.style &&
          other.look == this.look);
}

class AccfShirtCompanion extends UpdateCompanion<AccfShirtData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> season;
  final Value<String?> price;
  final Value<String?> color1;
  final Value<String?> color2;
  final Value<String?> style;
  final Value<String?> look;
  const AccfShirtCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.season = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.style = const Value.absent(),
    this.look = const Value.absent(),
  });
  AccfShirtCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.season = const Value.absent(),
    this.price = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
    this.style = const Value.absent(),
    this.look = const Value.absent(),
  });
  static Insertable<AccfShirtData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? season,
    Expression<String?>? price,
    Expression<String?>? color1,
    Expression<String?>? color2,
    Expression<String?>? style,
    Expression<String?>? look,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (season != null) 'Season': season,
      if (price != null) 'Price': price,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
      if (style != null) 'Style': style,
      if (look != null) 'Look': look,
    });
  }

  AccfShirtCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? season,
      Value<String?>? price,
      Value<String?>? color1,
      Value<String?>? color2,
      Value<String?>? style,
      Value<String?>? look}) {
    return AccfShirtCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      season: season ?? this.season,
      price: price ?? this.price,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
      style: style ?? this.style,
      look: look ?? this.look,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (season.present) {
      map['Season'] = Variable<String?>(season.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    if (look.present) {
      map['Look'] = Variable<String?>(look.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfShirtCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('season: $season, ')
          ..write('price: $price, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2, ')
          ..write('style: $style, ')
          ..write('look: $look')
          ..write(')'))
        .toString();
  }
}

class AccfShirt extends Table with TableInfo<AccfShirt, AccfShirtData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfShirt(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seasonMeta = const VerificationMeta('season');
  late final GeneratedColumn<String?> season = GeneratedColumn<String?>(
      'Season', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _lookMeta = const VerificationMeta('look');
  late final GeneratedColumn<String?> look = GeneratedColumn<String?>(
      'Look', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        index,
        selected,
        name,
        status,
        from,
        season,
        price,
        color1,
        color2,
        style,
        look
      ];
  @override
  String get aliasedName => _alias ?? 'accf_shirt';
  @override
  String get actualTableName => 'accf_shirt';
  @override
  VerificationContext validateIntegrity(Insertable<AccfShirtData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Season')) {
      context.handle(_seasonMeta,
          season.isAcceptableOrUnknown(data['Season']!, _seasonMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    if (data.containsKey('Look')) {
      context.handle(
          _lookMeta, look.isAcceptableOrUnknown(data['Look']!, _lookMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfShirtData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfShirtData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfShirt createAlias(String alias) {
    return AccfShirt(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfSongData extends DataClass implements Insertable<AccfSongData> {
  final int? index;
  final int? selected;
  final String? name;
  AccfSongData({this.index, this.selected, this.name});
  factory AccfSongData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfSongData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    return map;
  }

  AccfSongCompanion toCompanion(bool nullToAbsent) {
    return AccfSongCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
    );
  }

  factory AccfSongData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfSongData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
    };
  }

  AccfSongData copyWith({int? index, int? selected, String? name}) =>
      AccfSongData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('AccfSongData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfSongData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name);
}

class AccfSongCompanion extends UpdateCompanion<AccfSongData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  const AccfSongCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  AccfSongCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
  });
  static Insertable<AccfSongData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
    });
  }

  AccfSongCompanion copyWith(
      {Value<int?>? index, Value<int?>? selected, Value<String?>? name}) {
    return AccfSongCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfSongCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class AccfSong extends Table with TableInfo<AccfSong, AccfSongData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfSong(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name];
  @override
  String get aliasedName => _alias ?? 'accf_song';
  @override
  String get actualTableName => 'accf_song';
  @override
  VerificationContext validateIntegrity(Insertable<AccfSongData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfSongData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfSongData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfSong createAlias(String alias) {
    return AccfSong(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfStationeryData extends DataClass
    implements Insertable<AccfStationeryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  AccfStationeryData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price});
  factory AccfStationeryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfStationeryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    return map;
  }

  AccfStationeryCompanion toCompanion(bool nullToAbsent) {
    return AccfStationeryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
    );
  }

  factory AccfStationeryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfStationeryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
    };
  }

  AccfStationeryData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price}) =>
      AccfStationeryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
      );
  @override
  String toString() {
    return (StringBuffer('AccfStationeryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, price);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfStationeryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price);
}

class AccfStationeryCompanion extends UpdateCompanion<AccfStationeryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  const AccfStationeryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  AccfStationeryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  static Insertable<AccfStationeryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
    });
  }

  AccfStationeryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price}) {
    return AccfStationeryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfStationeryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }
}

class AccfStationery extends Table
    with TableInfo<AccfStationery, AccfStationeryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfStationery(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price];
  @override
  String get aliasedName => _alias ?? 'accf_stationery';
  @override
  String get actualTableName => 'accf_stationery';
  @override
  VerificationContext validateIntegrity(Insertable<AccfStationeryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfStationeryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfStationeryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfStationery createAlias(String alias) {
    return AccfStationery(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfToolData extends DataClass implements Insertable<AccfToolData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  AccfToolData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price});
  factory AccfToolData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfToolData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    return map;
  }

  AccfToolCompanion toCompanion(bool nullToAbsent) {
    return AccfToolCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
    );
  }

  factory AccfToolData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfToolData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
    };
  }

  AccfToolData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price}) =>
      AccfToolData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
      );
  @override
  String toString() {
    return (StringBuffer('AccfToolData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from, price);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfToolData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price);
}

class AccfToolCompanion extends UpdateCompanion<AccfToolData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  const AccfToolCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  AccfToolCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
  });
  static Insertable<AccfToolData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
    });
  }

  AccfToolCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price}) {
    return AccfToolCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfToolCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }
}

class AccfTool extends Table with TableInfo<AccfTool, AccfToolData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfTool(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price];
  @override
  String get aliasedName => _alias ?? 'accf_tool';
  @override
  String get actualTableName => 'accf_tool';
  @override
  VerificationContext validateIntegrity(Insertable<AccfToolData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfToolData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfToolData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfTool createAlias(String alias) {
    return AccfTool(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfWallpaperData extends DataClass
    implements Insertable<AccfWallpaperData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? price;
  final String? series;
  AccfWallpaperData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.price,
      this.series});
  factory AccfWallpaperData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfWallpaperData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AccfWallpaperCompanion toCompanion(bool nullToAbsent) {
    return AccfWallpaperCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AccfWallpaperData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfWallpaperData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      price: serializer.fromJson<String?>(json['Price']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Price': serializer.toJson<String?>(price),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AccfWallpaperData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? price,
          String? series}) =>
      AccfWallpaperData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        price: price ?? this.price,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AccfWallpaperData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, price, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfWallpaperData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.price == this.price &&
          other.series == this.series);
}

class AccfWallpaperCompanion extends UpdateCompanion<AccfWallpaperData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> price;
  final Value<String?> series;
  const AccfWallpaperCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  AccfWallpaperCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.price = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AccfWallpaperData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? price,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (price != null) 'Price': price,
      if (series != null) 'Series': series,
    });
  }

  AccfWallpaperCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? price,
      Value<String?>? series}) {
    return AccfWallpaperCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      price: price ?? this.price,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfWallpaperCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('price: $price, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AccfWallpaper extends Table
    with TableInfo<AccfWallpaper, AccfWallpaperData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfWallpaper(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, price, series];
  @override
  String get aliasedName => _alias ?? 'accf_wallpaper';
  @override
  String get actualTableName => 'accf_wallpaper';
  @override
  VerificationContext validateIntegrity(Insertable<AccfWallpaperData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfWallpaperData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfWallpaperData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfWallpaper createAlias(String alias) {
    return AccfWallpaper(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAccessoryData extends DataClass
    implements Insertable<AcnlAccessoryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlAccessoryData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlAccessoryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAccessoryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlAccessoryCompanion toCompanion(bool nullToAbsent) {
    return AcnlAccessoryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlAccessoryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAccessoryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlAccessoryData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlAccessoryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAccessoryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAccessoryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlAccessoryCompanion extends UpdateCompanion<AcnlAccessoryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlAccessoryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlAccessoryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlAccessoryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlAccessoryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlAccessoryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAccessoryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlAccessory extends Table
    with TableInfo<AcnlAccessory, AcnlAccessoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAccessory(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_accessory';
  @override
  String get actualTableName => 'acnl_accessory';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAccessoryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAccessoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAccessoryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAccessory createAlias(String alias) {
    return AcnlAccessory(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlArtData extends DataClass implements Insertable<AcnlArtData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlArtData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlArtData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlArtData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlArtCompanion toCompanion(bool nullToAbsent) {
    return AcnlArtCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlArtData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlArtData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlArtData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlArtData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlArtData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlArtData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlArtCompanion extends UpdateCompanion<AcnlArtData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlArtCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlArtCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlArtData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlArtCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlArtCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlArtCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlArt extends Table with TableInfo<AcnlArt, AcnlArtData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlArt(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_art';
  @override
  String get actualTableName => 'acnl_art';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlArtData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlArtData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlArtData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlArt createAlias(String alias) {
    return AcnlArt(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlBottomData extends DataClass implements Insertable<AcnlBottomData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlBottomData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlBottomData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlBottomData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlBottomCompanion toCompanion(bool nullToAbsent) {
    return AcnlBottomCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlBottomData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlBottomData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlBottomData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlBottomData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlBottomData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlBottomData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlBottomCompanion extends UpdateCompanion<AcnlBottomData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlBottomCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlBottomCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlBottomData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlBottomCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlBottomCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlBottomCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlBottom extends Table with TableInfo<AcnlBottom, AcnlBottomData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlBottom(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_bottom';
  @override
  String get actualTableName => 'acnl_bottom';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlBottomData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlBottomData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlBottomData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlBottom createAlias(String alias) {
    return AcnlBottom(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlCarpetData extends DataClass implements Insertable<AcnlCarpetData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  AcnlCarpetData(
      {this.index, this.selected, this.name, this.status, this.from});
  factory AcnlCarpetData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlCarpetData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlCarpetCompanion toCompanion(bool nullToAbsent) {
    return AcnlCarpetCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlCarpetData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlCarpetData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlCarpetData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from}) =>
      AcnlCarpetData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlCarpetData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlCarpetData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from);
}

class AcnlCarpetCompanion extends UpdateCompanion<AcnlCarpetData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  const AcnlCarpetCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlCarpetCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlCarpetData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
    });
  }

  AcnlCarpetCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from}) {
    return AcnlCarpetCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlCarpetCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlCarpet extends Table with TableInfo<AcnlCarpet, AcnlCarpetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlCarpet(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, status, from];
  @override
  String get aliasedName => _alias ?? 'acnl_carpet';
  @override
  String get actualTableName => 'acnl_carpet';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlCarpetData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlCarpetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlCarpetData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlCarpet createAlias(String alias) {
    return AcnlCarpet(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlDlcData extends DataClass implements Insertable<AcnlDlcData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlDlcData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlDlcData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlDlcData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlDlcCompanion toCompanion(bool nullToAbsent) {
    return AcnlDlcCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlDlcData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlDlcData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlDlcData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlDlcData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlDlcData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlDlcData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlDlcCompanion extends UpdateCompanion<AcnlDlcData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlDlcCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlDlcCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlDlcData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlDlcCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlDlcCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlDlcCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlDlc extends Table with TableInfo<AcnlDlc, AcnlDlcData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlDlc(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_dlc';
  @override
  String get actualTableName => 'acnl_dlc';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlDlcData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlDlcData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlDlcData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlDlc createAlias(String alias) {
    return AcnlDlc(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlDres extends DataClass implements Insertable<AcnlDres> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlDres(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlDres.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlDres(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlDressCompanion toCompanion(bool nullToAbsent) {
    return AcnlDressCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlDres.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlDres(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlDres copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlDres(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlDres(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlDres &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlDressCompanion extends UpdateCompanion<AcnlDres> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlDressCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlDressCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlDres> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlDressCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlDressCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlDressCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlDress extends Table with TableInfo<AcnlDress, AcnlDres> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlDress(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_dress';
  @override
  String get actualTableName => 'acnl_dress';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlDres> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlDres map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlDres.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlDress createAlias(String alias) {
    return AcnlDress(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFeetData extends DataClass implements Insertable<AcnlFeetData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlFeetData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlFeetData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFeetData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlFeetCompanion toCompanion(bool nullToAbsent) {
    return AcnlFeetCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlFeetData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFeetData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlFeetData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlFeetData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFeetData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFeetData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlFeetCompanion extends UpdateCompanion<AcnlFeetData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlFeetCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlFeetCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlFeetData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlFeetCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlFeetCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFeetCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlFeet extends Table with TableInfo<AcnlFeet, AcnlFeetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFeet(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_feet';
  @override
  String get actualTableName => 'acnl_feet';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlFeetData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFeetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFeetData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFeet createAlias(String alias) {
    return AcnlFeet(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFishData extends DataClass implements Insertable<AcnlFishData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? size;
  final String? shadow;
  final String? from;
  final String? times;
  AcnlFishData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.size,
      this.shadow,
      this.from,
      this.times});
  factory AcnlFishData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFishData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      size: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Size']),
      shadow: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Shadow']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || size != null) {
      map['Size'] = Variable<String?>(size);
    }
    if (!nullToAbsent || shadow != null) {
      map['Shadow'] = Variable<String?>(shadow);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcnlFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlFishCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      shadow:
          shadow == null && nullToAbsent ? const Value.absent() : Value(shadow),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcnlFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFishData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      size: serializer.fromJson<String?>(json['Size']),
      shadow: serializer.fromJson<String?>(json['Shadow']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'Size': serializer.toJson<String?>(size),
      'Shadow': serializer.toJson<String?>(shadow),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcnlFishData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? size,
          String? shadow,
          String? from,
          String? times}) =>
      AcnlFishData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        size: size ?? this.size,
        shadow: shadow ?? this.shadow,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFishData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, size, shadow, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFishData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.size == this.size &&
          other.shadow == this.shadow &&
          other.from == this.from &&
          other.times == this.times);
}

class AcnlFishCompanion extends UpdateCompanion<AcnlFishData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> size;
  final Value<String?> shadow;
  final Value<String?> from;
  final Value<String?> times;
  const AcnlFishCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcnlFishCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcnlFishData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? size,
    Expression<String?>? shadow,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (size != null) 'Size': size,
      if (shadow != null) 'Shadow': shadow,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AcnlFishCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? size,
      Value<String?>? shadow,
      Value<String?>? from,
      Value<String?>? times}) {
    return AcnlFishCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      size: size ?? this.size,
      shadow: shadow ?? this.shadow,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (size.present) {
      map['Size'] = Variable<String?>(size.value);
    }
    if (shadow.present) {
      map['Shadow'] = Variable<String?>(shadow.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFishCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcnlFish extends Table with TableInfo<AcnlFish, AcnlFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _sizeMeta = const VerificationMeta('size');
  late final GeneratedColumn<String?> size = GeneratedColumn<String?>(
      'Size', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _shadowMeta = const VerificationMeta('shadow');
  late final GeneratedColumn<String?> shadow = GeneratedColumn<String?>(
      'Shadow', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, size, shadow, from, times];
  @override
  String get aliasedName => _alias ?? 'acnl_fish';
  @override
  String get actualTableName => 'acnl_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Size')) {
      context.handle(
          _sizeMeta, size.isAcceptableOrUnknown(data['Size']!, _sizeMeta));
    }
    if (data.containsKey('Shadow')) {
      context.handle(_shadowMeta,
          shadow.isAcceptableOrUnknown(data['Shadow']!, _shadowMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFish createAlias(String alias) {
    return AcnlFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFossilData extends DataClass implements Insertable<AcnlFossilData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlFossilData(
      {this.index,
      this.selected,
      this.name,
      this.from,
      this.color1,
      this.color2});
  factory AcnlFossilData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFossilData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlFossilCompanion toCompanion(bool nullToAbsent) {
    return AcnlFossilCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlFossilData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFossilData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlFossilData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlFossilData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFossilData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFossilData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlFossilCompanion extends UpdateCompanion<AcnlFossilData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlFossilCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlFossilCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlFossilData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlFossilCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlFossilCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFossilCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlFossil extends Table with TableInfo<AcnlFossil, AcnlFossilData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFossil(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_fossil';
  @override
  String get actualTableName => 'acnl_fossil';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlFossilData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFossilData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFossilData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFossil createAlias(String alias) {
    return AcnlFossil(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFossilModelData extends DataClass
    implements Insertable<AcnlFossilModelData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnlFossilModelData({this.index, this.selected, this.name, this.from});
  factory AcnlFossilModelData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFossilModelData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlFossilModelCompanion toCompanion(bool nullToAbsent) {
    return AcnlFossilModelCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlFossilModelData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFossilModelData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlFossilModelData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnlFossilModelData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFossilModelData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFossilModelData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnlFossilModelCompanion extends UpdateCompanion<AcnlFossilModelData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnlFossilModelCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlFossilModelCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlFossilModelData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnlFossilModelCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnlFossilModelCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFossilModelCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlFossilModel extends Table
    with TableInfo<AcnlFossilModel, AcnlFossilModelData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFossilModel(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnl_fossil_model';
  @override
  String get actualTableName => 'acnl_fossil_model';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnlFossilModelData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFossilModelData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFossilModelData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFossilModel createAlias(String alias) {
    return AcnlFossilModel(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFurnitureData extends DataClass
    implements Insertable<AcnlFurnitureData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlFurnitureData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlFurnitureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFurnitureData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlFurnitureCompanion toCompanion(bool nullToAbsent) {
    return AcnlFurnitureCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlFurnitureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFurnitureData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlFurnitureData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlFurnitureData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFurnitureData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFurnitureData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlFurnitureCompanion extends UpdateCompanion<AcnlFurnitureData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlFurnitureCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlFurnitureCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlFurnitureData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlFurnitureCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlFurnitureCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFurnitureCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlFurniture extends Table
    with TableInfo<AcnlFurniture, AcnlFurnitureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFurniture(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_furniture';
  @override
  String get actualTableName => 'acnl_furniture';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlFurnitureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFurnitureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFurnitureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFurniture createAlias(String alias) {
    return AcnlFurniture(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlGyroidData extends DataClass implements Insertable<AcnlGyroidData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlGyroidData(
      {this.index,
      this.selected,
      this.name,
      this.from,
      this.color1,
      this.color2});
  factory AcnlGyroidData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlGyroidData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlGyroidCompanion toCompanion(bool nullToAbsent) {
    return AcnlGyroidCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlGyroidData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlGyroidData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlGyroidData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlGyroidData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlGyroidData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlGyroidData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlGyroidCompanion extends UpdateCompanion<AcnlGyroidData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlGyroidCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlGyroidCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlGyroidData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlGyroidCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlGyroidCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlGyroidCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlGyroid extends Table with TableInfo<AcnlGyroid, AcnlGyroidData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlGyroid(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_gyroid';
  @override
  String get actualTableName => 'acnl_gyroid';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlGyroidData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlGyroidData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlGyroidData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlGyroid createAlias(String alias) {
    return AcnlGyroid(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlHatData extends DataClass implements Insertable<AcnlHatData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlHatData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlHatData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlHatData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlHatCompanion toCompanion(bool nullToAbsent) {
    return AcnlHatCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlHatData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlHatData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlHatData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlHatData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlHatData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlHatData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlHatCompanion extends UpdateCompanion<AcnlHatData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlHatCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlHatCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlHatData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlHatCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlHatCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlHatCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlHat extends Table with TableInfo<AcnlHat, AcnlHatData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlHat(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_hat';
  @override
  String get actualTableName => 'acnl_hat';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlHatData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlHatData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlHatData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlHat createAlias(String alias) {
    return AcnlHat(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlInsectData extends DataClass implements Insertable<AcnlInsectData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? absent;
  final String? price;
  final String? color;
  final String? size;
  final String? from;
  final String? times;
  AcnlInsectData(
      {this.index,
      this.selected,
      this.name,
      this.absent,
      this.price,
      this.color,
      this.size,
      this.from,
      this.times});
  factory AcnlInsectData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlInsectData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      absent: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Absent']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      color: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color']),
      size: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Size']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || absent != null) {
      map['Absent'] = Variable<String?>(absent);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || color != null) {
      map['Color'] = Variable<String?>(color);
    }
    if (!nullToAbsent || size != null) {
      map['Size'] = Variable<String?>(size);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcnlInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlInsectCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      absent:
          absent == null && nullToAbsent ? const Value.absent() : Value(absent),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      color:
          color == null && nullToAbsent ? const Value.absent() : Value(color),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcnlInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlInsectData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      absent: serializer.fromJson<String?>(json['Absent']),
      price: serializer.fromJson<String?>(json['Price']),
      color: serializer.fromJson<String?>(json['Color']),
      size: serializer.fromJson<String?>(json['Size']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Absent': serializer.toJson<String?>(absent),
      'Price': serializer.toJson<String?>(price),
      'Color': serializer.toJson<String?>(color),
      'Size': serializer.toJson<String?>(size),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcnlInsectData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? absent,
          String? price,
          String? color,
          String? size,
          String? from,
          String? times}) =>
      AcnlInsectData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        absent: absent ?? this.absent,
        price: price ?? this.price,
        color: color ?? this.color,
        size: size ?? this.size,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlInsectData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('absent: $absent, ')
          ..write('price: $price, ')
          ..write('color: $color, ')
          ..write('size: $size, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, absent, price, color, size, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlInsectData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.absent == this.absent &&
          other.price == this.price &&
          other.color == this.color &&
          other.size == this.size &&
          other.from == this.from &&
          other.times == this.times);
}

class AcnlInsectCompanion extends UpdateCompanion<AcnlInsectData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> absent;
  final Value<String?> price;
  final Value<String?> color;
  final Value<String?> size;
  final Value<String?> from;
  final Value<String?> times;
  const AcnlInsectCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.absent = const Value.absent(),
    this.price = const Value.absent(),
    this.color = const Value.absent(),
    this.size = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcnlInsectCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.absent = const Value.absent(),
    this.price = const Value.absent(),
    this.color = const Value.absent(),
    this.size = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcnlInsectData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? absent,
    Expression<String?>? price,
    Expression<String?>? color,
    Expression<String?>? size,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (absent != null) 'Absent': absent,
      if (price != null) 'Price': price,
      if (color != null) 'Color': color,
      if (size != null) 'Size': size,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AcnlInsectCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? absent,
      Value<String?>? price,
      Value<String?>? color,
      Value<String?>? size,
      Value<String?>? from,
      Value<String?>? times}) {
    return AcnlInsectCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      absent: absent ?? this.absent,
      price: price ?? this.price,
      color: color ?? this.color,
      size: size ?? this.size,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (absent.present) {
      map['Absent'] = Variable<String?>(absent.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (color.present) {
      map['Color'] = Variable<String?>(color.value);
    }
    if (size.present) {
      map['Size'] = Variable<String?>(size.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlInsectCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('absent: $absent, ')
          ..write('price: $price, ')
          ..write('color: $color, ')
          ..write('size: $size, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcnlInsect extends Table with TableInfo<AcnlInsect, AcnlInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _absentMeta = const VerificationMeta('absent');
  late final GeneratedColumn<String?> absent = GeneratedColumn<String?>(
      'Absent', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _colorMeta = const VerificationMeta('color');
  late final GeneratedColumn<String?> color = GeneratedColumn<String?>(
      'Color', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _sizeMeta = const VerificationMeta('size');
  late final GeneratedColumn<String?> size = GeneratedColumn<String?>(
      'Size', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, absent, price, color, size, from, times];
  @override
  String get aliasedName => _alias ?? 'acnl_insect';
  @override
  String get actualTableName => 'acnl_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Absent')) {
      context.handle(_absentMeta,
          absent.isAcceptableOrUnknown(data['Absent']!, _absentMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Color')) {
      context.handle(
          _colorMeta, color.isAcceptableOrUnknown(data['Color']!, _colorMeta));
    }
    if (data.containsKey('Size')) {
      context.handle(
          _sizeMeta, size.isAcceptableOrUnknown(data['Size']!, _sizeMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlInsect createAlias(String alias) {
    return AcnlInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlMusicBoxData extends DataClass
    implements Insertable<AcnlMusicBoxData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnlMusicBoxData({this.index, this.selected, this.name, this.from});
  factory AcnlMusicBoxData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlMusicBoxData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlMusicBoxCompanion toCompanion(bool nullToAbsent) {
    return AcnlMusicBoxCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlMusicBoxData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlMusicBoxData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlMusicBoxData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnlMusicBoxData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlMusicBoxData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlMusicBoxData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnlMusicBoxCompanion extends UpdateCompanion<AcnlMusicBoxData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnlMusicBoxCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlMusicBoxCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlMusicBoxData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnlMusicBoxCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnlMusicBoxCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlMusicBoxCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlMusicBox extends Table
    with TableInfo<AcnlMusicBox, AcnlMusicBoxData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlMusicBox(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnl_music_box';
  @override
  String get actualTableName => 'acnl_music_box';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlMusicBoxData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlMusicBoxData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlMusicBoxData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlMusicBox createAlias(String alias) {
    return AcnlMusicBox(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSeafoodData extends DataClass implements Insertable<AcnlSeafoodData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? size;
  final String? shadow;
  final String? from;
  final String? times;
  AcnlSeafoodData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.size,
      this.shadow,
      this.from,
      this.times});
  factory AcnlSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSeafoodData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      size: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Size']),
      shadow: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Shadow']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || size != null) {
      map['Size'] = Variable<String?>(size);
    }
    if (!nullToAbsent || shadow != null) {
      map['Shadow'] = Variable<String?>(shadow);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcnlSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlSeafoodCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      size: size == null && nullToAbsent ? const Value.absent() : Value(size),
      shadow:
          shadow == null && nullToAbsent ? const Value.absent() : Value(shadow),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcnlSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSeafoodData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      size: serializer.fromJson<String?>(json['Size']),
      shadow: serializer.fromJson<String?>(json['Shadow']),
      from: serializer.fromJson<String?>(json['From']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'Size': serializer.toJson<String?>(size),
      'Shadow': serializer.toJson<String?>(shadow),
      'From': serializer.toJson<String?>(from),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcnlSeafoodData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? size,
          String? shadow,
          String? from,
          String? times}) =>
      AcnlSeafoodData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        size: size ?? this.size,
        shadow: shadow ?? this.shadow,
        from: from ?? this.from,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSeafoodData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, size, shadow, from, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSeafoodData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.size == this.size &&
          other.shadow == this.shadow &&
          other.from == this.from &&
          other.times == this.times);
}

class AcnlSeafoodCompanion extends UpdateCompanion<AcnlSeafoodData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> size;
  final Value<String?> shadow;
  final Value<String?> from;
  final Value<String?> times;
  const AcnlSeafoodCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcnlSeafoodCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.size = const Value.absent(),
    this.shadow = const Value.absent(),
    this.from = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcnlSeafoodData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? size,
    Expression<String?>? shadow,
    Expression<String?>? from,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (size != null) 'Size': size,
      if (shadow != null) 'Shadow': shadow,
      if (from != null) 'From': from,
      if (times != null) 'Times': times,
    });
  }

  AcnlSeafoodCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? size,
      Value<String?>? shadow,
      Value<String?>? from,
      Value<String?>? times}) {
    return AcnlSeafoodCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      size: size ?? this.size,
      shadow: shadow ?? this.shadow,
      from: from ?? this.from,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (size.present) {
      map['Size'] = Variable<String?>(size.value);
    }
    if (shadow.present) {
      map['Shadow'] = Variable<String?>(shadow.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSeafoodCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('size: $size, ')
          ..write('shadow: $shadow, ')
          ..write('from: $from, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcnlSeafood extends Table with TableInfo<AcnlSeafood, AcnlSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _sizeMeta = const VerificationMeta('size');
  late final GeneratedColumn<String?> size = GeneratedColumn<String?>(
      'Size', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _shadowMeta = const VerificationMeta('shadow');
  late final GeneratedColumn<String?> shadow = GeneratedColumn<String?>(
      'Shadow', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, size, shadow, from, times];
  @override
  String get aliasedName => _alias ?? 'acnl_seafood';
  @override
  String get actualTableName => 'acnl_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Size')) {
      context.handle(
          _sizeMeta, size.isAcceptableOrUnknown(data['Size']!, _sizeMeta));
    }
    if (data.containsKey('Shadow')) {
      context.handle(_shadowMeta,
          shadow.isAcceptableOrUnknown(data['Shadow']!, _shadowMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSeafood createAlias(String alias) {
    return AcnlSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlShirtData extends DataClass implements Insertable<AcnlShirtData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlShirtData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.from,
      this.color1,
      this.color2});
  factory AcnlShirtData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlShirtData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlShirtCompanion toCompanion(bool nullToAbsent) {
    return AcnlShirtCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlShirtData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlShirtData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlShirtData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlShirtData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlShirtData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlShirtData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlShirtCompanion extends UpdateCompanion<AcnlShirtData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlShirtCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlShirtCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlShirtData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlShirtCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlShirtCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlShirtCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlShirt extends Table with TableInfo<AcnlShirt, AcnlShirtData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlShirt(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_shirt';
  @override
  String get actualTableName => 'acnl_shirt';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlShirtData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlShirtData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlShirtData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlShirt createAlias(String alias) {
    return AcnlShirt(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSongData extends DataClass implements Insertable<AcnlSongData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnlSongData({this.index, this.selected, this.name, this.from});
  factory AcnlSongData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSongData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlSongCompanion toCompanion(bool nullToAbsent) {
    return AcnlSongCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlSongData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSongData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlSongData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnlSongData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSongData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSongData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnlSongCompanion extends UpdateCompanion<AcnlSongData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnlSongCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlSongCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlSongData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnlSongCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnlSongCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSongCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlSong extends Table with TableInfo<AcnlSong, AcnlSongData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSong(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnl_song';
  @override
  String get actualTableName => 'acnl_song';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlSongData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSongData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSongData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSong createAlias(String alias) {
    return AcnlSong(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlStationeryData extends DataClass
    implements Insertable<AcnlStationeryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  AcnlStationeryData(
      {this.index, this.selected, this.name, this.status, this.from});
  factory AcnlStationeryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlStationeryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlStationeryCompanion toCompanion(bool nullToAbsent) {
    return AcnlStationeryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlStationeryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlStationeryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlStationeryData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from}) =>
      AcnlStationeryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlStationeryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlStationeryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from);
}

class AcnlStationeryCompanion extends UpdateCompanion<AcnlStationeryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  const AcnlStationeryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlStationeryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlStationeryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
    });
  }

  AcnlStationeryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from}) {
    return AcnlStationeryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlStationeryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlStationery extends Table
    with TableInfo<AcnlStationery, AcnlStationeryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlStationery(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, status, from];
  @override
  String get aliasedName => _alias ?? 'acnl_stationery';
  @override
  String get actualTableName => 'acnl_stationery';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlStationeryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlStationeryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlStationeryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlStationery createAlias(String alias) {
    return AcnlStationery(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlToolData extends DataClass implements Insertable<AcnlToolData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnlToolData({this.index, this.selected, this.name, this.from});
  factory AcnlToolData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlToolData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlToolCompanion toCompanion(bool nullToAbsent) {
    return AcnlToolCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlToolData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlToolData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlToolData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnlToolData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlToolData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlToolData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnlToolCompanion extends UpdateCompanion<AcnlToolData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnlToolCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlToolCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlToolData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnlToolCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnlToolCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlToolCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlTool extends Table with TableInfo<AcnlTool, AcnlToolData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlTool(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnl_tool';
  @override
  String get actualTableName => 'acnl_tool';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlToolData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlToolData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlToolData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlTool createAlias(String alias) {
    return AcnlTool(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlVillagerPictureData extends DataClass
    implements Insertable<AcnlVillagerPictureData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnlVillagerPictureData({this.index, this.selected, this.name, this.from});
  factory AcnlVillagerPictureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlVillagerPictureData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlVillagerPictureCompanion toCompanion(bool nullToAbsent) {
    return AcnlVillagerPictureCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlVillagerPictureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlVillagerPictureData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlVillagerPictureData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnlVillagerPictureData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlVillagerPictureData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlVillagerPictureData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnlVillagerPictureCompanion
    extends UpdateCompanion<AcnlVillagerPictureData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnlVillagerPictureCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlVillagerPictureCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlVillagerPictureData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnlVillagerPictureCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnlVillagerPictureCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlVillagerPictureCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlVillagerPicture extends Table
    with TableInfo<AcnlVillagerPicture, AcnlVillagerPictureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlVillagerPicture(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnl_villager_picture';
  @override
  String get actualTableName => 'acnl_villager_picture';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnlVillagerPictureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlVillagerPictureData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    return AcnlVillagerPictureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlVillagerPicture createAlias(String alias) {
    return AcnlVillagerPicture(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlWallpaperData extends DataClass
    implements Insertable<AcnlWallpaperData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  AcnlWallpaperData(
      {this.index, this.selected, this.name, this.status, this.from});
  factory AcnlWallpaperData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlWallpaperData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnlWallpaperCompanion toCompanion(bool nullToAbsent) {
    return AcnlWallpaperCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnlWallpaperData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlWallpaperData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnlWallpaperData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from}) =>
      AcnlWallpaperData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlWallpaperData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlWallpaperData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from);
}

class AcnlWallpaperCompanion extends UpdateCompanion<AcnlWallpaperData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  const AcnlWallpaperCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnlWallpaperCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnlWallpaperData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
    });
  }

  AcnlWallpaperCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from}) {
    return AcnlWallpaperCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlWallpaperCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnlWallpaper extends Table
    with TableInfo<AcnlWallpaper, AcnlWallpaperData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlWallpaper(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, status, from];
  @override
  String get aliasedName => _alias ?? 'acnl_wallpaper';
  @override
  String get actualTableName => 'acnl_wallpaper';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlWallpaperData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlWallpaperData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlWallpaperData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlWallpaper createAlias(String alias) {
    return AcnlWallpaper(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlWetSuitData extends DataClass implements Insertable<AcnlWetSuitData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  final String? color1;
  final String? color2;
  AcnlWetSuitData(
      {this.index,
      this.selected,
      this.name,
      this.from,
      this.color1,
      this.color2});
  factory AcnlWetSuitData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlWetSuitData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      color1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color1']),
      color2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color2']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || color1 != null) {
      map['Color1'] = Variable<String?>(color1);
    }
    if (!nullToAbsent || color2 != null) {
      map['Color2'] = Variable<String?>(color2);
    }
    return map;
  }

  AcnlWetSuitCompanion toCompanion(bool nullToAbsent) {
    return AcnlWetSuitCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      color1:
          color1 == null && nullToAbsent ? const Value.absent() : Value(color1),
      color2:
          color2 == null && nullToAbsent ? const Value.absent() : Value(color2),
    );
  }

  factory AcnlWetSuitData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlWetSuitData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
      color1: serializer.fromJson<String?>(json['Color1']),
      color2: serializer.fromJson<String?>(json['Color2']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
      'Color1': serializer.toJson<String?>(color1),
      'Color2': serializer.toJson<String?>(color2),
    };
  }

  AcnlWetSuitData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? from,
          String? color1,
          String? color2}) =>
      AcnlWetSuitData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlWetSuitData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from, color1, color2);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlWetSuitData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from &&
          other.color1 == this.color1 &&
          other.color2 == this.color2);
}

class AcnlWetSuitCompanion extends UpdateCompanion<AcnlWetSuitData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  final Value<String?> color1;
  final Value<String?> color2;
  const AcnlWetSuitCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  AcnlWetSuitCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
    this.color1 = const Value.absent(),
    this.color2 = const Value.absent(),
  });
  static Insertable<AcnlWetSuitData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
    Expression<String?>? color1,
    Expression<String?>? color2,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
      if (color1 != null) 'Color1': color1,
      if (color2 != null) 'Color2': color2,
    });
  }

  AcnlWetSuitCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from,
      Value<String?>? color1,
      Value<String?>? color2}) {
    return AcnlWetSuitCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
      color1: color1 ?? this.color1,
      color2: color2 ?? this.color2,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (color1.present) {
      map['Color1'] = Variable<String?>(color1.value);
    }
    if (color2.present) {
      map['Color2'] = Variable<String?>(color2.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlWetSuitCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from, ')
          ..write('color1: $color1, ')
          ..write('color2: $color2')
          ..write(')'))
        .toString();
  }
}

class AcnlWetSuit extends Table with TableInfo<AcnlWetSuit, AcnlWetSuitData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlWetSuit(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color1Meta = const VerificationMeta('color1');
  late final GeneratedColumn<String?> color1 = GeneratedColumn<String?>(
      'Color1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _color2Meta = const VerificationMeta('color2');
  late final GeneratedColumn<String?> color2 = GeneratedColumn<String?>(
      'Color2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, from, color1, color2];
  @override
  String get aliasedName => _alias ?? 'acnl_wet_suit';
  @override
  String get actualTableName => 'acnl_wet_suit';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlWetSuitData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Color1')) {
      context.handle(_color1Meta,
          color1.isAcceptableOrUnknown(data['Color1']!, _color1Meta));
    }
    if (data.containsKey('Color2')) {
      context.handle(_color2Meta,
          color2.isAcceptableOrUnknown(data['Color2']!, _color2Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlWetSuitData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlWetSuitData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlWetSuit createAlias(String alias) {
    return AcnlWetSuit(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcJanFishData extends DataClass implements Insertable<AcgcJanFishData> {
  final int? id;
  AcgcJanFishData({this.id});
  factory AcgcJanFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcJanFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcJanFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcJanFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcJanFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcJanFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcJanFishData copyWith({int? id}) => AcgcJanFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcJanFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcJanFishData && other.id == this.id);
}

class AcgcJanFishCompanion extends UpdateCompanion<AcgcJanFishData> {
  final Value<int?> id;
  const AcgcJanFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcJanFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcJanFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcJanFishCompanion copyWith({Value<int?>? id}) {
    return AcgcJanFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcJanFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcJanFish extends Table with TableInfo<AcgcJanFish, AcgcJanFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcJanFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_jan_fish';
  @override
  String get actualTableName => 'acgc_jan_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcJanFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcJanFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcJanFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcJanFish createAlias(String alias) {
    return AcgcJanFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcFebFishData extends DataClass implements Insertable<AcgcFebFishData> {
  final int? id;
  AcgcFebFishData({this.id});
  factory AcgcFebFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcFebFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcFebFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcFebFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcFebFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcFebFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcFebFishData copyWith({int? id}) => AcgcFebFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcFebFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcFebFishData && other.id == this.id);
}

class AcgcFebFishCompanion extends UpdateCompanion<AcgcFebFishData> {
  final Value<int?> id;
  const AcgcFebFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcFebFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcFebFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcFebFishCompanion copyWith({Value<int?>? id}) {
    return AcgcFebFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcFebFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcFebFish extends Table with TableInfo<AcgcFebFish, AcgcFebFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcFebFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_feb_fish';
  @override
  String get actualTableName => 'acgc_feb_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcFebFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcFebFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcFebFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcFebFish createAlias(String alias) {
    return AcgcFebFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcMarFishData extends DataClass implements Insertable<AcgcMarFishData> {
  final int? id;
  AcgcMarFishData({this.id});
  factory AcgcMarFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcMarFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcMarFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcMarFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcMarFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcMarFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcMarFishData copyWith({int? id}) => AcgcMarFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcMarFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcMarFishData && other.id == this.id);
}

class AcgcMarFishCompanion extends UpdateCompanion<AcgcMarFishData> {
  final Value<int?> id;
  const AcgcMarFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcMarFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcMarFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcMarFishCompanion copyWith({Value<int?>? id}) {
    return AcgcMarFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcMarFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcMarFish extends Table with TableInfo<AcgcMarFish, AcgcMarFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcMarFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_mar_fish';
  @override
  String get actualTableName => 'acgc_mar_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcMarFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcMarFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcMarFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcMarFish createAlias(String alias) {
    return AcgcMarFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcAprFishData extends DataClass implements Insertable<AcgcAprFishData> {
  final int? id;
  AcgcAprFishData({this.id});
  factory AcgcAprFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcAprFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcAprFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcAprFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcAprFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcAprFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcAprFishData copyWith({int? id}) => AcgcAprFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcAprFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcAprFishData && other.id == this.id);
}

class AcgcAprFishCompanion extends UpdateCompanion<AcgcAprFishData> {
  final Value<int?> id;
  const AcgcAprFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcAprFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcAprFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcAprFishCompanion copyWith({Value<int?>? id}) {
    return AcgcAprFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcAprFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcAprFish extends Table with TableInfo<AcgcAprFish, AcgcAprFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcAprFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_apr_fish';
  @override
  String get actualTableName => 'acgc_apr_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcAprFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcAprFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcAprFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcAprFish createAlias(String alias) {
    return AcgcAprFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcMayFishData extends DataClass implements Insertable<AcgcMayFishData> {
  final int? id;
  AcgcMayFishData({this.id});
  factory AcgcMayFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcMayFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcMayFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcMayFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcMayFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcMayFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcMayFishData copyWith({int? id}) => AcgcMayFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcMayFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcMayFishData && other.id == this.id);
}

class AcgcMayFishCompanion extends UpdateCompanion<AcgcMayFishData> {
  final Value<int?> id;
  const AcgcMayFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcMayFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcMayFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcMayFishCompanion copyWith({Value<int?>? id}) {
    return AcgcMayFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcMayFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcMayFish extends Table with TableInfo<AcgcMayFish, AcgcMayFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcMayFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_may_fish';
  @override
  String get actualTableName => 'acgc_may_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcMayFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcMayFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcMayFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcMayFish createAlias(String alias) {
    return AcgcMayFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcJunFishData extends DataClass implements Insertable<AcgcJunFishData> {
  final int? id;
  AcgcJunFishData({this.id});
  factory AcgcJunFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcJunFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcJunFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcJunFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcJunFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcJunFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcJunFishData copyWith({int? id}) => AcgcJunFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcJunFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcJunFishData && other.id == this.id);
}

class AcgcJunFishCompanion extends UpdateCompanion<AcgcJunFishData> {
  final Value<int?> id;
  const AcgcJunFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcJunFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcJunFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcJunFishCompanion copyWith({Value<int?>? id}) {
    return AcgcJunFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcJunFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcJunFish extends Table with TableInfo<AcgcJunFish, AcgcJunFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcJunFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_jun_fish';
  @override
  String get actualTableName => 'acgc_jun_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcJunFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcJunFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcJunFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcJunFish createAlias(String alias) {
    return AcgcJunFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcJulFishData extends DataClass implements Insertable<AcgcJulFishData> {
  final int? id;
  AcgcJulFishData({this.id});
  factory AcgcJulFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcJulFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcJulFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcJulFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcJulFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcJulFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcJulFishData copyWith({int? id}) => AcgcJulFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcJulFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcJulFishData && other.id == this.id);
}

class AcgcJulFishCompanion extends UpdateCompanion<AcgcJulFishData> {
  final Value<int?> id;
  const AcgcJulFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcJulFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcJulFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcJulFishCompanion copyWith({Value<int?>? id}) {
    return AcgcJulFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcJulFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcJulFish extends Table with TableInfo<AcgcJulFish, AcgcJulFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcJulFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_jul_fish';
  @override
  String get actualTableName => 'acgc_jul_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcJulFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcJulFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcJulFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcJulFish createAlias(String alias) {
    return AcgcJulFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcAug1FishData extends DataClass
    implements Insertable<AcgcAug1FishData> {
  final int? id;
  AcgcAug1FishData({this.id});
  factory AcgcAug1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcAug1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcAug1FishCompanion toCompanion(bool nullToAbsent) {
    return AcgcAug1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcAug1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcAug1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcAug1FishData copyWith({int? id}) => AcgcAug1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcAug1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcAug1FishData && other.id == this.id);
}

class AcgcAug1FishCompanion extends UpdateCompanion<AcgcAug1FishData> {
  final Value<int?> id;
  const AcgcAug1FishCompanion({
    this.id = const Value.absent(),
  });
  AcgcAug1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcAug1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcAug1FishCompanion copyWith({Value<int?>? id}) {
    return AcgcAug1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcAug1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcAug1Fish extends Table
    with TableInfo<AcgcAug1Fish, AcgcAug1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcAug1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_aug1_fish';
  @override
  String get actualTableName => 'acgc_aug1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcAug1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcAug1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcAug1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcAug1Fish createAlias(String alias) {
    return AcgcAug1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcAug2FishData extends DataClass
    implements Insertable<AcgcAug2FishData> {
  final int? id;
  AcgcAug2FishData({this.id});
  factory AcgcAug2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcAug2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcAug2FishCompanion toCompanion(bool nullToAbsent) {
    return AcgcAug2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcAug2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcAug2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcAug2FishData copyWith({int? id}) => AcgcAug2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcAug2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcAug2FishData && other.id == this.id);
}

class AcgcAug2FishCompanion extends UpdateCompanion<AcgcAug2FishData> {
  final Value<int?> id;
  const AcgcAug2FishCompanion({
    this.id = const Value.absent(),
  });
  AcgcAug2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcAug2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcAug2FishCompanion copyWith({Value<int?>? id}) {
    return AcgcAug2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcAug2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcAug2Fish extends Table
    with TableInfo<AcgcAug2Fish, AcgcAug2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcAug2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_aug2_fish';
  @override
  String get actualTableName => 'acgc_aug2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcAug2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcAug2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcAug2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcAug2Fish createAlias(String alias) {
    return AcgcAug2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcSep1FishData extends DataClass
    implements Insertable<AcgcSep1FishData> {
  final int? id;
  AcgcSep1FishData({this.id});
  factory AcgcSep1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcSep1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcSep1FishCompanion toCompanion(bool nullToAbsent) {
    return AcgcSep1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcSep1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcSep1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcSep1FishData copyWith({int? id}) => AcgcSep1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcSep1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcSep1FishData && other.id == this.id);
}

class AcgcSep1FishCompanion extends UpdateCompanion<AcgcSep1FishData> {
  final Value<int?> id;
  const AcgcSep1FishCompanion({
    this.id = const Value.absent(),
  });
  AcgcSep1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcSep1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcSep1FishCompanion copyWith({Value<int?>? id}) {
    return AcgcSep1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcSep1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcSep1Fish extends Table
    with TableInfo<AcgcSep1Fish, AcgcSep1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcSep1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_sep1_fish';
  @override
  String get actualTableName => 'acgc_sep1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcSep1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcSep1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcSep1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcSep1Fish createAlias(String alias) {
    return AcgcSep1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcSep2FishData extends DataClass
    implements Insertable<AcgcSep2FishData> {
  final int? id;
  AcgcSep2FishData({this.id});
  factory AcgcSep2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcSep2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcSep2FishCompanion toCompanion(bool nullToAbsent) {
    return AcgcSep2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcSep2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcSep2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcSep2FishData copyWith({int? id}) => AcgcSep2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcSep2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcSep2FishData && other.id == this.id);
}

class AcgcSep2FishCompanion extends UpdateCompanion<AcgcSep2FishData> {
  final Value<int?> id;
  const AcgcSep2FishCompanion({
    this.id = const Value.absent(),
  });
  AcgcSep2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcSep2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcSep2FishCompanion copyWith({Value<int?>? id}) {
    return AcgcSep2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcSep2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcSep2Fish extends Table
    with TableInfo<AcgcSep2Fish, AcgcSep2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcSep2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_sep2_fish';
  @override
  String get actualTableName => 'acgc_sep2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcSep2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcSep2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcSep2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcSep2Fish createAlias(String alias) {
    return AcgcSep2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcOctFishData extends DataClass implements Insertable<AcgcOctFishData> {
  final int? id;
  AcgcOctFishData({this.id});
  factory AcgcOctFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcOctFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcOctFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcOctFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcOctFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcOctFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcOctFishData copyWith({int? id}) => AcgcOctFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcOctFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcOctFishData && other.id == this.id);
}

class AcgcOctFishCompanion extends UpdateCompanion<AcgcOctFishData> {
  final Value<int?> id;
  const AcgcOctFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcOctFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcOctFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcOctFishCompanion copyWith({Value<int?>? id}) {
    return AcgcOctFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcOctFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcOctFish extends Table with TableInfo<AcgcOctFish, AcgcOctFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcOctFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_oct_fish';
  @override
  String get actualTableName => 'acgc_oct_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcOctFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcOctFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcOctFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcOctFish createAlias(String alias) {
    return AcgcOctFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcNovFishData extends DataClass implements Insertable<AcgcNovFishData> {
  final int? id;
  AcgcNovFishData({this.id});
  factory AcgcNovFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcNovFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcNovFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcNovFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcNovFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcNovFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcNovFishData copyWith({int? id}) => AcgcNovFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcNovFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcNovFishData && other.id == this.id);
}

class AcgcNovFishCompanion extends UpdateCompanion<AcgcNovFishData> {
  final Value<int?> id;
  const AcgcNovFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcNovFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcNovFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcNovFishCompanion copyWith({Value<int?>? id}) {
    return AcgcNovFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcNovFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcNovFish extends Table with TableInfo<AcgcNovFish, AcgcNovFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcNovFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_nov_fish';
  @override
  String get actualTableName => 'acgc_nov_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcNovFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcNovFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcNovFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcNovFish createAlias(String alias) {
    return AcgcNovFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcDecFishData extends DataClass implements Insertable<AcgcDecFishData> {
  final int? id;
  AcgcDecFishData({this.id});
  factory AcgcDecFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcDecFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcDecFishCompanion toCompanion(bool nullToAbsent) {
    return AcgcDecFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcDecFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcDecFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcDecFishData copyWith({int? id}) => AcgcDecFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcDecFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcDecFishData && other.id == this.id);
}

class AcgcDecFishCompanion extends UpdateCompanion<AcgcDecFishData> {
  final Value<int?> id;
  const AcgcDecFishCompanion({
    this.id = const Value.absent(),
  });
  AcgcDecFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcDecFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcDecFishCompanion copyWith({Value<int?>? id}) {
    return AcgcDecFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcDecFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcDecFish extends Table with TableInfo<AcgcDecFish, AcgcDecFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcDecFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_dec_fish';
  @override
  String get actualTableName => 'acgc_dec_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcDecFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcDecFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcDecFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcDecFish createAlias(String alias) {
    return AcgcDecFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcJanInsectData extends DataClass
    implements Insertable<AcgcJanInsectData> {
  final int? id;
  AcgcJanInsectData({this.id});
  factory AcgcJanInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcJanInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcJanInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcJanInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcJanInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcJanInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcJanInsectData copyWith({int? id}) => AcgcJanInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcJanInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcJanInsectData && other.id == this.id);
}

class AcgcJanInsectCompanion extends UpdateCompanion<AcgcJanInsectData> {
  final Value<int?> id;
  const AcgcJanInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcJanInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcJanInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcJanInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcJanInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcJanInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcJanInsect extends Table
    with TableInfo<AcgcJanInsect, AcgcJanInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcJanInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_jan_insect';
  @override
  String get actualTableName => 'acgc_jan_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcJanInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcJanInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcJanInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcJanInsect createAlias(String alias) {
    return AcgcJanInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcFebInsectData extends DataClass
    implements Insertable<AcgcFebInsectData> {
  final int? id;
  AcgcFebInsectData({this.id});
  factory AcgcFebInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcFebInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcFebInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcFebInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcFebInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcFebInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcFebInsectData copyWith({int? id}) => AcgcFebInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcFebInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcFebInsectData && other.id == this.id);
}

class AcgcFebInsectCompanion extends UpdateCompanion<AcgcFebInsectData> {
  final Value<int?> id;
  const AcgcFebInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcFebInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcFebInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcFebInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcFebInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcFebInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcFebInsect extends Table
    with TableInfo<AcgcFebInsect, AcgcFebInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcFebInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_feb_insect';
  @override
  String get actualTableName => 'acgc_feb_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcFebInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcFebInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcFebInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcFebInsect createAlias(String alias) {
    return AcgcFebInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcMarInsectData extends DataClass
    implements Insertable<AcgcMarInsectData> {
  final int? id;
  AcgcMarInsectData({this.id});
  factory AcgcMarInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcMarInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcMarInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcMarInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcMarInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcMarInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcMarInsectData copyWith({int? id}) => AcgcMarInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcMarInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcMarInsectData && other.id == this.id);
}

class AcgcMarInsectCompanion extends UpdateCompanion<AcgcMarInsectData> {
  final Value<int?> id;
  const AcgcMarInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcMarInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcMarInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcMarInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcMarInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcMarInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcMarInsect extends Table
    with TableInfo<AcgcMarInsect, AcgcMarInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcMarInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_mar_insect';
  @override
  String get actualTableName => 'acgc_mar_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcMarInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcMarInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcMarInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcMarInsect createAlias(String alias) {
    return AcgcMarInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcAprInsectData extends DataClass
    implements Insertable<AcgcAprInsectData> {
  final int? id;
  AcgcAprInsectData({this.id});
  factory AcgcAprInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcAprInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcAprInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcAprInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcAprInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcAprInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcAprInsectData copyWith({int? id}) => AcgcAprInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcAprInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcAprInsectData && other.id == this.id);
}

class AcgcAprInsectCompanion extends UpdateCompanion<AcgcAprInsectData> {
  final Value<int?> id;
  const AcgcAprInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcAprInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcAprInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcAprInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcAprInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcAprInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcAprInsect extends Table
    with TableInfo<AcgcAprInsect, AcgcAprInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcAprInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_apr_insect';
  @override
  String get actualTableName => 'acgc_apr_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcAprInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcAprInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcAprInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcAprInsect createAlias(String alias) {
    return AcgcAprInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcMayInsectData extends DataClass
    implements Insertable<AcgcMayInsectData> {
  final int? id;
  AcgcMayInsectData({this.id});
  factory AcgcMayInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcMayInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcMayInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcMayInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcMayInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcMayInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcMayInsectData copyWith({int? id}) => AcgcMayInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcMayInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcMayInsectData && other.id == this.id);
}

class AcgcMayInsectCompanion extends UpdateCompanion<AcgcMayInsectData> {
  final Value<int?> id;
  const AcgcMayInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcMayInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcMayInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcMayInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcMayInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcMayInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcMayInsect extends Table
    with TableInfo<AcgcMayInsect, AcgcMayInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcMayInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_may_insect';
  @override
  String get actualTableName => 'acgc_may_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcMayInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcMayInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcMayInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcMayInsect createAlias(String alias) {
    return AcgcMayInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcJunInsectData extends DataClass
    implements Insertable<AcgcJunInsectData> {
  final int? id;
  AcgcJunInsectData({this.id});
  factory AcgcJunInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcJunInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcJunInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcJunInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcJunInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcJunInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcJunInsectData copyWith({int? id}) => AcgcJunInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcJunInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcJunInsectData && other.id == this.id);
}

class AcgcJunInsectCompanion extends UpdateCompanion<AcgcJunInsectData> {
  final Value<int?> id;
  const AcgcJunInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcJunInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcJunInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcJunInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcJunInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcJunInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcJunInsect extends Table
    with TableInfo<AcgcJunInsect, AcgcJunInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcJunInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_jun_insect';
  @override
  String get actualTableName => 'acgc_jun_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcJunInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcJunInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcJunInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcJunInsect createAlias(String alias) {
    return AcgcJunInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcJulInsectData extends DataClass
    implements Insertable<AcgcJulInsectData> {
  final int? id;
  AcgcJulInsectData({this.id});
  factory AcgcJulInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcJulInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcJulInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcJulInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcJulInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcJulInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcJulInsectData copyWith({int? id}) => AcgcJulInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcJulInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcJulInsectData && other.id == this.id);
}

class AcgcJulInsectCompanion extends UpdateCompanion<AcgcJulInsectData> {
  final Value<int?> id;
  const AcgcJulInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcJulInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcJulInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcJulInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcJulInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcJulInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcJulInsect extends Table
    with TableInfo<AcgcJulInsect, AcgcJulInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcJulInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_jul_insect';
  @override
  String get actualTableName => 'acgc_jul_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcJulInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcJulInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcJulInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcJulInsect createAlias(String alias) {
    return AcgcJulInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcAug1InsectData extends DataClass
    implements Insertable<AcgcAug1InsectData> {
  final int? id;
  AcgcAug1InsectData({this.id});
  factory AcgcAug1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcAug1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcAug1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcAug1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcAug1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcAug1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcAug1InsectData copyWith({int? id}) => AcgcAug1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcAug1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcAug1InsectData && other.id == this.id);
}

class AcgcAug1InsectCompanion extends UpdateCompanion<AcgcAug1InsectData> {
  final Value<int?> id;
  const AcgcAug1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcAug1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcAug1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcAug1InsectCompanion copyWith({Value<int?>? id}) {
    return AcgcAug1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcAug1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcAug1Insect extends Table
    with TableInfo<AcgcAug1Insect, AcgcAug1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcAug1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_aug1_insect';
  @override
  String get actualTableName => 'acgc_aug1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcAug1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcAug1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcAug1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcAug1Insect createAlias(String alias) {
    return AcgcAug1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcAug2InsectData extends DataClass
    implements Insertable<AcgcAug2InsectData> {
  final int? id;
  AcgcAug2InsectData({this.id});
  factory AcgcAug2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcAug2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcAug2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcAug2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcAug2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcAug2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcAug2InsectData copyWith({int? id}) => AcgcAug2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcAug2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcAug2InsectData && other.id == this.id);
}

class AcgcAug2InsectCompanion extends UpdateCompanion<AcgcAug2InsectData> {
  final Value<int?> id;
  const AcgcAug2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcAug2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcAug2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcAug2InsectCompanion copyWith({Value<int?>? id}) {
    return AcgcAug2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcAug2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcAug2Insect extends Table
    with TableInfo<AcgcAug2Insect, AcgcAug2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcAug2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_aug2_insect';
  @override
  String get actualTableName => 'acgc_aug2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcAug2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcAug2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcAug2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcAug2Insect createAlias(String alias) {
    return AcgcAug2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcSep1InsectData extends DataClass
    implements Insertable<AcgcSep1InsectData> {
  final int? id;
  AcgcSep1InsectData({this.id});
  factory AcgcSep1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcSep1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcSep1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcSep1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcSep1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcSep1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcSep1InsectData copyWith({int? id}) => AcgcSep1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcSep1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcSep1InsectData && other.id == this.id);
}

class AcgcSep1InsectCompanion extends UpdateCompanion<AcgcSep1InsectData> {
  final Value<int?> id;
  const AcgcSep1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcSep1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcSep1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcSep1InsectCompanion copyWith({Value<int?>? id}) {
    return AcgcSep1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcSep1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcSep1Insect extends Table
    with TableInfo<AcgcSep1Insect, AcgcSep1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcSep1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_sep1_insect';
  @override
  String get actualTableName => 'acgc_sep1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcSep1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcSep1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcSep1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcSep1Insect createAlias(String alias) {
    return AcgcSep1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcSep2InsectData extends DataClass
    implements Insertable<AcgcSep2InsectData> {
  final int? id;
  AcgcSep2InsectData({this.id});
  factory AcgcSep2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcSep2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcSep2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcSep2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcSep2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcSep2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcSep2InsectData copyWith({int? id}) => AcgcSep2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcSep2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcSep2InsectData && other.id == this.id);
}

class AcgcSep2InsectCompanion extends UpdateCompanion<AcgcSep2InsectData> {
  final Value<int?> id;
  const AcgcSep2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcSep2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcSep2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcSep2InsectCompanion copyWith({Value<int?>? id}) {
    return AcgcSep2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcSep2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcSep2Insect extends Table
    with TableInfo<AcgcSep2Insect, AcgcSep2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcSep2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_sep2_insect';
  @override
  String get actualTableName => 'acgc_sep2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcSep2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcSep2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcSep2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcSep2Insect createAlias(String alias) {
    return AcgcSep2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcOctInsectData extends DataClass
    implements Insertable<AcgcOctInsectData> {
  final int? id;
  AcgcOctInsectData({this.id});
  factory AcgcOctInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcOctInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcOctInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcOctInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcOctInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcOctInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcOctInsectData copyWith({int? id}) => AcgcOctInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcOctInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcOctInsectData && other.id == this.id);
}

class AcgcOctInsectCompanion extends UpdateCompanion<AcgcOctInsectData> {
  final Value<int?> id;
  const AcgcOctInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcOctInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcOctInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcOctInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcOctInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcOctInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcOctInsect extends Table
    with TableInfo<AcgcOctInsect, AcgcOctInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcOctInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_oct_insect';
  @override
  String get actualTableName => 'acgc_oct_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcOctInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcOctInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcOctInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcOctInsect createAlias(String alias) {
    return AcgcOctInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcNovInsectData extends DataClass
    implements Insertable<AcgcNovInsectData> {
  final int? id;
  AcgcNovInsectData({this.id});
  factory AcgcNovInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcNovInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcNovInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcNovInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcNovInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcNovInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcNovInsectData copyWith({int? id}) => AcgcNovInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcNovInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcNovInsectData && other.id == this.id);
}

class AcgcNovInsectCompanion extends UpdateCompanion<AcgcNovInsectData> {
  final Value<int?> id;
  const AcgcNovInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcNovInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcNovInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcNovInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcNovInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcNovInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcNovInsect extends Table
    with TableInfo<AcgcNovInsect, AcgcNovInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcNovInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_nov_insect';
  @override
  String get actualTableName => 'acgc_nov_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcNovInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcNovInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcNovInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcNovInsect createAlias(String alias) {
    return AcgcNovInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcDecInsectData extends DataClass
    implements Insertable<AcgcDecInsectData> {
  final int? id;
  AcgcDecInsectData({this.id});
  factory AcgcDecInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcDecInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcgcDecInsectCompanion toCompanion(bool nullToAbsent) {
    return AcgcDecInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcgcDecInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcDecInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcgcDecInsectData copyWith({int? id}) => AcgcDecInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcDecInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcDecInsectData && other.id == this.id);
}

class AcgcDecInsectCompanion extends UpdateCompanion<AcgcDecInsectData> {
  final Value<int?> id;
  const AcgcDecInsectCompanion({
    this.id = const Value.absent(),
  });
  AcgcDecInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcgcDecInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcgcDecInsectCompanion copyWith({Value<int?>? id}) {
    return AcgcDecInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcDecInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcgcDecInsect extends Table
    with TableInfo<AcgcDecInsect, AcgcDecInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcDecInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acgc_dec_insect';
  @override
  String get actualTableName => 'acgc_dec_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcDecInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcDecInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcDecInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcDecInsect createAlias(String alias) {
    return AcgcDecInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwJanFishData extends DataClass implements Insertable<AcwwJanFishData> {
  final int? id;
  AcwwJanFishData({this.id});
  factory AcwwJanFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwJanFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwJanFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwJanFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwJanFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwJanFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwJanFishData copyWith({int? id}) => AcwwJanFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwJanFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwJanFishData && other.id == this.id);
}

class AcwwJanFishCompanion extends UpdateCompanion<AcwwJanFishData> {
  final Value<int?> id;
  const AcwwJanFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwJanFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwJanFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwJanFishCompanion copyWith({Value<int?>? id}) {
    return AcwwJanFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwJanFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwJanFish extends Table with TableInfo<AcwwJanFish, AcwwJanFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwJanFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_jan_fish';
  @override
  String get actualTableName => 'acww_jan_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwJanFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwJanFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwJanFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwJanFish createAlias(String alias) {
    return AcwwJanFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwFebFishData extends DataClass implements Insertable<AcwwFebFishData> {
  final int? id;
  AcwwFebFishData({this.id});
  factory AcwwFebFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwFebFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwFebFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwFebFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwFebFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwFebFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwFebFishData copyWith({int? id}) => AcwwFebFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwFebFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwFebFishData && other.id == this.id);
}

class AcwwFebFishCompanion extends UpdateCompanion<AcwwFebFishData> {
  final Value<int?> id;
  const AcwwFebFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwFebFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwFebFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwFebFishCompanion copyWith({Value<int?>? id}) {
    return AcwwFebFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwFebFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwFebFish extends Table with TableInfo<AcwwFebFish, AcwwFebFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwFebFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_feb_fish';
  @override
  String get actualTableName => 'acww_feb_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwFebFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwFebFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwFebFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwFebFish createAlias(String alias) {
    return AcwwFebFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwMarFishData extends DataClass implements Insertable<AcwwMarFishData> {
  final int? id;
  AcwwMarFishData({this.id});
  factory AcwwMarFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwMarFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwMarFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwMarFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwMarFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwMarFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwMarFishData copyWith({int? id}) => AcwwMarFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwMarFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwMarFishData && other.id == this.id);
}

class AcwwMarFishCompanion extends UpdateCompanion<AcwwMarFishData> {
  final Value<int?> id;
  const AcwwMarFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwMarFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwMarFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwMarFishCompanion copyWith({Value<int?>? id}) {
    return AcwwMarFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwMarFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwMarFish extends Table with TableInfo<AcwwMarFish, AcwwMarFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwMarFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_mar_fish';
  @override
  String get actualTableName => 'acww_mar_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwMarFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwMarFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwMarFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwMarFish createAlias(String alias) {
    return AcwwMarFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwAprFishData extends DataClass implements Insertable<AcwwAprFishData> {
  final int? id;
  AcwwAprFishData({this.id});
  factory AcwwAprFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwAprFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwAprFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwAprFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwAprFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwAprFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwAprFishData copyWith({int? id}) => AcwwAprFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwAprFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwAprFishData && other.id == this.id);
}

class AcwwAprFishCompanion extends UpdateCompanion<AcwwAprFishData> {
  final Value<int?> id;
  const AcwwAprFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwAprFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwAprFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwAprFishCompanion copyWith({Value<int?>? id}) {
    return AcwwAprFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwAprFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwAprFish extends Table with TableInfo<AcwwAprFish, AcwwAprFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwAprFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_apr_fish';
  @override
  String get actualTableName => 'acww_apr_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwAprFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwAprFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwAprFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwAprFish createAlias(String alias) {
    return AcwwAprFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwMayFishData extends DataClass implements Insertable<AcwwMayFishData> {
  final int? id;
  AcwwMayFishData({this.id});
  factory AcwwMayFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwMayFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwMayFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwMayFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwMayFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwMayFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwMayFishData copyWith({int? id}) => AcwwMayFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwMayFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwMayFishData && other.id == this.id);
}

class AcwwMayFishCompanion extends UpdateCompanion<AcwwMayFishData> {
  final Value<int?> id;
  const AcwwMayFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwMayFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwMayFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwMayFishCompanion copyWith({Value<int?>? id}) {
    return AcwwMayFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwMayFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwMayFish extends Table with TableInfo<AcwwMayFish, AcwwMayFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwMayFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_may_fish';
  @override
  String get actualTableName => 'acww_may_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwMayFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwMayFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwMayFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwMayFish createAlias(String alias) {
    return AcwwMayFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwJunFishData extends DataClass implements Insertable<AcwwJunFishData> {
  final int? id;
  AcwwJunFishData({this.id});
  factory AcwwJunFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwJunFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwJunFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwJunFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwJunFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwJunFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwJunFishData copyWith({int? id}) => AcwwJunFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwJunFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwJunFishData && other.id == this.id);
}

class AcwwJunFishCompanion extends UpdateCompanion<AcwwJunFishData> {
  final Value<int?> id;
  const AcwwJunFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwJunFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwJunFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwJunFishCompanion copyWith({Value<int?>? id}) {
    return AcwwJunFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwJunFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwJunFish extends Table with TableInfo<AcwwJunFish, AcwwJunFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwJunFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_jun_fish';
  @override
  String get actualTableName => 'acww_jun_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwJunFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwJunFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwJunFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwJunFish createAlias(String alias) {
    return AcwwJunFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwJulFishData extends DataClass implements Insertable<AcwwJulFishData> {
  final int? id;
  AcwwJulFishData({this.id});
  factory AcwwJulFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwJulFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwJulFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwJulFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwJulFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwJulFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwJulFishData copyWith({int? id}) => AcwwJulFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwJulFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwJulFishData && other.id == this.id);
}

class AcwwJulFishCompanion extends UpdateCompanion<AcwwJulFishData> {
  final Value<int?> id;
  const AcwwJulFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwJulFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwJulFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwJulFishCompanion copyWith({Value<int?>? id}) {
    return AcwwJulFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwJulFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwJulFish extends Table with TableInfo<AcwwJulFish, AcwwJulFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwJulFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_jul_fish';
  @override
  String get actualTableName => 'acww_jul_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwJulFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwJulFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwJulFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwJulFish createAlias(String alias) {
    return AcwwJulFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwAug1FishData extends DataClass
    implements Insertable<AcwwAug1FishData> {
  final int? id;
  AcwwAug1FishData({this.id});
  factory AcwwAug1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwAug1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwAug1FishCompanion toCompanion(bool nullToAbsent) {
    return AcwwAug1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwAug1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwAug1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwAug1FishData copyWith({int? id}) => AcwwAug1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwAug1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwAug1FishData && other.id == this.id);
}

class AcwwAug1FishCompanion extends UpdateCompanion<AcwwAug1FishData> {
  final Value<int?> id;
  const AcwwAug1FishCompanion({
    this.id = const Value.absent(),
  });
  AcwwAug1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwAug1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwAug1FishCompanion copyWith({Value<int?>? id}) {
    return AcwwAug1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwAug1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwAug1Fish extends Table
    with TableInfo<AcwwAug1Fish, AcwwAug1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwAug1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_aug1_fish';
  @override
  String get actualTableName => 'acww_aug1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwAug1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwAug1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwAug1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwAug1Fish createAlias(String alias) {
    return AcwwAug1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwAug2FishData extends DataClass
    implements Insertable<AcwwAug2FishData> {
  final int? id;
  AcwwAug2FishData({this.id});
  factory AcwwAug2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwAug2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwAug2FishCompanion toCompanion(bool nullToAbsent) {
    return AcwwAug2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwAug2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwAug2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwAug2FishData copyWith({int? id}) => AcwwAug2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwAug2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwAug2FishData && other.id == this.id);
}

class AcwwAug2FishCompanion extends UpdateCompanion<AcwwAug2FishData> {
  final Value<int?> id;
  const AcwwAug2FishCompanion({
    this.id = const Value.absent(),
  });
  AcwwAug2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwAug2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwAug2FishCompanion copyWith({Value<int?>? id}) {
    return AcwwAug2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwAug2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwAug2Fish extends Table
    with TableInfo<AcwwAug2Fish, AcwwAug2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwAug2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_aug2_fish';
  @override
  String get actualTableName => 'acww_aug2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwAug2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwAug2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwAug2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwAug2Fish createAlias(String alias) {
    return AcwwAug2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwSep1FishData extends DataClass
    implements Insertable<AcwwSep1FishData> {
  final int? id;
  AcwwSep1FishData({this.id});
  factory AcwwSep1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwSep1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwSep1FishCompanion toCompanion(bool nullToAbsent) {
    return AcwwSep1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwSep1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwSep1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwSep1FishData copyWith({int? id}) => AcwwSep1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwSep1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwSep1FishData && other.id == this.id);
}

class AcwwSep1FishCompanion extends UpdateCompanion<AcwwSep1FishData> {
  final Value<int?> id;
  const AcwwSep1FishCompanion({
    this.id = const Value.absent(),
  });
  AcwwSep1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwSep1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwSep1FishCompanion copyWith({Value<int?>? id}) {
    return AcwwSep1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwSep1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwSep1Fish extends Table
    with TableInfo<AcwwSep1Fish, AcwwSep1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwSep1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_sep1_fish';
  @override
  String get actualTableName => 'acww_sep1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwSep1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwSep1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwSep1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwSep1Fish createAlias(String alias) {
    return AcwwSep1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwSep2FishData extends DataClass
    implements Insertable<AcwwSep2FishData> {
  final int? id;
  AcwwSep2FishData({this.id});
  factory AcwwSep2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwSep2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwSep2FishCompanion toCompanion(bool nullToAbsent) {
    return AcwwSep2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwSep2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwSep2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwSep2FishData copyWith({int? id}) => AcwwSep2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwSep2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwSep2FishData && other.id == this.id);
}

class AcwwSep2FishCompanion extends UpdateCompanion<AcwwSep2FishData> {
  final Value<int?> id;
  const AcwwSep2FishCompanion({
    this.id = const Value.absent(),
  });
  AcwwSep2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwSep2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwSep2FishCompanion copyWith({Value<int?>? id}) {
    return AcwwSep2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwSep2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwSep2Fish extends Table
    with TableInfo<AcwwSep2Fish, AcwwSep2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwSep2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_sep2_fish';
  @override
  String get actualTableName => 'acww_sep2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwSep2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwSep2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwSep2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwSep2Fish createAlias(String alias) {
    return AcwwSep2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwOctFishData extends DataClass implements Insertable<AcwwOctFishData> {
  final int? id;
  AcwwOctFishData({this.id});
  factory AcwwOctFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwOctFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwOctFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwOctFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwOctFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwOctFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwOctFishData copyWith({int? id}) => AcwwOctFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwOctFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwOctFishData && other.id == this.id);
}

class AcwwOctFishCompanion extends UpdateCompanion<AcwwOctFishData> {
  final Value<int?> id;
  const AcwwOctFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwOctFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwOctFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwOctFishCompanion copyWith({Value<int?>? id}) {
    return AcwwOctFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwOctFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwOctFish extends Table with TableInfo<AcwwOctFish, AcwwOctFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwOctFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_oct_fish';
  @override
  String get actualTableName => 'acww_oct_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwOctFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwOctFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwOctFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwOctFish createAlias(String alias) {
    return AcwwOctFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwNovFishData extends DataClass implements Insertable<AcwwNovFishData> {
  final int? id;
  AcwwNovFishData({this.id});
  factory AcwwNovFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwNovFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwNovFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwNovFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwNovFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwNovFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwNovFishData copyWith({int? id}) => AcwwNovFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwNovFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwNovFishData && other.id == this.id);
}

class AcwwNovFishCompanion extends UpdateCompanion<AcwwNovFishData> {
  final Value<int?> id;
  const AcwwNovFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwNovFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwNovFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwNovFishCompanion copyWith({Value<int?>? id}) {
    return AcwwNovFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwNovFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwNovFish extends Table with TableInfo<AcwwNovFish, AcwwNovFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwNovFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_nov_fish';
  @override
  String get actualTableName => 'acww_nov_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwNovFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwNovFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwNovFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwNovFish createAlias(String alias) {
    return AcwwNovFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwDecFishData extends DataClass implements Insertable<AcwwDecFishData> {
  final int? id;
  AcwwDecFishData({this.id});
  factory AcwwDecFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwDecFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwDecFishCompanion toCompanion(bool nullToAbsent) {
    return AcwwDecFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwDecFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwDecFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwDecFishData copyWith({int? id}) => AcwwDecFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwDecFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwDecFishData && other.id == this.id);
}

class AcwwDecFishCompanion extends UpdateCompanion<AcwwDecFishData> {
  final Value<int?> id;
  const AcwwDecFishCompanion({
    this.id = const Value.absent(),
  });
  AcwwDecFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwDecFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwDecFishCompanion copyWith({Value<int?>? id}) {
    return AcwwDecFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwDecFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwDecFish extends Table with TableInfo<AcwwDecFish, AcwwDecFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwDecFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_dec_fish';
  @override
  String get actualTableName => 'acww_dec_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwDecFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwDecFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwDecFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwDecFish createAlias(String alias) {
    return AcwwDecFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwJanInsectData extends DataClass
    implements Insertable<AcwwJanInsectData> {
  final int? id;
  AcwwJanInsectData({this.id});
  factory AcwwJanInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwJanInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwJanInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwJanInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwJanInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwJanInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwJanInsectData copyWith({int? id}) => AcwwJanInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwJanInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwJanInsectData && other.id == this.id);
}

class AcwwJanInsectCompanion extends UpdateCompanion<AcwwJanInsectData> {
  final Value<int?> id;
  const AcwwJanInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwJanInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwJanInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwJanInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwJanInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwJanInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwJanInsect extends Table
    with TableInfo<AcwwJanInsect, AcwwJanInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwJanInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_jan_insect';
  @override
  String get actualTableName => 'acww_jan_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwJanInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwJanInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwJanInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwJanInsect createAlias(String alias) {
    return AcwwJanInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwFebInsectData extends DataClass
    implements Insertable<AcwwFebInsectData> {
  final int? id;
  AcwwFebInsectData({this.id});
  factory AcwwFebInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwFebInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwFebInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwFebInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwFebInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwFebInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwFebInsectData copyWith({int? id}) => AcwwFebInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwFebInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwFebInsectData && other.id == this.id);
}

class AcwwFebInsectCompanion extends UpdateCompanion<AcwwFebInsectData> {
  final Value<int?> id;
  const AcwwFebInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwFebInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwFebInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwFebInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwFebInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwFebInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwFebInsect extends Table
    with TableInfo<AcwwFebInsect, AcwwFebInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwFebInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_feb_insect';
  @override
  String get actualTableName => 'acww_feb_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwFebInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwFebInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwFebInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwFebInsect createAlias(String alias) {
    return AcwwFebInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwMarInsectData extends DataClass
    implements Insertable<AcwwMarInsectData> {
  final int? id;
  AcwwMarInsectData({this.id});
  factory AcwwMarInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwMarInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwMarInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwMarInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwMarInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwMarInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwMarInsectData copyWith({int? id}) => AcwwMarInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwMarInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwMarInsectData && other.id == this.id);
}

class AcwwMarInsectCompanion extends UpdateCompanion<AcwwMarInsectData> {
  final Value<int?> id;
  const AcwwMarInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwMarInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwMarInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwMarInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwMarInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwMarInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwMarInsect extends Table
    with TableInfo<AcwwMarInsect, AcwwMarInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwMarInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_mar_insect';
  @override
  String get actualTableName => 'acww_mar_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwMarInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwMarInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwMarInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwMarInsect createAlias(String alias) {
    return AcwwMarInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwAprInsectData extends DataClass
    implements Insertable<AcwwAprInsectData> {
  final int? id;
  AcwwAprInsectData({this.id});
  factory AcwwAprInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwAprInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwAprInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwAprInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwAprInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwAprInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwAprInsectData copyWith({int? id}) => AcwwAprInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwAprInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwAprInsectData && other.id == this.id);
}

class AcwwAprInsectCompanion extends UpdateCompanion<AcwwAprInsectData> {
  final Value<int?> id;
  const AcwwAprInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwAprInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwAprInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwAprInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwAprInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwAprInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwAprInsect extends Table
    with TableInfo<AcwwAprInsect, AcwwAprInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwAprInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_apr_insect';
  @override
  String get actualTableName => 'acww_apr_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwAprInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwAprInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwAprInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwAprInsect createAlias(String alias) {
    return AcwwAprInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwMayInsectData extends DataClass
    implements Insertable<AcwwMayInsectData> {
  final int? id;
  AcwwMayInsectData({this.id});
  factory AcwwMayInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwMayInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwMayInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwMayInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwMayInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwMayInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwMayInsectData copyWith({int? id}) => AcwwMayInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwMayInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwMayInsectData && other.id == this.id);
}

class AcwwMayInsectCompanion extends UpdateCompanion<AcwwMayInsectData> {
  final Value<int?> id;
  const AcwwMayInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwMayInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwMayInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwMayInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwMayInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwMayInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwMayInsect extends Table
    with TableInfo<AcwwMayInsect, AcwwMayInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwMayInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_may_insect';
  @override
  String get actualTableName => 'acww_may_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwMayInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwMayInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwMayInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwMayInsect createAlias(String alias) {
    return AcwwMayInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwJunInsectData extends DataClass
    implements Insertable<AcwwJunInsectData> {
  final int? id;
  AcwwJunInsectData({this.id});
  factory AcwwJunInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwJunInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwJunInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwJunInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwJunInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwJunInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwJunInsectData copyWith({int? id}) => AcwwJunInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwJunInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwJunInsectData && other.id == this.id);
}

class AcwwJunInsectCompanion extends UpdateCompanion<AcwwJunInsectData> {
  final Value<int?> id;
  const AcwwJunInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwJunInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwJunInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwJunInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwJunInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwJunInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwJunInsect extends Table
    with TableInfo<AcwwJunInsect, AcwwJunInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwJunInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_jun_insect';
  @override
  String get actualTableName => 'acww_jun_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwJunInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwJunInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwJunInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwJunInsect createAlias(String alias) {
    return AcwwJunInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwJulInsectData extends DataClass
    implements Insertable<AcwwJulInsectData> {
  final int? id;
  AcwwJulInsectData({this.id});
  factory AcwwJulInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwJulInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwJulInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwJulInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwJulInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwJulInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwJulInsectData copyWith({int? id}) => AcwwJulInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwJulInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwJulInsectData && other.id == this.id);
}

class AcwwJulInsectCompanion extends UpdateCompanion<AcwwJulInsectData> {
  final Value<int?> id;
  const AcwwJulInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwJulInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwJulInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwJulInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwJulInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwJulInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwJulInsect extends Table
    with TableInfo<AcwwJulInsect, AcwwJulInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwJulInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_jul_insect';
  @override
  String get actualTableName => 'acww_jul_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwJulInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwJulInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwJulInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwJulInsect createAlias(String alias) {
    return AcwwJulInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwAug1InsectData extends DataClass
    implements Insertable<AcwwAug1InsectData> {
  final int? id;
  AcwwAug1InsectData({this.id});
  factory AcwwAug1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwAug1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwAug1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwAug1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwAug1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwAug1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwAug1InsectData copyWith({int? id}) => AcwwAug1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwAug1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwAug1InsectData && other.id == this.id);
}

class AcwwAug1InsectCompanion extends UpdateCompanion<AcwwAug1InsectData> {
  final Value<int?> id;
  const AcwwAug1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwAug1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwAug1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwAug1InsectCompanion copyWith({Value<int?>? id}) {
    return AcwwAug1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwAug1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwAug1Insect extends Table
    with TableInfo<AcwwAug1Insect, AcwwAug1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwAug1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_aug1_insect';
  @override
  String get actualTableName => 'acww_aug1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwAug1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwAug1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwAug1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwAug1Insect createAlias(String alias) {
    return AcwwAug1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwAug2InsectData extends DataClass
    implements Insertable<AcwwAug2InsectData> {
  final int? id;
  AcwwAug2InsectData({this.id});
  factory AcwwAug2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwAug2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwAug2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwAug2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwAug2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwAug2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwAug2InsectData copyWith({int? id}) => AcwwAug2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwAug2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwAug2InsectData && other.id == this.id);
}

class AcwwAug2InsectCompanion extends UpdateCompanion<AcwwAug2InsectData> {
  final Value<int?> id;
  const AcwwAug2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwAug2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwAug2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwAug2InsectCompanion copyWith({Value<int?>? id}) {
    return AcwwAug2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwAug2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwAug2Insect extends Table
    with TableInfo<AcwwAug2Insect, AcwwAug2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwAug2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_aug2_insect';
  @override
  String get actualTableName => 'acww_aug2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwAug2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwAug2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwAug2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwAug2Insect createAlias(String alias) {
    return AcwwAug2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwSep1InsectData extends DataClass
    implements Insertable<AcwwSep1InsectData> {
  final int? id;
  AcwwSep1InsectData({this.id});
  factory AcwwSep1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwSep1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwSep1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwSep1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwSep1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwSep1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwSep1InsectData copyWith({int? id}) => AcwwSep1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwSep1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwSep1InsectData && other.id == this.id);
}

class AcwwSep1InsectCompanion extends UpdateCompanion<AcwwSep1InsectData> {
  final Value<int?> id;
  const AcwwSep1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwSep1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwSep1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwSep1InsectCompanion copyWith({Value<int?>? id}) {
    return AcwwSep1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwSep1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwSep1Insect extends Table
    with TableInfo<AcwwSep1Insect, AcwwSep1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwSep1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_sep1_insect';
  @override
  String get actualTableName => 'acww_sep1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwSep1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwSep1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwSep1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwSep1Insect createAlias(String alias) {
    return AcwwSep1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwSep2InsectData extends DataClass
    implements Insertable<AcwwSep2InsectData> {
  final int? id;
  AcwwSep2InsectData({this.id});
  factory AcwwSep2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwSep2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwSep2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwSep2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwSep2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwSep2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwSep2InsectData copyWith({int? id}) => AcwwSep2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwSep2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwSep2InsectData && other.id == this.id);
}

class AcwwSep2InsectCompanion extends UpdateCompanion<AcwwSep2InsectData> {
  final Value<int?> id;
  const AcwwSep2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwSep2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwSep2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwSep2InsectCompanion copyWith({Value<int?>? id}) {
    return AcwwSep2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwSep2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwSep2Insect extends Table
    with TableInfo<AcwwSep2Insect, AcwwSep2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwSep2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_sep2_insect';
  @override
  String get actualTableName => 'acww_sep2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwSep2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwSep2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwSep2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwSep2Insect createAlias(String alias) {
    return AcwwSep2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwOctInsectData extends DataClass
    implements Insertable<AcwwOctInsectData> {
  final int? id;
  AcwwOctInsectData({this.id});
  factory AcwwOctInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwOctInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwOctInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwOctInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwOctInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwOctInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwOctInsectData copyWith({int? id}) => AcwwOctInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwOctInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwOctInsectData && other.id == this.id);
}

class AcwwOctInsectCompanion extends UpdateCompanion<AcwwOctInsectData> {
  final Value<int?> id;
  const AcwwOctInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwOctInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwOctInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwOctInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwOctInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwOctInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwOctInsect extends Table
    with TableInfo<AcwwOctInsect, AcwwOctInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwOctInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_oct_insect';
  @override
  String get actualTableName => 'acww_oct_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwOctInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwOctInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwOctInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwOctInsect createAlias(String alias) {
    return AcwwOctInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwNovInsectData extends DataClass
    implements Insertable<AcwwNovInsectData> {
  final int? id;
  AcwwNovInsectData({this.id});
  factory AcwwNovInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwNovInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwNovInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwNovInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwNovInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwNovInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwNovInsectData copyWith({int? id}) => AcwwNovInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwNovInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwNovInsectData && other.id == this.id);
}

class AcwwNovInsectCompanion extends UpdateCompanion<AcwwNovInsectData> {
  final Value<int?> id;
  const AcwwNovInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwNovInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwNovInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwNovInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwNovInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwNovInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwNovInsect extends Table
    with TableInfo<AcwwNovInsect, AcwwNovInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwNovInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_nov_insect';
  @override
  String get actualTableName => 'acww_nov_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwNovInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwNovInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwNovInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwNovInsect createAlias(String alias) {
    return AcwwNovInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwDecInsectData extends DataClass
    implements Insertable<AcwwDecInsectData> {
  final int? id;
  AcwwDecInsectData({this.id});
  factory AcwwDecInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwDecInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcwwDecInsectCompanion toCompanion(bool nullToAbsent) {
    return AcwwDecInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcwwDecInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwDecInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcwwDecInsectData copyWith({int? id}) => AcwwDecInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwDecInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwDecInsectData && other.id == this.id);
}

class AcwwDecInsectCompanion extends UpdateCompanion<AcwwDecInsectData> {
  final Value<int?> id;
  const AcwwDecInsectCompanion({
    this.id = const Value.absent(),
  });
  AcwwDecInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcwwDecInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcwwDecInsectCompanion copyWith({Value<int?>? id}) {
    return AcwwDecInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwDecInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcwwDecInsect extends Table
    with TableInfo<AcwwDecInsect, AcwwDecInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwDecInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acww_dec_insect';
  @override
  String get actualTableName => 'acww_dec_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwDecInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwDecInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwDecInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwDecInsect createAlias(String alias) {
    return AcwwDecInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfJanFishData extends DataClass implements Insertable<AccfJanFishData> {
  final int? id;
  AccfJanFishData({this.id});
  factory AccfJanFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfJanFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfJanFishCompanion toCompanion(bool nullToAbsent) {
    return AccfJanFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfJanFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfJanFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfJanFishData copyWith({int? id}) => AccfJanFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfJanFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfJanFishData && other.id == this.id);
}

class AccfJanFishCompanion extends UpdateCompanion<AccfJanFishData> {
  final Value<int?> id;
  const AccfJanFishCompanion({
    this.id = const Value.absent(),
  });
  AccfJanFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfJanFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfJanFishCompanion copyWith({Value<int?>? id}) {
    return AccfJanFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfJanFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfJanFish extends Table with TableInfo<AccfJanFish, AccfJanFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfJanFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_jan_fish';
  @override
  String get actualTableName => 'accf_jan_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfJanFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfJanFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfJanFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfJanFish createAlias(String alias) {
    return AccfJanFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfFebFishData extends DataClass implements Insertable<AccfFebFishData> {
  final int? id;
  AccfFebFishData({this.id});
  factory AccfFebFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfFebFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfFebFishCompanion toCompanion(bool nullToAbsent) {
    return AccfFebFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfFebFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfFebFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfFebFishData copyWith({int? id}) => AccfFebFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfFebFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfFebFishData && other.id == this.id);
}

class AccfFebFishCompanion extends UpdateCompanion<AccfFebFishData> {
  final Value<int?> id;
  const AccfFebFishCompanion({
    this.id = const Value.absent(),
  });
  AccfFebFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfFebFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfFebFishCompanion copyWith({Value<int?>? id}) {
    return AccfFebFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfFebFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfFebFish extends Table with TableInfo<AccfFebFish, AccfFebFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfFebFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_feb_fish';
  @override
  String get actualTableName => 'accf_feb_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfFebFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfFebFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfFebFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfFebFish createAlias(String alias) {
    return AccfFebFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfMarFishData extends DataClass implements Insertable<AccfMarFishData> {
  final int? id;
  AccfMarFishData({this.id});
  factory AccfMarFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfMarFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfMarFishCompanion toCompanion(bool nullToAbsent) {
    return AccfMarFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfMarFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfMarFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfMarFishData copyWith({int? id}) => AccfMarFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfMarFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfMarFishData && other.id == this.id);
}

class AccfMarFishCompanion extends UpdateCompanion<AccfMarFishData> {
  final Value<int?> id;
  const AccfMarFishCompanion({
    this.id = const Value.absent(),
  });
  AccfMarFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfMarFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfMarFishCompanion copyWith({Value<int?>? id}) {
    return AccfMarFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfMarFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfMarFish extends Table with TableInfo<AccfMarFish, AccfMarFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfMarFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_mar_fish';
  @override
  String get actualTableName => 'accf_mar_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfMarFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfMarFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfMarFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfMarFish createAlias(String alias) {
    return AccfMarFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfAprFishData extends DataClass implements Insertable<AccfAprFishData> {
  final int? id;
  AccfAprFishData({this.id});
  factory AccfAprFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfAprFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfAprFishCompanion toCompanion(bool nullToAbsent) {
    return AccfAprFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfAprFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfAprFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfAprFishData copyWith({int? id}) => AccfAprFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfAprFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfAprFishData && other.id == this.id);
}

class AccfAprFishCompanion extends UpdateCompanion<AccfAprFishData> {
  final Value<int?> id;
  const AccfAprFishCompanion({
    this.id = const Value.absent(),
  });
  AccfAprFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfAprFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfAprFishCompanion copyWith({Value<int?>? id}) {
    return AccfAprFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfAprFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfAprFish extends Table with TableInfo<AccfAprFish, AccfAprFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfAprFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_apr_fish';
  @override
  String get actualTableName => 'accf_apr_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfAprFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfAprFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfAprFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfAprFish createAlias(String alias) {
    return AccfAprFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfMayFishData extends DataClass implements Insertable<AccfMayFishData> {
  final int? id;
  AccfMayFishData({this.id});
  factory AccfMayFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfMayFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfMayFishCompanion toCompanion(bool nullToAbsent) {
    return AccfMayFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfMayFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfMayFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfMayFishData copyWith({int? id}) => AccfMayFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfMayFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfMayFishData && other.id == this.id);
}

class AccfMayFishCompanion extends UpdateCompanion<AccfMayFishData> {
  final Value<int?> id;
  const AccfMayFishCompanion({
    this.id = const Value.absent(),
  });
  AccfMayFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfMayFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfMayFishCompanion copyWith({Value<int?>? id}) {
    return AccfMayFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfMayFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfMayFish extends Table with TableInfo<AccfMayFish, AccfMayFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfMayFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_may_fish';
  @override
  String get actualTableName => 'accf_may_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfMayFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfMayFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfMayFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfMayFish createAlias(String alias) {
    return AccfMayFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfJunFishData extends DataClass implements Insertable<AccfJunFishData> {
  final int? id;
  AccfJunFishData({this.id});
  factory AccfJunFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfJunFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfJunFishCompanion toCompanion(bool nullToAbsent) {
    return AccfJunFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfJunFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfJunFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfJunFishData copyWith({int? id}) => AccfJunFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfJunFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfJunFishData && other.id == this.id);
}

class AccfJunFishCompanion extends UpdateCompanion<AccfJunFishData> {
  final Value<int?> id;
  const AccfJunFishCompanion({
    this.id = const Value.absent(),
  });
  AccfJunFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfJunFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfJunFishCompanion copyWith({Value<int?>? id}) {
    return AccfJunFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfJunFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfJunFish extends Table with TableInfo<AccfJunFish, AccfJunFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfJunFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_jun_fish';
  @override
  String get actualTableName => 'accf_jun_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfJunFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfJunFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfJunFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfJunFish createAlias(String alias) {
    return AccfJunFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfJulFishData extends DataClass implements Insertable<AccfJulFishData> {
  final int? id;
  AccfJulFishData({this.id});
  factory AccfJulFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfJulFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfJulFishCompanion toCompanion(bool nullToAbsent) {
    return AccfJulFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfJulFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfJulFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfJulFishData copyWith({int? id}) => AccfJulFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfJulFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfJulFishData && other.id == this.id);
}

class AccfJulFishCompanion extends UpdateCompanion<AccfJulFishData> {
  final Value<int?> id;
  const AccfJulFishCompanion({
    this.id = const Value.absent(),
  });
  AccfJulFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfJulFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfJulFishCompanion copyWith({Value<int?>? id}) {
    return AccfJulFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfJulFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfJulFish extends Table with TableInfo<AccfJulFish, AccfJulFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfJulFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_jul_fish';
  @override
  String get actualTableName => 'accf_jul_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfJulFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfJulFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfJulFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfJulFish createAlias(String alias) {
    return AccfJulFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfAug1FishData extends DataClass
    implements Insertable<AccfAug1FishData> {
  final int? id;
  AccfAug1FishData({this.id});
  factory AccfAug1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfAug1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfAug1FishCompanion toCompanion(bool nullToAbsent) {
    return AccfAug1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfAug1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfAug1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfAug1FishData copyWith({int? id}) => AccfAug1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfAug1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfAug1FishData && other.id == this.id);
}

class AccfAug1FishCompanion extends UpdateCompanion<AccfAug1FishData> {
  final Value<int?> id;
  const AccfAug1FishCompanion({
    this.id = const Value.absent(),
  });
  AccfAug1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfAug1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfAug1FishCompanion copyWith({Value<int?>? id}) {
    return AccfAug1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfAug1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfAug1Fish extends Table
    with TableInfo<AccfAug1Fish, AccfAug1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfAug1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_aug1_fish';
  @override
  String get actualTableName => 'accf_aug1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfAug1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfAug1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfAug1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfAug1Fish createAlias(String alias) {
    return AccfAug1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfAug2FishData extends DataClass
    implements Insertable<AccfAug2FishData> {
  final int? id;
  AccfAug2FishData({this.id});
  factory AccfAug2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfAug2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfAug2FishCompanion toCompanion(bool nullToAbsent) {
    return AccfAug2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfAug2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfAug2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfAug2FishData copyWith({int? id}) => AccfAug2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfAug2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfAug2FishData && other.id == this.id);
}

class AccfAug2FishCompanion extends UpdateCompanion<AccfAug2FishData> {
  final Value<int?> id;
  const AccfAug2FishCompanion({
    this.id = const Value.absent(),
  });
  AccfAug2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfAug2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfAug2FishCompanion copyWith({Value<int?>? id}) {
    return AccfAug2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfAug2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfAug2Fish extends Table
    with TableInfo<AccfAug2Fish, AccfAug2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfAug2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_aug2_fish';
  @override
  String get actualTableName => 'accf_aug2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfAug2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfAug2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfAug2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfAug2Fish createAlias(String alias) {
    return AccfAug2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfSep1FishData extends DataClass
    implements Insertable<AccfSep1FishData> {
  final int? id;
  AccfSep1FishData({this.id});
  factory AccfSep1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfSep1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfSep1FishCompanion toCompanion(bool nullToAbsent) {
    return AccfSep1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfSep1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfSep1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfSep1FishData copyWith({int? id}) => AccfSep1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfSep1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfSep1FishData && other.id == this.id);
}

class AccfSep1FishCompanion extends UpdateCompanion<AccfSep1FishData> {
  final Value<int?> id;
  const AccfSep1FishCompanion({
    this.id = const Value.absent(),
  });
  AccfSep1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfSep1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfSep1FishCompanion copyWith({Value<int?>? id}) {
    return AccfSep1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfSep1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfSep1Fish extends Table
    with TableInfo<AccfSep1Fish, AccfSep1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfSep1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_sep1_fish';
  @override
  String get actualTableName => 'accf_sep1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfSep1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfSep1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfSep1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfSep1Fish createAlias(String alias) {
    return AccfSep1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfSep2FishData extends DataClass
    implements Insertable<AccfSep2FishData> {
  final int? id;
  AccfSep2FishData({this.id});
  factory AccfSep2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfSep2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfSep2FishCompanion toCompanion(bool nullToAbsent) {
    return AccfSep2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfSep2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfSep2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfSep2FishData copyWith({int? id}) => AccfSep2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfSep2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfSep2FishData && other.id == this.id);
}

class AccfSep2FishCompanion extends UpdateCompanion<AccfSep2FishData> {
  final Value<int?> id;
  const AccfSep2FishCompanion({
    this.id = const Value.absent(),
  });
  AccfSep2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfSep2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfSep2FishCompanion copyWith({Value<int?>? id}) {
    return AccfSep2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfSep2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfSep2Fish extends Table
    with TableInfo<AccfSep2Fish, AccfSep2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfSep2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_sep2_fish';
  @override
  String get actualTableName => 'accf_sep2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfSep2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfSep2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfSep2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfSep2Fish createAlias(String alias) {
    return AccfSep2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfOctFishData extends DataClass implements Insertable<AccfOctFishData> {
  final int? id;
  AccfOctFishData({this.id});
  factory AccfOctFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfOctFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfOctFishCompanion toCompanion(bool nullToAbsent) {
    return AccfOctFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfOctFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfOctFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfOctFishData copyWith({int? id}) => AccfOctFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfOctFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfOctFishData && other.id == this.id);
}

class AccfOctFishCompanion extends UpdateCompanion<AccfOctFishData> {
  final Value<int?> id;
  const AccfOctFishCompanion({
    this.id = const Value.absent(),
  });
  AccfOctFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfOctFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfOctFishCompanion copyWith({Value<int?>? id}) {
    return AccfOctFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfOctFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfOctFish extends Table with TableInfo<AccfOctFish, AccfOctFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfOctFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_oct_fish';
  @override
  String get actualTableName => 'accf_oct_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfOctFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfOctFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfOctFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfOctFish createAlias(String alias) {
    return AccfOctFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfNovFishData extends DataClass implements Insertable<AccfNovFishData> {
  final int? id;
  AccfNovFishData({this.id});
  factory AccfNovFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfNovFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfNovFishCompanion toCompanion(bool nullToAbsent) {
    return AccfNovFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfNovFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfNovFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfNovFishData copyWith({int? id}) => AccfNovFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfNovFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfNovFishData && other.id == this.id);
}

class AccfNovFishCompanion extends UpdateCompanion<AccfNovFishData> {
  final Value<int?> id;
  const AccfNovFishCompanion({
    this.id = const Value.absent(),
  });
  AccfNovFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfNovFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfNovFishCompanion copyWith({Value<int?>? id}) {
    return AccfNovFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfNovFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfNovFish extends Table with TableInfo<AccfNovFish, AccfNovFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfNovFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_nov_fish';
  @override
  String get actualTableName => 'accf_nov_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfNovFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfNovFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfNovFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfNovFish createAlias(String alias) {
    return AccfNovFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfDecFishData extends DataClass implements Insertable<AccfDecFishData> {
  final int? id;
  AccfDecFishData({this.id});
  factory AccfDecFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfDecFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfDecFishCompanion toCompanion(bool nullToAbsent) {
    return AccfDecFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfDecFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfDecFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfDecFishData copyWith({int? id}) => AccfDecFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfDecFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfDecFishData && other.id == this.id);
}

class AccfDecFishCompanion extends UpdateCompanion<AccfDecFishData> {
  final Value<int?> id;
  const AccfDecFishCompanion({
    this.id = const Value.absent(),
  });
  AccfDecFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfDecFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfDecFishCompanion copyWith({Value<int?>? id}) {
    return AccfDecFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfDecFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfDecFish extends Table with TableInfo<AccfDecFish, AccfDecFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfDecFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_dec_fish';
  @override
  String get actualTableName => 'accf_dec_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AccfDecFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfDecFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfDecFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfDecFish createAlias(String alias) {
    return AccfDecFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfJanInsectData extends DataClass
    implements Insertable<AccfJanInsectData> {
  final int? id;
  AccfJanInsectData({this.id});
  factory AccfJanInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfJanInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfJanInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfJanInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfJanInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfJanInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfJanInsectData copyWith({int? id}) => AccfJanInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfJanInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfJanInsectData && other.id == this.id);
}

class AccfJanInsectCompanion extends UpdateCompanion<AccfJanInsectData> {
  final Value<int?> id;
  const AccfJanInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfJanInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfJanInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfJanInsectCompanion copyWith({Value<int?>? id}) {
    return AccfJanInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfJanInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfJanInsect extends Table
    with TableInfo<AccfJanInsect, AccfJanInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfJanInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_jan_insect';
  @override
  String get actualTableName => 'accf_jan_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfJanInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfJanInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfJanInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfJanInsect createAlias(String alias) {
    return AccfJanInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfFebInsectData extends DataClass
    implements Insertable<AccfFebInsectData> {
  final int? id;
  AccfFebInsectData({this.id});
  factory AccfFebInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfFebInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfFebInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfFebInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfFebInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfFebInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfFebInsectData copyWith({int? id}) => AccfFebInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfFebInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfFebInsectData && other.id == this.id);
}

class AccfFebInsectCompanion extends UpdateCompanion<AccfFebInsectData> {
  final Value<int?> id;
  const AccfFebInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfFebInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfFebInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfFebInsectCompanion copyWith({Value<int?>? id}) {
    return AccfFebInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfFebInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfFebInsect extends Table
    with TableInfo<AccfFebInsect, AccfFebInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfFebInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_feb_insect';
  @override
  String get actualTableName => 'accf_feb_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfFebInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfFebInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfFebInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfFebInsect createAlias(String alias) {
    return AccfFebInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfMarInsectData extends DataClass
    implements Insertable<AccfMarInsectData> {
  final int? id;
  AccfMarInsectData({this.id});
  factory AccfMarInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfMarInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfMarInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfMarInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfMarInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfMarInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfMarInsectData copyWith({int? id}) => AccfMarInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfMarInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfMarInsectData && other.id == this.id);
}

class AccfMarInsectCompanion extends UpdateCompanion<AccfMarInsectData> {
  final Value<int?> id;
  const AccfMarInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfMarInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfMarInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfMarInsectCompanion copyWith({Value<int?>? id}) {
    return AccfMarInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfMarInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfMarInsect extends Table
    with TableInfo<AccfMarInsect, AccfMarInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfMarInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_mar_insect';
  @override
  String get actualTableName => 'accf_mar_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfMarInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfMarInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfMarInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfMarInsect createAlias(String alias) {
    return AccfMarInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfAprInsectData extends DataClass
    implements Insertable<AccfAprInsectData> {
  final int? id;
  AccfAprInsectData({this.id});
  factory AccfAprInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfAprInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfAprInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfAprInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfAprInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfAprInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfAprInsectData copyWith({int? id}) => AccfAprInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfAprInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfAprInsectData && other.id == this.id);
}

class AccfAprInsectCompanion extends UpdateCompanion<AccfAprInsectData> {
  final Value<int?> id;
  const AccfAprInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfAprInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfAprInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfAprInsectCompanion copyWith({Value<int?>? id}) {
    return AccfAprInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfAprInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfAprInsect extends Table
    with TableInfo<AccfAprInsect, AccfAprInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfAprInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_apr_insect';
  @override
  String get actualTableName => 'accf_apr_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfAprInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfAprInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfAprInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfAprInsect createAlias(String alias) {
    return AccfAprInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfMayInsectData extends DataClass
    implements Insertable<AccfMayInsectData> {
  final int? id;
  AccfMayInsectData({this.id});
  factory AccfMayInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfMayInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfMayInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfMayInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfMayInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfMayInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfMayInsectData copyWith({int? id}) => AccfMayInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfMayInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfMayInsectData && other.id == this.id);
}

class AccfMayInsectCompanion extends UpdateCompanion<AccfMayInsectData> {
  final Value<int?> id;
  const AccfMayInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfMayInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfMayInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfMayInsectCompanion copyWith({Value<int?>? id}) {
    return AccfMayInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfMayInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfMayInsect extends Table
    with TableInfo<AccfMayInsect, AccfMayInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfMayInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_may_insect';
  @override
  String get actualTableName => 'accf_may_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfMayInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfMayInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfMayInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfMayInsect createAlias(String alias) {
    return AccfMayInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfJunInsectData extends DataClass
    implements Insertable<AccfJunInsectData> {
  final int? id;
  AccfJunInsectData({this.id});
  factory AccfJunInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfJunInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfJunInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfJunInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfJunInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfJunInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfJunInsectData copyWith({int? id}) => AccfJunInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfJunInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfJunInsectData && other.id == this.id);
}

class AccfJunInsectCompanion extends UpdateCompanion<AccfJunInsectData> {
  final Value<int?> id;
  const AccfJunInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfJunInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfJunInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfJunInsectCompanion copyWith({Value<int?>? id}) {
    return AccfJunInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfJunInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfJunInsect extends Table
    with TableInfo<AccfJunInsect, AccfJunInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfJunInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_jun_insect';
  @override
  String get actualTableName => 'accf_jun_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfJunInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfJunInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfJunInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfJunInsect createAlias(String alias) {
    return AccfJunInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfJulInsectData extends DataClass
    implements Insertable<AccfJulInsectData> {
  final int? id;
  AccfJulInsectData({this.id});
  factory AccfJulInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfJulInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfJulInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfJulInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfJulInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfJulInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfJulInsectData copyWith({int? id}) => AccfJulInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfJulInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfJulInsectData && other.id == this.id);
}

class AccfJulInsectCompanion extends UpdateCompanion<AccfJulInsectData> {
  final Value<int?> id;
  const AccfJulInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfJulInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfJulInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfJulInsectCompanion copyWith({Value<int?>? id}) {
    return AccfJulInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfJulInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfJulInsect extends Table
    with TableInfo<AccfJulInsect, AccfJulInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfJulInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_jul_insect';
  @override
  String get actualTableName => 'accf_jul_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfJulInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfJulInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfJulInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfJulInsect createAlias(String alias) {
    return AccfJulInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfAug1InsectData extends DataClass
    implements Insertable<AccfAug1InsectData> {
  final int? id;
  AccfAug1InsectData({this.id});
  factory AccfAug1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfAug1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfAug1InsectCompanion toCompanion(bool nullToAbsent) {
    return AccfAug1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfAug1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfAug1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfAug1InsectData copyWith({int? id}) => AccfAug1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfAug1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfAug1InsectData && other.id == this.id);
}

class AccfAug1InsectCompanion extends UpdateCompanion<AccfAug1InsectData> {
  final Value<int?> id;
  const AccfAug1InsectCompanion({
    this.id = const Value.absent(),
  });
  AccfAug1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfAug1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfAug1InsectCompanion copyWith({Value<int?>? id}) {
    return AccfAug1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfAug1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfAug1Insect extends Table
    with TableInfo<AccfAug1Insect, AccfAug1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfAug1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_aug1_insect';
  @override
  String get actualTableName => 'accf_aug1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfAug1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfAug1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfAug1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfAug1Insect createAlias(String alias) {
    return AccfAug1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfAug2InsectData extends DataClass
    implements Insertable<AccfAug2InsectData> {
  final int? id;
  AccfAug2InsectData({this.id});
  factory AccfAug2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfAug2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfAug2InsectCompanion toCompanion(bool nullToAbsent) {
    return AccfAug2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfAug2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfAug2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfAug2InsectData copyWith({int? id}) => AccfAug2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfAug2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfAug2InsectData && other.id == this.id);
}

class AccfAug2InsectCompanion extends UpdateCompanion<AccfAug2InsectData> {
  final Value<int?> id;
  const AccfAug2InsectCompanion({
    this.id = const Value.absent(),
  });
  AccfAug2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfAug2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfAug2InsectCompanion copyWith({Value<int?>? id}) {
    return AccfAug2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfAug2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfAug2Insect extends Table
    with TableInfo<AccfAug2Insect, AccfAug2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfAug2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_aug2_insect';
  @override
  String get actualTableName => 'accf_aug2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfAug2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfAug2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfAug2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfAug2Insect createAlias(String alias) {
    return AccfAug2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfSep1InsectData extends DataClass
    implements Insertable<AccfSep1InsectData> {
  final int? id;
  AccfSep1InsectData({this.id});
  factory AccfSep1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfSep1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfSep1InsectCompanion toCompanion(bool nullToAbsent) {
    return AccfSep1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfSep1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfSep1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfSep1InsectData copyWith({int? id}) => AccfSep1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfSep1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfSep1InsectData && other.id == this.id);
}

class AccfSep1InsectCompanion extends UpdateCompanion<AccfSep1InsectData> {
  final Value<int?> id;
  const AccfSep1InsectCompanion({
    this.id = const Value.absent(),
  });
  AccfSep1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfSep1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfSep1InsectCompanion copyWith({Value<int?>? id}) {
    return AccfSep1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfSep1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfSep1Insect extends Table
    with TableInfo<AccfSep1Insect, AccfSep1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfSep1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_sep1_insect';
  @override
  String get actualTableName => 'accf_sep1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfSep1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfSep1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfSep1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfSep1Insect createAlias(String alias) {
    return AccfSep1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfSep2InsectData extends DataClass
    implements Insertable<AccfSep2InsectData> {
  final int? id;
  AccfSep2InsectData({this.id});
  factory AccfSep2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfSep2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfSep2InsectCompanion toCompanion(bool nullToAbsent) {
    return AccfSep2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfSep2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfSep2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfSep2InsectData copyWith({int? id}) => AccfSep2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfSep2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfSep2InsectData && other.id == this.id);
}

class AccfSep2InsectCompanion extends UpdateCompanion<AccfSep2InsectData> {
  final Value<int?> id;
  const AccfSep2InsectCompanion({
    this.id = const Value.absent(),
  });
  AccfSep2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfSep2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfSep2InsectCompanion copyWith({Value<int?>? id}) {
    return AccfSep2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfSep2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfSep2Insect extends Table
    with TableInfo<AccfSep2Insect, AccfSep2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfSep2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_sep2_insect';
  @override
  String get actualTableName => 'accf_sep2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfSep2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfSep2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfSep2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfSep2Insect createAlias(String alias) {
    return AccfSep2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfOctInsectData extends DataClass
    implements Insertable<AccfOctInsectData> {
  final int? id;
  AccfOctInsectData({this.id});
  factory AccfOctInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfOctInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfOctInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfOctInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfOctInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfOctInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfOctInsectData copyWith({int? id}) => AccfOctInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfOctInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfOctInsectData && other.id == this.id);
}

class AccfOctInsectCompanion extends UpdateCompanion<AccfOctInsectData> {
  final Value<int?> id;
  const AccfOctInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfOctInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfOctInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfOctInsectCompanion copyWith({Value<int?>? id}) {
    return AccfOctInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfOctInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfOctInsect extends Table
    with TableInfo<AccfOctInsect, AccfOctInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfOctInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_oct_insect';
  @override
  String get actualTableName => 'accf_oct_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfOctInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfOctInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfOctInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfOctInsect createAlias(String alias) {
    return AccfOctInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfNovInsectData extends DataClass
    implements Insertable<AccfNovInsectData> {
  final int? id;
  AccfNovInsectData({this.id});
  factory AccfNovInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfNovInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfNovInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfNovInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfNovInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfNovInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfNovInsectData copyWith({int? id}) => AccfNovInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfNovInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfNovInsectData && other.id == this.id);
}

class AccfNovInsectCompanion extends UpdateCompanion<AccfNovInsectData> {
  final Value<int?> id;
  const AccfNovInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfNovInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfNovInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfNovInsectCompanion copyWith({Value<int?>? id}) {
    return AccfNovInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfNovInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfNovInsect extends Table
    with TableInfo<AccfNovInsect, AccfNovInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfNovInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_nov_insect';
  @override
  String get actualTableName => 'accf_nov_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfNovInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfNovInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfNovInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfNovInsect createAlias(String alias) {
    return AccfNovInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfDecInsectData extends DataClass
    implements Insertable<AccfDecInsectData> {
  final int? id;
  AccfDecInsectData({this.id});
  factory AccfDecInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfDecInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AccfDecInsectCompanion toCompanion(bool nullToAbsent) {
    return AccfDecInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AccfDecInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfDecInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AccfDecInsectData copyWith({int? id}) => AccfDecInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AccfDecInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfDecInsectData && other.id == this.id);
}

class AccfDecInsectCompanion extends UpdateCompanion<AccfDecInsectData> {
  final Value<int?> id;
  const AccfDecInsectCompanion({
    this.id = const Value.absent(),
  });
  AccfDecInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AccfDecInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AccfDecInsectCompanion copyWith({Value<int?>? id}) {
    return AccfDecInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfDecInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AccfDecInsect extends Table
    with TableInfo<AccfDecInsect, AccfDecInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfDecInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'accf_dec_insect';
  @override
  String get actualTableName => 'accf_dec_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AccfDecInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfDecInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfDecInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfDecInsect createAlias(String alias) {
    return AccfDecInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJanFishData extends DataClass implements Insertable<AcnlJanFishData> {
  final int? id;
  AcnlJanFishData({this.id});
  factory AcnlJanFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJanFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJanFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlJanFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJanFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJanFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJanFishData copyWith({int? id}) => AcnlJanFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJanFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJanFishData && other.id == this.id);
}

class AcnlJanFishCompanion extends UpdateCompanion<AcnlJanFishData> {
  final Value<int?> id;
  const AcnlJanFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlJanFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJanFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJanFishCompanion copyWith({Value<int?>? id}) {
    return AcnlJanFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJanFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJanFish extends Table with TableInfo<AcnlJanFish, AcnlJanFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJanFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jan_fish';
  @override
  String get actualTableName => 'acnl_jan_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJanFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJanFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJanFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJanFish createAlias(String alias) {
    return AcnlJanFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFebFishData extends DataClass implements Insertable<AcnlFebFishData> {
  final int? id;
  AcnlFebFishData({this.id});
  factory AcnlFebFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFebFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlFebFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlFebFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlFebFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFebFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlFebFishData copyWith({int? id}) => AcnlFebFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFebFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFebFishData && other.id == this.id);
}

class AcnlFebFishCompanion extends UpdateCompanion<AcnlFebFishData> {
  final Value<int?> id;
  const AcnlFebFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlFebFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlFebFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlFebFishCompanion copyWith({Value<int?>? id}) {
    return AcnlFebFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFebFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlFebFish extends Table with TableInfo<AcnlFebFish, AcnlFebFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFebFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_feb_fish';
  @override
  String get actualTableName => 'acnl_feb_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlFebFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFebFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFebFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFebFish createAlias(String alias) {
    return AcnlFebFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlMarFishData extends DataClass implements Insertable<AcnlMarFishData> {
  final int? id;
  AcnlMarFishData({this.id});
  factory AcnlMarFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlMarFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlMarFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlMarFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlMarFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlMarFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlMarFishData copyWith({int? id}) => AcnlMarFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlMarFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlMarFishData && other.id == this.id);
}

class AcnlMarFishCompanion extends UpdateCompanion<AcnlMarFishData> {
  final Value<int?> id;
  const AcnlMarFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlMarFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlMarFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlMarFishCompanion copyWith({Value<int?>? id}) {
    return AcnlMarFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlMarFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlMarFish extends Table with TableInfo<AcnlMarFish, AcnlMarFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlMarFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_mar_fish';
  @override
  String get actualTableName => 'acnl_mar_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlMarFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlMarFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlMarFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlMarFish createAlias(String alias) {
    return AcnlMarFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAprFishData extends DataClass implements Insertable<AcnlAprFishData> {
  final int? id;
  AcnlAprFishData({this.id});
  factory AcnlAprFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAprFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAprFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlAprFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAprFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAprFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAprFishData copyWith({int? id}) => AcnlAprFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAprFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAprFishData && other.id == this.id);
}

class AcnlAprFishCompanion extends UpdateCompanion<AcnlAprFishData> {
  final Value<int?> id;
  const AcnlAprFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlAprFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAprFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAprFishCompanion copyWith({Value<int?>? id}) {
    return AcnlAprFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAprFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAprFish extends Table with TableInfo<AcnlAprFish, AcnlAprFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAprFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_apr_fish';
  @override
  String get actualTableName => 'acnl_apr_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAprFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAprFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAprFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAprFish createAlias(String alias) {
    return AcnlAprFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlMayFishData extends DataClass implements Insertable<AcnlMayFishData> {
  final int? id;
  AcnlMayFishData({this.id});
  factory AcnlMayFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlMayFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlMayFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlMayFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlMayFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlMayFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlMayFishData copyWith({int? id}) => AcnlMayFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlMayFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlMayFishData && other.id == this.id);
}

class AcnlMayFishCompanion extends UpdateCompanion<AcnlMayFishData> {
  final Value<int?> id;
  const AcnlMayFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlMayFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlMayFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlMayFishCompanion copyWith({Value<int?>? id}) {
    return AcnlMayFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlMayFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlMayFish extends Table with TableInfo<AcnlMayFish, AcnlMayFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlMayFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_may_fish';
  @override
  String get actualTableName => 'acnl_may_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlMayFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlMayFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlMayFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlMayFish createAlias(String alias) {
    return AcnlMayFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJunFishData extends DataClass implements Insertable<AcnlJunFishData> {
  final int? id;
  AcnlJunFishData({this.id});
  factory AcnlJunFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJunFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJunFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlJunFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJunFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJunFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJunFishData copyWith({int? id}) => AcnlJunFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJunFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJunFishData && other.id == this.id);
}

class AcnlJunFishCompanion extends UpdateCompanion<AcnlJunFishData> {
  final Value<int?> id;
  const AcnlJunFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlJunFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJunFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJunFishCompanion copyWith({Value<int?>? id}) {
    return AcnlJunFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJunFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJunFish extends Table with TableInfo<AcnlJunFish, AcnlJunFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJunFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jun_fish';
  @override
  String get actualTableName => 'acnl_jun_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJunFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJunFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJunFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJunFish createAlias(String alias) {
    return AcnlJunFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJulFishData extends DataClass implements Insertable<AcnlJulFishData> {
  final int? id;
  AcnlJulFishData({this.id});
  factory AcnlJulFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJulFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJulFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlJulFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJulFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJulFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJulFishData copyWith({int? id}) => AcnlJulFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJulFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJulFishData && other.id == this.id);
}

class AcnlJulFishCompanion extends UpdateCompanion<AcnlJulFishData> {
  final Value<int?> id;
  const AcnlJulFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlJulFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJulFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJulFishCompanion copyWith({Value<int?>? id}) {
    return AcnlJulFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJulFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJulFish extends Table with TableInfo<AcnlJulFish, AcnlJulFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJulFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jul_fish';
  @override
  String get actualTableName => 'acnl_jul_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJulFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJulFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJulFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJulFish createAlias(String alias) {
    return AcnlJulFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAug1FishData extends DataClass
    implements Insertable<AcnlAug1FishData> {
  final int? id;
  AcnlAug1FishData({this.id});
  factory AcnlAug1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAug1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAug1FishCompanion toCompanion(bool nullToAbsent) {
    return AcnlAug1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAug1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAug1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAug1FishData copyWith({int? id}) => AcnlAug1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAug1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAug1FishData && other.id == this.id);
}

class AcnlAug1FishCompanion extends UpdateCompanion<AcnlAug1FishData> {
  final Value<int?> id;
  const AcnlAug1FishCompanion({
    this.id = const Value.absent(),
  });
  AcnlAug1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAug1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAug1FishCompanion copyWith({Value<int?>? id}) {
    return AcnlAug1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAug1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAug1Fish extends Table
    with TableInfo<AcnlAug1Fish, AcnlAug1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAug1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_aug1_fish';
  @override
  String get actualTableName => 'acnl_aug1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAug1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAug1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAug1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAug1Fish createAlias(String alias) {
    return AcnlAug1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAug2FishData extends DataClass
    implements Insertable<AcnlAug2FishData> {
  final int? id;
  AcnlAug2FishData({this.id});
  factory AcnlAug2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAug2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAug2FishCompanion toCompanion(bool nullToAbsent) {
    return AcnlAug2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAug2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAug2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAug2FishData copyWith({int? id}) => AcnlAug2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAug2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAug2FishData && other.id == this.id);
}

class AcnlAug2FishCompanion extends UpdateCompanion<AcnlAug2FishData> {
  final Value<int?> id;
  const AcnlAug2FishCompanion({
    this.id = const Value.absent(),
  });
  AcnlAug2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAug2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAug2FishCompanion copyWith({Value<int?>? id}) {
    return AcnlAug2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAug2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAug2Fish extends Table
    with TableInfo<AcnlAug2Fish, AcnlAug2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAug2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_aug2_fish';
  @override
  String get actualTableName => 'acnl_aug2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAug2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAug2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAug2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAug2Fish createAlias(String alias) {
    return AcnlAug2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSep1FishData extends DataClass
    implements Insertable<AcnlSep1FishData> {
  final int? id;
  AcnlSep1FishData({this.id});
  factory AcnlSep1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSep1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlSep1FishCompanion toCompanion(bool nullToAbsent) {
    return AcnlSep1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlSep1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSep1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlSep1FishData copyWith({int? id}) => AcnlSep1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSep1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSep1FishData && other.id == this.id);
}

class AcnlSep1FishCompanion extends UpdateCompanion<AcnlSep1FishData> {
  final Value<int?> id;
  const AcnlSep1FishCompanion({
    this.id = const Value.absent(),
  });
  AcnlSep1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlSep1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlSep1FishCompanion copyWith({Value<int?>? id}) {
    return AcnlSep1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSep1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlSep1Fish extends Table
    with TableInfo<AcnlSep1Fish, AcnlSep1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSep1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_sep1_fish';
  @override
  String get actualTableName => 'acnl_sep1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlSep1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSep1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSep1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSep1Fish createAlias(String alias) {
    return AcnlSep1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSep2FishData extends DataClass
    implements Insertable<AcnlSep2FishData> {
  final int? id;
  AcnlSep2FishData({this.id});
  factory AcnlSep2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSep2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlSep2FishCompanion toCompanion(bool nullToAbsent) {
    return AcnlSep2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlSep2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSep2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlSep2FishData copyWith({int? id}) => AcnlSep2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSep2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSep2FishData && other.id == this.id);
}

class AcnlSep2FishCompanion extends UpdateCompanion<AcnlSep2FishData> {
  final Value<int?> id;
  const AcnlSep2FishCompanion({
    this.id = const Value.absent(),
  });
  AcnlSep2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlSep2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlSep2FishCompanion copyWith({Value<int?>? id}) {
    return AcnlSep2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSep2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlSep2Fish extends Table
    with TableInfo<AcnlSep2Fish, AcnlSep2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSep2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_sep2_fish';
  @override
  String get actualTableName => 'acnl_sep2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlSep2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSep2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSep2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSep2Fish createAlias(String alias) {
    return AcnlSep2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlOctFishData extends DataClass implements Insertable<AcnlOctFishData> {
  final int? id;
  AcnlOctFishData({this.id});
  factory AcnlOctFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlOctFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlOctFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlOctFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlOctFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlOctFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlOctFishData copyWith({int? id}) => AcnlOctFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlOctFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlOctFishData && other.id == this.id);
}

class AcnlOctFishCompanion extends UpdateCompanion<AcnlOctFishData> {
  final Value<int?> id;
  const AcnlOctFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlOctFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlOctFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlOctFishCompanion copyWith({Value<int?>? id}) {
    return AcnlOctFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlOctFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlOctFish extends Table with TableInfo<AcnlOctFish, AcnlOctFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlOctFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_oct_fish';
  @override
  String get actualTableName => 'acnl_oct_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlOctFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlOctFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlOctFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlOctFish createAlias(String alias) {
    return AcnlOctFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlNovFishData extends DataClass implements Insertable<AcnlNovFishData> {
  final int? id;
  AcnlNovFishData({this.id});
  factory AcnlNovFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlNovFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlNovFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlNovFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlNovFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlNovFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlNovFishData copyWith({int? id}) => AcnlNovFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlNovFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlNovFishData && other.id == this.id);
}

class AcnlNovFishCompanion extends UpdateCompanion<AcnlNovFishData> {
  final Value<int?> id;
  const AcnlNovFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlNovFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlNovFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlNovFishCompanion copyWith({Value<int?>? id}) {
    return AcnlNovFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlNovFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlNovFish extends Table with TableInfo<AcnlNovFish, AcnlNovFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlNovFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_nov_fish';
  @override
  String get actualTableName => 'acnl_nov_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlNovFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlNovFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlNovFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlNovFish createAlias(String alias) {
    return AcnlNovFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlDecFishData extends DataClass implements Insertable<AcnlDecFishData> {
  final int? id;
  AcnlDecFishData({this.id});
  factory AcnlDecFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlDecFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlDecFishCompanion toCompanion(bool nullToAbsent) {
    return AcnlDecFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlDecFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlDecFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlDecFishData copyWith({int? id}) => AcnlDecFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlDecFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlDecFishData && other.id == this.id);
}

class AcnlDecFishCompanion extends UpdateCompanion<AcnlDecFishData> {
  final Value<int?> id;
  const AcnlDecFishCompanion({
    this.id = const Value.absent(),
  });
  AcnlDecFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlDecFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlDecFishCompanion copyWith({Value<int?>? id}) {
    return AcnlDecFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlDecFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlDecFish extends Table with TableInfo<AcnlDecFish, AcnlDecFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlDecFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_dec_fish';
  @override
  String get actualTableName => 'acnl_dec_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlDecFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlDecFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlDecFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlDecFish createAlias(String alias) {
    return AcnlDecFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJanInsectData extends DataClass
    implements Insertable<AcnlJanInsectData> {
  final int? id;
  AcnlJanInsectData({this.id});
  factory AcnlJanInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJanInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJanInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlJanInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJanInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJanInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJanInsectData copyWith({int? id}) => AcnlJanInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJanInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJanInsectData && other.id == this.id);
}

class AcnlJanInsectCompanion extends UpdateCompanion<AcnlJanInsectData> {
  final Value<int?> id;
  const AcnlJanInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlJanInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJanInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJanInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlJanInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJanInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJanInsect extends Table
    with TableInfo<AcnlJanInsect, AcnlJanInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJanInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jan_insect';
  @override
  String get actualTableName => 'acnl_jan_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJanInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJanInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJanInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJanInsect createAlias(String alias) {
    return AcnlJanInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFebInsectData extends DataClass
    implements Insertable<AcnlFebInsectData> {
  final int? id;
  AcnlFebInsectData({this.id});
  factory AcnlFebInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFebInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlFebInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlFebInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlFebInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFebInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlFebInsectData copyWith({int? id}) => AcnlFebInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFebInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFebInsectData && other.id == this.id);
}

class AcnlFebInsectCompanion extends UpdateCompanion<AcnlFebInsectData> {
  final Value<int?> id;
  const AcnlFebInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlFebInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlFebInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlFebInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlFebInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFebInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlFebInsect extends Table
    with TableInfo<AcnlFebInsect, AcnlFebInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFebInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_feb_insect';
  @override
  String get actualTableName => 'acnl_feb_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlFebInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFebInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFebInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFebInsect createAlias(String alias) {
    return AcnlFebInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlMarInsectData extends DataClass
    implements Insertable<AcnlMarInsectData> {
  final int? id;
  AcnlMarInsectData({this.id});
  factory AcnlMarInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlMarInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlMarInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlMarInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlMarInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlMarInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlMarInsectData copyWith({int? id}) => AcnlMarInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlMarInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlMarInsectData && other.id == this.id);
}

class AcnlMarInsectCompanion extends UpdateCompanion<AcnlMarInsectData> {
  final Value<int?> id;
  const AcnlMarInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlMarInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlMarInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlMarInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlMarInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlMarInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlMarInsect extends Table
    with TableInfo<AcnlMarInsect, AcnlMarInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlMarInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_mar_insect';
  @override
  String get actualTableName => 'acnl_mar_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlMarInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlMarInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlMarInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlMarInsect createAlias(String alias) {
    return AcnlMarInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAprInsectData extends DataClass
    implements Insertable<AcnlAprInsectData> {
  final int? id;
  AcnlAprInsectData({this.id});
  factory AcnlAprInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAprInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAprInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlAprInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAprInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAprInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAprInsectData copyWith({int? id}) => AcnlAprInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAprInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAprInsectData && other.id == this.id);
}

class AcnlAprInsectCompanion extends UpdateCompanion<AcnlAprInsectData> {
  final Value<int?> id;
  const AcnlAprInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlAprInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAprInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAprInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlAprInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAprInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAprInsect extends Table
    with TableInfo<AcnlAprInsect, AcnlAprInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAprInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_apr_insect';
  @override
  String get actualTableName => 'acnl_apr_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAprInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAprInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAprInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAprInsect createAlias(String alias) {
    return AcnlAprInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlMayInsectData extends DataClass
    implements Insertable<AcnlMayInsectData> {
  final int? id;
  AcnlMayInsectData({this.id});
  factory AcnlMayInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlMayInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlMayInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlMayInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlMayInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlMayInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlMayInsectData copyWith({int? id}) => AcnlMayInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlMayInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlMayInsectData && other.id == this.id);
}

class AcnlMayInsectCompanion extends UpdateCompanion<AcnlMayInsectData> {
  final Value<int?> id;
  const AcnlMayInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlMayInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlMayInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlMayInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlMayInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlMayInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlMayInsect extends Table
    with TableInfo<AcnlMayInsect, AcnlMayInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlMayInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_may_insect';
  @override
  String get actualTableName => 'acnl_may_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlMayInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlMayInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlMayInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlMayInsect createAlias(String alias) {
    return AcnlMayInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJunInsectData extends DataClass
    implements Insertable<AcnlJunInsectData> {
  final int? id;
  AcnlJunInsectData({this.id});
  factory AcnlJunInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJunInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJunInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlJunInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJunInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJunInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJunInsectData copyWith({int? id}) => AcnlJunInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJunInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJunInsectData && other.id == this.id);
}

class AcnlJunInsectCompanion extends UpdateCompanion<AcnlJunInsectData> {
  final Value<int?> id;
  const AcnlJunInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlJunInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJunInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJunInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlJunInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJunInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJunInsect extends Table
    with TableInfo<AcnlJunInsect, AcnlJunInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJunInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jun_insect';
  @override
  String get actualTableName => 'acnl_jun_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJunInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJunInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJunInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJunInsect createAlias(String alias) {
    return AcnlJunInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJulInsectData extends DataClass
    implements Insertable<AcnlJulInsectData> {
  final int? id;
  AcnlJulInsectData({this.id});
  factory AcnlJulInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJulInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJulInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlJulInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJulInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJulInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJulInsectData copyWith({int? id}) => AcnlJulInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJulInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJulInsectData && other.id == this.id);
}

class AcnlJulInsectCompanion extends UpdateCompanion<AcnlJulInsectData> {
  final Value<int?> id;
  const AcnlJulInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlJulInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJulInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJulInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlJulInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJulInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJulInsect extends Table
    with TableInfo<AcnlJulInsect, AcnlJulInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJulInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jul_insect';
  @override
  String get actualTableName => 'acnl_jul_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJulInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJulInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJulInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJulInsect createAlias(String alias) {
    return AcnlJulInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAug1InsectData extends DataClass
    implements Insertable<AcnlAug1InsectData> {
  final int? id;
  AcnlAug1InsectData({this.id});
  factory AcnlAug1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAug1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAug1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlAug1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAug1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAug1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAug1InsectData copyWith({int? id}) => AcnlAug1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAug1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAug1InsectData && other.id == this.id);
}

class AcnlAug1InsectCompanion extends UpdateCompanion<AcnlAug1InsectData> {
  final Value<int?> id;
  const AcnlAug1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlAug1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAug1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAug1InsectCompanion copyWith({Value<int?>? id}) {
    return AcnlAug1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAug1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAug1Insect extends Table
    with TableInfo<AcnlAug1Insect, AcnlAug1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAug1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_aug1_insect';
  @override
  String get actualTableName => 'acnl_aug1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAug1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAug1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAug1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAug1Insect createAlias(String alias) {
    return AcnlAug1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAug2InsectData extends DataClass
    implements Insertable<AcnlAug2InsectData> {
  final int? id;
  AcnlAug2InsectData({this.id});
  factory AcnlAug2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAug2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAug2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlAug2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAug2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAug2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAug2InsectData copyWith({int? id}) => AcnlAug2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAug2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAug2InsectData && other.id == this.id);
}

class AcnlAug2InsectCompanion extends UpdateCompanion<AcnlAug2InsectData> {
  final Value<int?> id;
  const AcnlAug2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlAug2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAug2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAug2InsectCompanion copyWith({Value<int?>? id}) {
    return AcnlAug2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAug2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAug2Insect extends Table
    with TableInfo<AcnlAug2Insect, AcnlAug2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAug2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_aug2_insect';
  @override
  String get actualTableName => 'acnl_aug2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAug2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAug2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAug2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAug2Insect createAlias(String alias) {
    return AcnlAug2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSep1InsectData extends DataClass
    implements Insertable<AcnlSep1InsectData> {
  final int? id;
  AcnlSep1InsectData({this.id});
  factory AcnlSep1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSep1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlSep1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlSep1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlSep1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSep1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlSep1InsectData copyWith({int? id}) => AcnlSep1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSep1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSep1InsectData && other.id == this.id);
}

class AcnlSep1InsectCompanion extends UpdateCompanion<AcnlSep1InsectData> {
  final Value<int?> id;
  const AcnlSep1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlSep1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlSep1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlSep1InsectCompanion copyWith({Value<int?>? id}) {
    return AcnlSep1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSep1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlSep1Insect extends Table
    with TableInfo<AcnlSep1Insect, AcnlSep1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSep1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_sep1_insect';
  @override
  String get actualTableName => 'acnl_sep1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlSep1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSep1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSep1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSep1Insect createAlias(String alias) {
    return AcnlSep1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSep2InsectData extends DataClass
    implements Insertable<AcnlSep2InsectData> {
  final int? id;
  AcnlSep2InsectData({this.id});
  factory AcnlSep2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSep2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlSep2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlSep2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlSep2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSep2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlSep2InsectData copyWith({int? id}) => AcnlSep2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSep2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSep2InsectData && other.id == this.id);
}

class AcnlSep2InsectCompanion extends UpdateCompanion<AcnlSep2InsectData> {
  final Value<int?> id;
  const AcnlSep2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlSep2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlSep2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlSep2InsectCompanion copyWith({Value<int?>? id}) {
    return AcnlSep2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSep2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlSep2Insect extends Table
    with TableInfo<AcnlSep2Insect, AcnlSep2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSep2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_sep2_insect';
  @override
  String get actualTableName => 'acnl_sep2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlSep2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSep2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSep2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSep2Insect createAlias(String alias) {
    return AcnlSep2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlOctInsectData extends DataClass
    implements Insertable<AcnlOctInsectData> {
  final int? id;
  AcnlOctInsectData({this.id});
  factory AcnlOctInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlOctInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlOctInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlOctInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlOctInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlOctInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlOctInsectData copyWith({int? id}) => AcnlOctInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlOctInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlOctInsectData && other.id == this.id);
}

class AcnlOctInsectCompanion extends UpdateCompanion<AcnlOctInsectData> {
  final Value<int?> id;
  const AcnlOctInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlOctInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlOctInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlOctInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlOctInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlOctInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlOctInsect extends Table
    with TableInfo<AcnlOctInsect, AcnlOctInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlOctInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_oct_insect';
  @override
  String get actualTableName => 'acnl_oct_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlOctInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlOctInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlOctInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlOctInsect createAlias(String alias) {
    return AcnlOctInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlNovInsectData extends DataClass
    implements Insertable<AcnlNovInsectData> {
  final int? id;
  AcnlNovInsectData({this.id});
  factory AcnlNovInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlNovInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlNovInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlNovInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlNovInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlNovInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlNovInsectData copyWith({int? id}) => AcnlNovInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlNovInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlNovInsectData && other.id == this.id);
}

class AcnlNovInsectCompanion extends UpdateCompanion<AcnlNovInsectData> {
  final Value<int?> id;
  const AcnlNovInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlNovInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlNovInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlNovInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlNovInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlNovInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlNovInsect extends Table
    with TableInfo<AcnlNovInsect, AcnlNovInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlNovInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_nov_insect';
  @override
  String get actualTableName => 'acnl_nov_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlNovInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlNovInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlNovInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlNovInsect createAlias(String alias) {
    return AcnlNovInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlDecInsectData extends DataClass
    implements Insertable<AcnlDecInsectData> {
  final int? id;
  AcnlDecInsectData({this.id});
  factory AcnlDecInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlDecInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlDecInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnlDecInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlDecInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlDecInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlDecInsectData copyWith({int? id}) => AcnlDecInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlDecInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlDecInsectData && other.id == this.id);
}

class AcnlDecInsectCompanion extends UpdateCompanion<AcnlDecInsectData> {
  final Value<int?> id;
  const AcnlDecInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnlDecInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlDecInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlDecInsectCompanion copyWith({Value<int?>? id}) {
    return AcnlDecInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlDecInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlDecInsect extends Table
    with TableInfo<AcnlDecInsect, AcnlDecInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlDecInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_dec_insect';
  @override
  String get actualTableName => 'acnl_dec_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlDecInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlDecInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlDecInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlDecInsect createAlias(String alias) {
    return AcnlDecInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJanSeafoodData extends DataClass
    implements Insertable<AcnlJanSeafoodData> {
  final int? id;
  AcnlJanSeafoodData({this.id});
  factory AcnlJanSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJanSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJanSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlJanSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJanSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJanSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJanSeafoodData copyWith({int? id}) => AcnlJanSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJanSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJanSeafoodData && other.id == this.id);
}

class AcnlJanSeafoodCompanion extends UpdateCompanion<AcnlJanSeafoodData> {
  final Value<int?> id;
  const AcnlJanSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlJanSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJanSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJanSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlJanSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJanSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJanSeafood extends Table
    with TableInfo<AcnlJanSeafood, AcnlJanSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJanSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jan_seafood';
  @override
  String get actualTableName => 'acnl_jan_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJanSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJanSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJanSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJanSeafood createAlias(String alias) {
    return AcnlJanSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlFebSeafoodData extends DataClass
    implements Insertable<AcnlFebSeafoodData> {
  final int? id;
  AcnlFebSeafoodData({this.id});
  factory AcnlFebSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlFebSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlFebSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlFebSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlFebSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlFebSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlFebSeafoodData copyWith({int? id}) => AcnlFebSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlFebSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlFebSeafoodData && other.id == this.id);
}

class AcnlFebSeafoodCompanion extends UpdateCompanion<AcnlFebSeafoodData> {
  final Value<int?> id;
  const AcnlFebSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlFebSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlFebSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlFebSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlFebSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlFebSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlFebSeafood extends Table
    with TableInfo<AcnlFebSeafood, AcnlFebSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlFebSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_feb_seafood';
  @override
  String get actualTableName => 'acnl_feb_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlFebSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlFebSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlFebSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlFebSeafood createAlias(String alias) {
    return AcnlFebSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlMarSeafoodData extends DataClass
    implements Insertable<AcnlMarSeafoodData> {
  final int? id;
  AcnlMarSeafoodData({this.id});
  factory AcnlMarSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlMarSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlMarSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlMarSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlMarSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlMarSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlMarSeafoodData copyWith({int? id}) => AcnlMarSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlMarSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlMarSeafoodData && other.id == this.id);
}

class AcnlMarSeafoodCompanion extends UpdateCompanion<AcnlMarSeafoodData> {
  final Value<int?> id;
  const AcnlMarSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlMarSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlMarSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlMarSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlMarSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlMarSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlMarSeafood extends Table
    with TableInfo<AcnlMarSeafood, AcnlMarSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlMarSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_mar_seafood';
  @override
  String get actualTableName => 'acnl_mar_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlMarSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlMarSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlMarSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlMarSeafood createAlias(String alias) {
    return AcnlMarSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAprSeafoodData extends DataClass
    implements Insertable<AcnlAprSeafoodData> {
  final int? id;
  AcnlAprSeafoodData({this.id});
  factory AcnlAprSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAprSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAprSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlAprSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAprSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAprSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAprSeafoodData copyWith({int? id}) => AcnlAprSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAprSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAprSeafoodData && other.id == this.id);
}

class AcnlAprSeafoodCompanion extends UpdateCompanion<AcnlAprSeafoodData> {
  final Value<int?> id;
  const AcnlAprSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlAprSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAprSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAprSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlAprSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAprSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAprSeafood extends Table
    with TableInfo<AcnlAprSeafood, AcnlAprSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAprSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_apr_seafood';
  @override
  String get actualTableName => 'acnl_apr_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlAprSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAprSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAprSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAprSeafood createAlias(String alias) {
    return AcnlAprSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlMaySeafoodData extends DataClass
    implements Insertable<AcnlMaySeafoodData> {
  final int? id;
  AcnlMaySeafoodData({this.id});
  factory AcnlMaySeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlMaySeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlMaySeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlMaySeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlMaySeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlMaySeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlMaySeafoodData copyWith({int? id}) => AcnlMaySeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlMaySeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlMaySeafoodData && other.id == this.id);
}

class AcnlMaySeafoodCompanion extends UpdateCompanion<AcnlMaySeafoodData> {
  final Value<int?> id;
  const AcnlMaySeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlMaySeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlMaySeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlMaySeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlMaySeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlMaySeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlMaySeafood extends Table
    with TableInfo<AcnlMaySeafood, AcnlMaySeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlMaySeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_may_seafood';
  @override
  String get actualTableName => 'acnl_may_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlMaySeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlMaySeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlMaySeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlMaySeafood createAlias(String alias) {
    return AcnlMaySeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJunSeafoodData extends DataClass
    implements Insertable<AcnlJunSeafoodData> {
  final int? id;
  AcnlJunSeafoodData({this.id});
  factory AcnlJunSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJunSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJunSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlJunSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJunSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJunSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJunSeafoodData copyWith({int? id}) => AcnlJunSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJunSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJunSeafoodData && other.id == this.id);
}

class AcnlJunSeafoodCompanion extends UpdateCompanion<AcnlJunSeafoodData> {
  final Value<int?> id;
  const AcnlJunSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlJunSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJunSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJunSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlJunSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJunSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJunSeafood extends Table
    with TableInfo<AcnlJunSeafood, AcnlJunSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJunSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jun_seafood';
  @override
  String get actualTableName => 'acnl_jun_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJunSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJunSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJunSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJunSeafood createAlias(String alias) {
    return AcnlJunSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlJulSeafoodData extends DataClass
    implements Insertable<AcnlJulSeafoodData> {
  final int? id;
  AcnlJulSeafoodData({this.id});
  factory AcnlJulSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlJulSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlJulSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlJulSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlJulSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlJulSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlJulSeafoodData copyWith({int? id}) => AcnlJulSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlJulSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlJulSeafoodData && other.id == this.id);
}

class AcnlJulSeafoodCompanion extends UpdateCompanion<AcnlJulSeafoodData> {
  final Value<int?> id;
  const AcnlJulSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlJulSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlJulSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlJulSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlJulSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlJulSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlJulSeafood extends Table
    with TableInfo<AcnlJulSeafood, AcnlJulSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlJulSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_jul_seafood';
  @override
  String get actualTableName => 'acnl_jul_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlJulSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlJulSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlJulSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlJulSeafood createAlias(String alias) {
    return AcnlJulSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAug1SeafoodData extends DataClass
    implements Insertable<AcnlAug1SeafoodData> {
  final int? id;
  AcnlAug1SeafoodData({this.id});
  factory AcnlAug1SeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAug1SeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAug1SeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlAug1SeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAug1SeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAug1SeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAug1SeafoodData copyWith({int? id}) => AcnlAug1SeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAug1SeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAug1SeafoodData && other.id == this.id);
}

class AcnlAug1SeafoodCompanion extends UpdateCompanion<AcnlAug1SeafoodData> {
  final Value<int?> id;
  const AcnlAug1SeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlAug1SeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAug1SeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAug1SeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlAug1SeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAug1SeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAug1Seafood extends Table
    with TableInfo<AcnlAug1Seafood, AcnlAug1SeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAug1Seafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_aug1_seafood';
  @override
  String get actualTableName => 'acnl_aug1_seafood';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnlAug1SeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAug1SeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAug1SeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAug1Seafood createAlias(String alias) {
    return AcnlAug1Seafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlAug2SeafoodData extends DataClass
    implements Insertable<AcnlAug2SeafoodData> {
  final int? id;
  AcnlAug2SeafoodData({this.id});
  factory AcnlAug2SeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlAug2SeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlAug2SeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlAug2SeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlAug2SeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlAug2SeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlAug2SeafoodData copyWith({int? id}) => AcnlAug2SeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlAug2SeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlAug2SeafoodData && other.id == this.id);
}

class AcnlAug2SeafoodCompanion extends UpdateCompanion<AcnlAug2SeafoodData> {
  final Value<int?> id;
  const AcnlAug2SeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlAug2SeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlAug2SeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlAug2SeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlAug2SeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlAug2SeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlAug2Seafood extends Table
    with TableInfo<AcnlAug2Seafood, AcnlAug2SeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlAug2Seafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_aug2_seafood';
  @override
  String get actualTableName => 'acnl_aug2_seafood';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnlAug2SeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlAug2SeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlAug2SeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlAug2Seafood createAlias(String alias) {
    return AcnlAug2Seafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSep1SeafoodData extends DataClass
    implements Insertable<AcnlSep1SeafoodData> {
  final int? id;
  AcnlSep1SeafoodData({this.id});
  factory AcnlSep1SeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSep1SeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlSep1SeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlSep1SeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlSep1SeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSep1SeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlSep1SeafoodData copyWith({int? id}) => AcnlSep1SeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSep1SeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSep1SeafoodData && other.id == this.id);
}

class AcnlSep1SeafoodCompanion extends UpdateCompanion<AcnlSep1SeafoodData> {
  final Value<int?> id;
  const AcnlSep1SeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlSep1SeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlSep1SeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlSep1SeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlSep1SeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSep1SeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlSep1Seafood extends Table
    with TableInfo<AcnlSep1Seafood, AcnlSep1SeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSep1Seafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_sep1_seafood';
  @override
  String get actualTableName => 'acnl_sep1_seafood';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnlSep1SeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSep1SeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSep1SeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSep1Seafood createAlias(String alias) {
    return AcnlSep1Seafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlSep2SeafoodData extends DataClass
    implements Insertable<AcnlSep2SeafoodData> {
  final int? id;
  AcnlSep2SeafoodData({this.id});
  factory AcnlSep2SeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlSep2SeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlSep2SeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlSep2SeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlSep2SeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlSep2SeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlSep2SeafoodData copyWith({int? id}) => AcnlSep2SeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlSep2SeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlSep2SeafoodData && other.id == this.id);
}

class AcnlSep2SeafoodCompanion extends UpdateCompanion<AcnlSep2SeafoodData> {
  final Value<int?> id;
  const AcnlSep2SeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlSep2SeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlSep2SeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlSep2SeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlSep2SeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlSep2SeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlSep2Seafood extends Table
    with TableInfo<AcnlSep2Seafood, AcnlSep2SeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlSep2Seafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_sep2_seafood';
  @override
  String get actualTableName => 'acnl_sep2_seafood';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnlSep2SeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlSep2SeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlSep2SeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlSep2Seafood createAlias(String alias) {
    return AcnlSep2Seafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlOctSeafoodData extends DataClass
    implements Insertable<AcnlOctSeafoodData> {
  final int? id;
  AcnlOctSeafoodData({this.id});
  factory AcnlOctSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlOctSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlOctSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlOctSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlOctSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlOctSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlOctSeafoodData copyWith({int? id}) => AcnlOctSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlOctSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlOctSeafoodData && other.id == this.id);
}

class AcnlOctSeafoodCompanion extends UpdateCompanion<AcnlOctSeafoodData> {
  final Value<int?> id;
  const AcnlOctSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlOctSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlOctSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlOctSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlOctSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlOctSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlOctSeafood extends Table
    with TableInfo<AcnlOctSeafood, AcnlOctSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlOctSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_oct_seafood';
  @override
  String get actualTableName => 'acnl_oct_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlOctSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlOctSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlOctSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlOctSeafood createAlias(String alias) {
    return AcnlOctSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlNovSeafoodData extends DataClass
    implements Insertable<AcnlNovSeafoodData> {
  final int? id;
  AcnlNovSeafoodData({this.id});
  factory AcnlNovSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlNovSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlNovSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlNovSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlNovSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlNovSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlNovSeafoodData copyWith({int? id}) => AcnlNovSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlNovSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlNovSeafoodData && other.id == this.id);
}

class AcnlNovSeafoodCompanion extends UpdateCompanion<AcnlNovSeafoodData> {
  final Value<int?> id;
  const AcnlNovSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlNovSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlNovSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlNovSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlNovSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlNovSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlNovSeafood extends Table
    with TableInfo<AcnlNovSeafood, AcnlNovSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlNovSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_nov_seafood';
  @override
  String get actualTableName => 'acnl_nov_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlNovSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlNovSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlNovSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlNovSeafood createAlias(String alias) {
    return AcnlNovSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlDecSeafoodData extends DataClass
    implements Insertable<AcnlDecSeafoodData> {
  final int? id;
  AcnlDecSeafoodData({this.id});
  factory AcnlDecSeafoodData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlDecSeafoodData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnlDecSeafoodCompanion toCompanion(bool nullToAbsent) {
    return AcnlDecSeafoodCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnlDecSeafoodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlDecSeafoodData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnlDecSeafoodData copyWith({int? id}) => AcnlDecSeafoodData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlDecSeafoodData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlDecSeafoodData && other.id == this.id);
}

class AcnlDecSeafoodCompanion extends UpdateCompanion<AcnlDecSeafoodData> {
  final Value<int?> id;
  const AcnlDecSeafoodCompanion({
    this.id = const Value.absent(),
  });
  AcnlDecSeafoodCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnlDecSeafoodData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnlDecSeafoodCompanion copyWith({Value<int?>? id}) {
    return AcnlDecSeafoodCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlDecSeafoodCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnlDecSeafood extends Table
    with TableInfo<AcnlDecSeafood, AcnlDecSeafoodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlDecSeafood(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnl_dec_seafood';
  @override
  String get actualTableName => 'acnl_dec_seafood';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlDecSeafoodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlDecSeafoodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlDecSeafoodData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlDecSeafood createAlias(String alias) {
    return AcnlDecSeafood(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcTableData extends DataClass implements Insertable<AcgcTableData> {
  final String? table;
  AcgcTableData({this.table});
  factory AcgcTableData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcTableData(
      table: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Table']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || table != null) {
      map['Table'] = Variable<String?>(table);
    }
    return map;
  }

  AcgcTableCompanion toCompanion(bool nullToAbsent) {
    return AcgcTableCompanion(
      table:
          table == null && nullToAbsent ? const Value.absent() : Value(table),
    );
  }

  factory AcgcTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcTableData(
      table: serializer.fromJson<String?>(json['Table']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Table': serializer.toJson<String?>(table),
    };
  }

  AcgcTableData copyWith({String? table}) => AcgcTableData(
        table: table ?? this.table,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcTableData(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => table.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcTableData && other.table == this.table);
}

class AcgcTableCompanion extends UpdateCompanion<AcgcTableData> {
  final Value<String?> table;
  const AcgcTableCompanion({
    this.table = const Value.absent(),
  });
  AcgcTableCompanion.insert({
    this.table = const Value.absent(),
  });
  static Insertable<AcgcTableData> custom({
    Expression<String?>? table,
  }) {
    return RawValuesInsertable({
      if (table != null) 'Table': table,
    });
  }

  AcgcTableCompanion copyWith({Value<String?>? table}) {
    return AcgcTableCompanion(
      table: table ?? this.table,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (table.present) {
      map['Table'] = Variable<String?>(table.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcTableCompanion(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }
}

class AcgcTable extends Table with TableInfo<AcgcTable, AcgcTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcTable(this.attachedDatabase, [this._alias]);
  final VerificationMeta _tableMeta = const VerificationMeta('table');
  late final GeneratedColumn<String?> table = GeneratedColumn<String?>(
      'Table', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [table];
  @override
  String get aliasedName => _alias ?? 'acgc_table';
  @override
  String get actualTableName => 'acgc_table';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Table')) {
      context.handle(
          _tableMeta, table.isAcceptableOrUnknown(data['Table']!, _tableMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcTableData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcTable createAlias(String alias) {
    return AcgcTable(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcwwTableData extends DataClass implements Insertable<AcwwTableData> {
  final String? table;
  AcwwTableData({this.table});
  factory AcwwTableData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcwwTableData(
      table: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Table']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || table != null) {
      map['Table'] = Variable<String?>(table);
    }
    return map;
  }

  AcwwTableCompanion toCompanion(bool nullToAbsent) {
    return AcwwTableCompanion(
      table:
          table == null && nullToAbsent ? const Value.absent() : Value(table),
    );
  }

  factory AcwwTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcwwTableData(
      table: serializer.fromJson<String?>(json['Table']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Table': serializer.toJson<String?>(table),
    };
  }

  AcwwTableData copyWith({String? table}) => AcwwTableData(
        table: table ?? this.table,
      );
  @override
  String toString() {
    return (StringBuffer('AcwwTableData(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => table.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcwwTableData && other.table == this.table);
}

class AcwwTableCompanion extends UpdateCompanion<AcwwTableData> {
  final Value<String?> table;
  const AcwwTableCompanion({
    this.table = const Value.absent(),
  });
  AcwwTableCompanion.insert({
    this.table = const Value.absent(),
  });
  static Insertable<AcwwTableData> custom({
    Expression<String?>? table,
  }) {
    return RawValuesInsertable({
      if (table != null) 'Table': table,
    });
  }

  AcwwTableCompanion copyWith({Value<String?>? table}) {
    return AcwwTableCompanion(
      table: table ?? this.table,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (table.present) {
      map['Table'] = Variable<String?>(table.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcwwTableCompanion(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }
}

class AcwwTable extends Table with TableInfo<AcwwTable, AcwwTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcwwTable(this.attachedDatabase, [this._alias]);
  final VerificationMeta _tableMeta = const VerificationMeta('table');
  late final GeneratedColumn<String?> table = GeneratedColumn<String?>(
      'Table', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [table];
  @override
  String get aliasedName => _alias ?? 'acww_table';
  @override
  String get actualTableName => 'acww_table';
  @override
  VerificationContext validateIntegrity(Insertable<AcwwTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Table')) {
      context.handle(
          _tableMeta, table.isAcceptableOrUnknown(data['Table']!, _tableMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcwwTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcwwTableData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcwwTable createAlias(String alias) {
    return AcwwTable(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AccfTableData extends DataClass implements Insertable<AccfTableData> {
  final String? table;
  AccfTableData({this.table});
  factory AccfTableData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AccfTableData(
      table: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Table']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || table != null) {
      map['Table'] = Variable<String?>(table);
    }
    return map;
  }

  AccfTableCompanion toCompanion(bool nullToAbsent) {
    return AccfTableCompanion(
      table:
          table == null && nullToAbsent ? const Value.absent() : Value(table),
    );
  }

  factory AccfTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AccfTableData(
      table: serializer.fromJson<String?>(json['Table']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Table': serializer.toJson<String?>(table),
    };
  }

  AccfTableData copyWith({String? table}) => AccfTableData(
        table: table ?? this.table,
      );
  @override
  String toString() {
    return (StringBuffer('AccfTableData(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => table.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AccfTableData && other.table == this.table);
}

class AccfTableCompanion extends UpdateCompanion<AccfTableData> {
  final Value<String?> table;
  const AccfTableCompanion({
    this.table = const Value.absent(),
  });
  AccfTableCompanion.insert({
    this.table = const Value.absent(),
  });
  static Insertable<AccfTableData> custom({
    Expression<String?>? table,
  }) {
    return RawValuesInsertable({
      if (table != null) 'Table': table,
    });
  }

  AccfTableCompanion copyWith({Value<String?>? table}) {
    return AccfTableCompanion(
      table: table ?? this.table,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (table.present) {
      map['Table'] = Variable<String?>(table.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccfTableCompanion(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }
}

class AccfTable extends Table with TableInfo<AccfTable, AccfTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AccfTable(this.attachedDatabase, [this._alias]);
  final VerificationMeta _tableMeta = const VerificationMeta('table');
  late final GeneratedColumn<String?> table = GeneratedColumn<String?>(
      'Table', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [table];
  @override
  String get aliasedName => _alias ?? 'accf_table';
  @override
  String get actualTableName => 'accf_table';
  @override
  VerificationContext validateIntegrity(Insertable<AccfTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Table')) {
      context.handle(
          _tableMeta, table.isAcceptableOrUnknown(data['Table']!, _tableMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AccfTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AccfTableData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AccfTable createAlias(String alias) {
    return AccfTable(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnlTableData extends DataClass implements Insertable<AcnlTableData> {
  final String? table;
  AcnlTableData({this.table});
  factory AcnlTableData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnlTableData(
      table: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Table']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || table != null) {
      map['Table'] = Variable<String?>(table);
    }
    return map;
  }

  AcnlTableCompanion toCompanion(bool nullToAbsent) {
    return AcnlTableCompanion(
      table:
          table == null && nullToAbsent ? const Value.absent() : Value(table),
    );
  }

  factory AcnlTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnlTableData(
      table: serializer.fromJson<String?>(json['Table']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Table': serializer.toJson<String?>(table),
    };
  }

  AcnlTableData copyWith({String? table}) => AcnlTableData(
        table: table ?? this.table,
      );
  @override
  String toString() {
    return (StringBuffer('AcnlTableData(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => table.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnlTableData && other.table == this.table);
}

class AcnlTableCompanion extends UpdateCompanion<AcnlTableData> {
  final Value<String?> table;
  const AcnlTableCompanion({
    this.table = const Value.absent(),
  });
  AcnlTableCompanion.insert({
    this.table = const Value.absent(),
  });
  static Insertable<AcnlTableData> custom({
    Expression<String?>? table,
  }) {
    return RawValuesInsertable({
      if (table != null) 'Table': table,
    });
  }

  AcnlTableCompanion copyWith({Value<String?>? table}) {
    return AcnlTableCompanion(
      table: table ?? this.table,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (table.present) {
      map['Table'] = Variable<String?>(table.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnlTableCompanion(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }
}

class AcnlTable extends Table with TableInfo<AcnlTable, AcnlTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnlTable(this.attachedDatabase, [this._alias]);
  final VerificationMeta _tableMeta = const VerificationMeta('table');
  late final GeneratedColumn<String?> table = GeneratedColumn<String?>(
      'Table', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [table];
  @override
  String get aliasedName => _alias ?? 'acnl_table';
  @override
  String get actualTableName => 'acnl_table';
  @override
  VerificationContext validateIntegrity(Insertable<AcnlTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Table')) {
      context.handle(
          _tableMeta, table.isAcceptableOrUnknown(data['Table']!, _tableMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnlTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnlTableData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnlTable createAlias(String alias) {
    return AcnlTable(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhTableData extends DataClass implements Insertable<AcnhTableData> {
  final String? table;
  AcnhTableData({this.table});
  factory AcnhTableData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhTableData(
      table: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Table']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || table != null) {
      map['Table'] = Variable<String?>(table);
    }
    return map;
  }

  AcnhTableCompanion toCompanion(bool nullToAbsent) {
    return AcnhTableCompanion(
      table:
          table == null && nullToAbsent ? const Value.absent() : Value(table),
    );
  }

  factory AcnhTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhTableData(
      table: serializer.fromJson<String?>(json['Table']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Table': serializer.toJson<String?>(table),
    };
  }

  AcnhTableData copyWith({String? table}) => AcnhTableData(
        table: table ?? this.table,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhTableData(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => table.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhTableData && other.table == this.table);
}

class AcnhTableCompanion extends UpdateCompanion<AcnhTableData> {
  final Value<String?> table;
  const AcnhTableCompanion({
    this.table = const Value.absent(),
  });
  AcnhTableCompanion.insert({
    this.table = const Value.absent(),
  });
  static Insertable<AcnhTableData> custom({
    Expression<String?>? table,
  }) {
    return RawValuesInsertable({
      if (table != null) 'Table': table,
    });
  }

  AcnhTableCompanion copyWith({Value<String?>? table}) {
    return AcnhTableCompanion(
      table: table ?? this.table,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (table.present) {
      map['Table'] = Variable<String?>(table.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhTableCompanion(')
          ..write('table: $table')
          ..write(')'))
        .toString();
  }
}

class AcnhTable extends Table with TableInfo<AcnhTable, AcnhTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhTable(this.attachedDatabase, [this._alias]);
  final VerificationMeta _tableMeta = const VerificationMeta('table');
  late final GeneratedColumn<String?> table = GeneratedColumn<String?>(
      'Table', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [table];
  @override
  String get aliasedName => _alias ?? 'acnh_table';
  @override
  String get actualTableName => 'acnh_table';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Table')) {
      context.handle(
          _tableMeta, table.isAcceptableOrUnknown(data['Table']!, _tableMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhTableData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhTable createAlias(String alias) {
    return AcnhTable(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAccessoryData extends DataClass
    implements Insertable<AcnhAccessoryData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhAccessoryData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhAccessoryData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAccessoryData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhAccessoryCompanion toCompanion(bool nullToAbsent) {
    return AcnhAccessoryCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhAccessoryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAccessoryData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhAccessoryData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhAccessoryData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAccessoryData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAccessoryData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhAccessoryCompanion extends UpdateCompanion<AcnhAccessoryData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhAccessoryCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhAccessoryCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhAccessoryData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhAccessoryCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhAccessoryCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAccessoryCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhAccessory extends Table
    with TableInfo<AcnhAccessory, AcnhAccessoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAccessory(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_accessory';
  @override
  String get actualTableName => 'acnh_accessory';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhAccessoryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAccessoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAccessoryData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAccessory createAlias(String alias) {
    return AcnhAccessory(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhArtData extends DataClass implements Insertable<AcnhArtData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? pReal;
  final String? fake;
  final String? from;
  final String? actualTitle;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhArtData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.pReal,
      this.fake,
      this.from,
      this.actualTitle,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhArtData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhArtData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      pReal: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}PReal']),
      fake: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Fake']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      actualTitle: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Actual Title']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || pReal != null) {
      map['PReal'] = Variable<String?>(pReal);
    }
    if (!nullToAbsent || fake != null) {
      map['Fake'] = Variable<String?>(fake);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || actualTitle != null) {
      map['Actual Title'] = Variable<String?>(actualTitle);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhArtCompanion toCompanion(bool nullToAbsent) {
    return AcnhArtCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      pReal:
          pReal == null && nullToAbsent ? const Value.absent() : Value(pReal),
      fake: fake == null && nullToAbsent ? const Value.absent() : Value(fake),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      actualTitle: actualTitle == null && nullToAbsent
          ? const Value.absent()
          : Value(actualTitle),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhArtData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhArtData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      pReal: serializer.fromJson<String?>(json['PReal']),
      fake: serializer.fromJson<String?>(json['Fake']),
      from: serializer.fromJson<String?>(json['From']),
      actualTitle: serializer.fromJson<String?>(json['Actual Title']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'PReal': serializer.toJson<String?>(pReal),
      'Fake': serializer.toJson<String?>(fake),
      'From': serializer.toJson<String?>(from),
      'Actual Title': serializer.toJson<String?>(actualTitle),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhArtData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? pReal,
          String? fake,
          String? from,
          String? actualTitle,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhArtData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        pReal: pReal ?? this.pReal,
        fake: fake ?? this.fake,
        from: from ?? this.from,
        actualTitle: actualTitle ?? this.actualTitle,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhArtData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('pReal: $pReal, ')
          ..write('fake: $fake, ')
          ..write('from: $from, ')
          ..write('actualTitle: $actualTitle, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, price, pReal,
      fake, from, actualTitle, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhArtData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.pReal == this.pReal &&
          other.fake == this.fake &&
          other.from == this.from &&
          other.actualTitle == this.actualTitle &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhArtCompanion extends UpdateCompanion<AcnhArtData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> pReal;
  final Value<String?> fake;
  final Value<String?> from;
  final Value<String?> actualTitle;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhArtCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.pReal = const Value.absent(),
    this.fake = const Value.absent(),
    this.from = const Value.absent(),
    this.actualTitle = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhArtCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.pReal = const Value.absent(),
    this.fake = const Value.absent(),
    this.from = const Value.absent(),
    this.actualTitle = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhArtData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? pReal,
    Expression<String?>? fake,
    Expression<String?>? from,
    Expression<String?>? actualTitle,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (pReal != null) 'PReal': pReal,
      if (fake != null) 'Fake': fake,
      if (from != null) 'From': from,
      if (actualTitle != null) 'Actual Title': actualTitle,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhArtCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? pReal,
      Value<String?>? fake,
      Value<String?>? from,
      Value<String?>? actualTitle,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhArtCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      pReal: pReal ?? this.pReal,
      fake: fake ?? this.fake,
      from: from ?? this.from,
      actualTitle: actualTitle ?? this.actualTitle,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (pReal.present) {
      map['PReal'] = Variable<String?>(pReal.value);
    }
    if (fake.present) {
      map['Fake'] = Variable<String?>(fake.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (actualTitle.present) {
      map['Actual Title'] = Variable<String?>(actualTitle.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhArtCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('pReal: $pReal, ')
          ..write('fake: $fake, ')
          ..write('from: $from, ')
          ..write('actualTitle: $actualTitle, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhArt extends Table with TableInfo<AcnhArt, AcnhArtData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhArt(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _pRealMeta = const VerificationMeta('pReal');
  late final GeneratedColumn<String?> pReal = GeneratedColumn<String?>(
      'PReal', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fakeMeta = const VerificationMeta('fake');
  late final GeneratedColumn<String?> fake = GeneratedColumn<String?>(
      'Fake', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _actualTitleMeta =
      const VerificationMeta('actualTitle');
  late final GeneratedColumn<String?> actualTitle = GeneratedColumn<String?>(
      'Actual Title', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        index,
        selected,
        name,
        status,
        price,
        pReal,
        fake,
        from,
        actualTitle,
        concept1,
        concept2,
        series
      ];
  @override
  String get aliasedName => _alias ?? 'acnh_art';
  @override
  String get actualTableName => 'acnh_art';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhArtData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('PReal')) {
      context.handle(
          _pRealMeta, pReal.isAcceptableOrUnknown(data['PReal']!, _pRealMeta));
    }
    if (data.containsKey('Fake')) {
      context.handle(
          _fakeMeta, fake.isAcceptableOrUnknown(data['Fake']!, _fakeMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Actual Title')) {
      context.handle(
          _actualTitleMeta,
          actualTitle.isAcceptableOrUnknown(
              data['Actual Title']!, _actualTitleMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhArtData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhArtData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhArt createAlias(String alias) {
    return AcnhArt(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhBagData extends DataClass implements Insertable<AcnhBagData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhBagData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhBagData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhBagData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhBagCompanion toCompanion(bool nullToAbsent) {
    return AcnhBagCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhBagData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhBagData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhBagData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhBagData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhBagData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhBagData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhBagCompanion extends UpdateCompanion<AcnhBagData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhBagCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhBagCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhBagData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhBagCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhBagCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhBagCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhBag extends Table with TableInfo<AcnhBag, AcnhBagData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhBag(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_bag';
  @override
  String get actualTableName => 'acnh_bag';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhBagData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhBagData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhBagData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhBag createAlias(String alias) {
    return AcnhBag(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhBottomData extends DataClass implements Insertable<AcnhBottomData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhBottomData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhBottomData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhBottomData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhBottomCompanion toCompanion(bool nullToAbsent) {
    return AcnhBottomCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhBottomData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhBottomData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhBottomData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhBottomData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhBottomData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhBottomData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhBottomCompanion extends UpdateCompanion<AcnhBottomData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhBottomCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhBottomCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhBottomData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhBottomCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhBottomCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhBottomCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhBottom extends Table with TableInfo<AcnhBottom, AcnhBottomData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhBottom(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_bottom';
  @override
  String get actualTableName => 'acnh_bottom';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhBottomData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhBottomData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhBottomData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhBottom createAlias(String alias) {
    return AcnhBottom(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhDres extends DataClass implements Insertable<AcnhDres> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhDres(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhDres.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhDres(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhDressCompanion toCompanion(bool nullToAbsent) {
    return AcnhDressCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhDres.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhDres(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhDres copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhDres(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhDres(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhDres &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhDressCompanion extends UpdateCompanion<AcnhDres> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhDressCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhDressCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhDres> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhDressCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhDressCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhDressCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhDress extends Table with TableInfo<AcnhDress, AcnhDres> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhDress(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_dress';
  @override
  String get actualTableName => 'acnh_dress';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhDres> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhDres map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhDres.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhDress createAlias(String alias) {
    return AcnhDress(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhFencingData extends DataClass implements Insertable<AcnhFencingData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? from;
  AcnhFencingData(
      {this.index, this.selected, this.name, this.price, this.from});
  factory AcnhFencingData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhFencingData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhFencingCompanion toCompanion(bool nullToAbsent) {
    return AcnhFencingCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhFencingData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhFencingData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhFencingData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? from}) =>
      AcnhFencingData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhFencingData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, price, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhFencingData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.from == this.from);
}

class AcnhFencingCompanion extends UpdateCompanion<AcnhFencingData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> from;
  const AcnhFencingCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhFencingCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhFencingData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
    });
  }

  AcnhFencingCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? from}) {
    return AcnhFencingCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhFencingCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhFencing extends Table with TableInfo<AcnhFencing, AcnhFencingData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhFencing(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, price, from];
  @override
  String get aliasedName => _alias ?? 'acnh_fencing';
  @override
  String get actualTableName => 'acnh_fencing';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhFencingData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhFencingData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhFencingData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhFencing createAlias(String alias) {
    return AcnhFencing(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhFishData extends DataClass implements Insertable<AcnhFishData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? from;
  final String? shadow;
  final String? times;
  AcnhFishData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.from,
      this.shadow,
      this.times});
  factory AcnhFishData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhFishData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      shadow: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Shadow']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || shadow != null) {
      map['Shadow'] = Variable<String?>(shadow);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcnhFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhFishCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      shadow:
          shadow == null && nullToAbsent ? const Value.absent() : Value(shadow),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcnhFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhFishData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      shadow: serializer.fromJson<String?>(json['Shadow']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Shadow': serializer.toJson<String?>(shadow),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcnhFishData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? from,
          String? shadow,
          String? times}) =>
      AcnhFishData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        from: from ?? this.from,
        shadow: shadow ?? this.shadow,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhFishData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('shadow: $shadow, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, from, shadow, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhFishData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.from == this.from &&
          other.shadow == this.shadow &&
          other.times == this.times);
}

class AcnhFishCompanion extends UpdateCompanion<AcnhFishData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> shadow;
  final Value<String?> times;
  const AcnhFishCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.shadow = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcnhFishCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.shadow = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcnhFishData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? shadow,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (shadow != null) 'Shadow': shadow,
      if (times != null) 'Times': times,
    });
  }

  AcnhFishCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? shadow,
      Value<String?>? times}) {
    return AcnhFishCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      from: from ?? this.from,
      shadow: shadow ?? this.shadow,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (shadow.present) {
      map['Shadow'] = Variable<String?>(shadow.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhFishCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('shadow: $shadow, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcnhFish extends Table with TableInfo<AcnhFish, AcnhFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _shadowMeta = const VerificationMeta('shadow');
  late final GeneratedColumn<String?> shadow = GeneratedColumn<String?>(
      'Shadow', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, from, shadow, times];
  @override
  String get aliasedName => _alias ?? 'acnh_fish';
  @override
  String get actualTableName => 'acnh_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Shadow')) {
      context.handle(_shadowMeta,
          shadow.isAcceptableOrUnknown(data['Shadow']!, _shadowMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhFish createAlias(String alias) {
    return AcnhFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJanFishData extends DataClass implements Insertable<AcnhJanFishData> {
  final int? id;
  AcnhJanFishData({this.id});
  factory AcnhJanFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJanFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJanFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhJanFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJanFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJanFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJanFishData copyWith({int? id}) => AcnhJanFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJanFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJanFishData && other.id == this.id);
}

class AcnhJanFishCompanion extends UpdateCompanion<AcnhJanFishData> {
  final Value<int?> id;
  const AcnhJanFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhJanFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJanFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJanFishCompanion copyWith({Value<int?>? id}) {
    return AcnhJanFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJanFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJanFish extends Table with TableInfo<AcnhJanFish, AcnhJanFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJanFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jan_fish';
  @override
  String get actualTableName => 'acnh_jan_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhJanFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJanFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJanFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJanFish createAlias(String alias) {
    return AcnhJanFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhFebFishData extends DataClass implements Insertable<AcnhFebFishData> {
  final int? id;
  AcnhFebFishData({this.id});
  factory AcnhFebFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhFebFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhFebFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhFebFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhFebFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhFebFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhFebFishData copyWith({int? id}) => AcnhFebFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhFebFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhFebFishData && other.id == this.id);
}

class AcnhFebFishCompanion extends UpdateCompanion<AcnhFebFishData> {
  final Value<int?> id;
  const AcnhFebFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhFebFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhFebFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhFebFishCompanion copyWith({Value<int?>? id}) {
    return AcnhFebFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhFebFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhFebFish extends Table with TableInfo<AcnhFebFish, AcnhFebFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhFebFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_feb_fish';
  @override
  String get actualTableName => 'acnh_feb_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhFebFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhFebFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhFebFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhFebFish createAlias(String alias) {
    return AcnhFebFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhMarFishData extends DataClass implements Insertable<AcnhMarFishData> {
  final int? id;
  AcnhMarFishData({this.id});
  factory AcnhMarFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhMarFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhMarFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhMarFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhMarFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhMarFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhMarFishData copyWith({int? id}) => AcnhMarFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhMarFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhMarFishData && other.id == this.id);
}

class AcnhMarFishCompanion extends UpdateCompanion<AcnhMarFishData> {
  final Value<int?> id;
  const AcnhMarFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhMarFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhMarFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhMarFishCompanion copyWith({Value<int?>? id}) {
    return AcnhMarFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhMarFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhMarFish extends Table with TableInfo<AcnhMarFish, AcnhMarFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhMarFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_mar_fish';
  @override
  String get actualTableName => 'acnh_mar_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhMarFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhMarFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhMarFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhMarFish createAlias(String alias) {
    return AcnhMarFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAprFishData extends DataClass implements Insertable<AcnhAprFishData> {
  final int? id;
  AcnhAprFishData({this.id});
  factory AcnhAprFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAprFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAprFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhAprFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAprFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAprFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAprFishData copyWith({int? id}) => AcnhAprFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAprFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAprFishData && other.id == this.id);
}

class AcnhAprFishCompanion extends UpdateCompanion<AcnhAprFishData> {
  final Value<int?> id;
  const AcnhAprFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhAprFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAprFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAprFishCompanion copyWith({Value<int?>? id}) {
    return AcnhAprFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAprFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAprFish extends Table with TableInfo<AcnhAprFish, AcnhAprFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAprFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_apr_fish';
  @override
  String get actualTableName => 'acnh_apr_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhAprFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAprFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAprFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAprFish createAlias(String alias) {
    return AcnhAprFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhMayFishData extends DataClass implements Insertable<AcnhMayFishData> {
  final int? id;
  AcnhMayFishData({this.id});
  factory AcnhMayFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhMayFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhMayFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhMayFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhMayFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhMayFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhMayFishData copyWith({int? id}) => AcnhMayFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhMayFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhMayFishData && other.id == this.id);
}

class AcnhMayFishCompanion extends UpdateCompanion<AcnhMayFishData> {
  final Value<int?> id;
  const AcnhMayFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhMayFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhMayFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhMayFishCompanion copyWith({Value<int?>? id}) {
    return AcnhMayFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhMayFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhMayFish extends Table with TableInfo<AcnhMayFish, AcnhMayFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhMayFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_may_fish';
  @override
  String get actualTableName => 'acnh_may_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhMayFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhMayFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhMayFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhMayFish createAlias(String alias) {
    return AcnhMayFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJunFishData extends DataClass implements Insertable<AcnhJunFishData> {
  final int? id;
  AcnhJunFishData({this.id});
  factory AcnhJunFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJunFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJunFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhJunFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJunFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJunFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJunFishData copyWith({int? id}) => AcnhJunFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJunFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJunFishData && other.id == this.id);
}

class AcnhJunFishCompanion extends UpdateCompanion<AcnhJunFishData> {
  final Value<int?> id;
  const AcnhJunFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhJunFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJunFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJunFishCompanion copyWith({Value<int?>? id}) {
    return AcnhJunFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJunFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJunFish extends Table with TableInfo<AcnhJunFish, AcnhJunFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJunFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jun_fish';
  @override
  String get actualTableName => 'acnh_jun_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhJunFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJunFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJunFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJunFish createAlias(String alias) {
    return AcnhJunFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJulFishData extends DataClass implements Insertable<AcnhJulFishData> {
  final int? id;
  AcnhJulFishData({this.id});
  factory AcnhJulFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJulFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJulFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhJulFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJulFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJulFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJulFishData copyWith({int? id}) => AcnhJulFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJulFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJulFishData && other.id == this.id);
}

class AcnhJulFishCompanion extends UpdateCompanion<AcnhJulFishData> {
  final Value<int?> id;
  const AcnhJulFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhJulFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJulFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJulFishCompanion copyWith({Value<int?>? id}) {
    return AcnhJulFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJulFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJulFish extends Table with TableInfo<AcnhJulFish, AcnhJulFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJulFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jul_fish';
  @override
  String get actualTableName => 'acnh_jul_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhJulFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJulFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJulFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJulFish createAlias(String alias) {
    return AcnhJulFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAug1FishData extends DataClass
    implements Insertable<AcnhAug1FishData> {
  final int? id;
  AcnhAug1FishData({this.id});
  factory AcnhAug1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAug1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAug1FishCompanion toCompanion(bool nullToAbsent) {
    return AcnhAug1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAug1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAug1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAug1FishData copyWith({int? id}) => AcnhAug1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAug1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAug1FishData && other.id == this.id);
}

class AcnhAug1FishCompanion extends UpdateCompanion<AcnhAug1FishData> {
  final Value<int?> id;
  const AcnhAug1FishCompanion({
    this.id = const Value.absent(),
  });
  AcnhAug1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAug1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAug1FishCompanion copyWith({Value<int?>? id}) {
    return AcnhAug1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAug1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAug1Fish extends Table
    with TableInfo<AcnhAug1Fish, AcnhAug1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAug1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_aug1_fish';
  @override
  String get actualTableName => 'acnh_aug1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhAug1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAug1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAug1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAug1Fish createAlias(String alias) {
    return AcnhAug1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAug2FishData extends DataClass
    implements Insertable<AcnhAug2FishData> {
  final int? id;
  AcnhAug2FishData({this.id});
  factory AcnhAug2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAug2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAug2FishCompanion toCompanion(bool nullToAbsent) {
    return AcnhAug2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAug2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAug2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAug2FishData copyWith({int? id}) => AcnhAug2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAug2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAug2FishData && other.id == this.id);
}

class AcnhAug2FishCompanion extends UpdateCompanion<AcnhAug2FishData> {
  final Value<int?> id;
  const AcnhAug2FishCompanion({
    this.id = const Value.absent(),
  });
  AcnhAug2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAug2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAug2FishCompanion copyWith({Value<int?>? id}) {
    return AcnhAug2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAug2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAug2Fish extends Table
    with TableInfo<AcnhAug2Fish, AcnhAug2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAug2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_aug2_fish';
  @override
  String get actualTableName => 'acnh_aug2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhAug2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAug2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAug2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAug2Fish createAlias(String alias) {
    return AcnhAug2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSep1FishData extends DataClass
    implements Insertable<AcnhSep1FishData> {
  final int? id;
  AcnhSep1FishData({this.id});
  factory AcnhSep1FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSep1FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhSep1FishCompanion toCompanion(bool nullToAbsent) {
    return AcnhSep1FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhSep1FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSep1FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhSep1FishData copyWith({int? id}) => AcnhSep1FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSep1FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSep1FishData && other.id == this.id);
}

class AcnhSep1FishCompanion extends UpdateCompanion<AcnhSep1FishData> {
  final Value<int?> id;
  const AcnhSep1FishCompanion({
    this.id = const Value.absent(),
  });
  AcnhSep1FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhSep1FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhSep1FishCompanion copyWith({Value<int?>? id}) {
    return AcnhSep1FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSep1FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhSep1Fish extends Table
    with TableInfo<AcnhSep1Fish, AcnhSep1FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSep1Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_sep1_fish';
  @override
  String get actualTableName => 'acnh_sep1_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhSep1FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSep1FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhSep1FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSep1Fish createAlias(String alias) {
    return AcnhSep1Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSep2FishData extends DataClass
    implements Insertable<AcnhSep2FishData> {
  final int? id;
  AcnhSep2FishData({this.id});
  factory AcnhSep2FishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSep2FishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhSep2FishCompanion toCompanion(bool nullToAbsent) {
    return AcnhSep2FishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhSep2FishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSep2FishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhSep2FishData copyWith({int? id}) => AcnhSep2FishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSep2FishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSep2FishData && other.id == this.id);
}

class AcnhSep2FishCompanion extends UpdateCompanion<AcnhSep2FishData> {
  final Value<int?> id;
  const AcnhSep2FishCompanion({
    this.id = const Value.absent(),
  });
  AcnhSep2FishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhSep2FishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhSep2FishCompanion copyWith({Value<int?>? id}) {
    return AcnhSep2FishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSep2FishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhSep2Fish extends Table
    with TableInfo<AcnhSep2Fish, AcnhSep2FishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSep2Fish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_sep2_fish';
  @override
  String get actualTableName => 'acnh_sep2_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhSep2FishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSep2FishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhSep2FishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSep2Fish createAlias(String alias) {
    return AcnhSep2Fish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhOctFishData extends DataClass implements Insertable<AcnhOctFishData> {
  final int? id;
  AcnhOctFishData({this.id});
  factory AcnhOctFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhOctFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhOctFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhOctFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhOctFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhOctFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhOctFishData copyWith({int? id}) => AcnhOctFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhOctFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhOctFishData && other.id == this.id);
}

class AcnhOctFishCompanion extends UpdateCompanion<AcnhOctFishData> {
  final Value<int?> id;
  const AcnhOctFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhOctFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhOctFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhOctFishCompanion copyWith({Value<int?>? id}) {
    return AcnhOctFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhOctFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhOctFish extends Table with TableInfo<AcnhOctFish, AcnhOctFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhOctFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_oct_fish';
  @override
  String get actualTableName => 'acnh_oct_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhOctFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhOctFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhOctFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhOctFish createAlias(String alias) {
    return AcnhOctFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhNovFishData extends DataClass implements Insertable<AcnhNovFishData> {
  final int? id;
  AcnhNovFishData({this.id});
  factory AcnhNovFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhNovFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhNovFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhNovFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhNovFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhNovFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhNovFishData copyWith({int? id}) => AcnhNovFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhNovFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhNovFishData && other.id == this.id);
}

class AcnhNovFishCompanion extends UpdateCompanion<AcnhNovFishData> {
  final Value<int?> id;
  const AcnhNovFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhNovFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhNovFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhNovFishCompanion copyWith({Value<int?>? id}) {
    return AcnhNovFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhNovFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhNovFish extends Table with TableInfo<AcnhNovFish, AcnhNovFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhNovFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_nov_fish';
  @override
  String get actualTableName => 'acnh_nov_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhNovFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhNovFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhNovFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhNovFish createAlias(String alias) {
    return AcnhNovFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhDecFishData extends DataClass implements Insertable<AcnhDecFishData> {
  final int? id;
  AcnhDecFishData({this.id});
  factory AcnhDecFishData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhDecFishData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhDecFishCompanion toCompanion(bool nullToAbsent) {
    return AcnhDecFishCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhDecFishData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhDecFishData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhDecFishData copyWith({int? id}) => AcnhDecFishData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhDecFishData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhDecFishData && other.id == this.id);
}

class AcnhDecFishCompanion extends UpdateCompanion<AcnhDecFishData> {
  final Value<int?> id;
  const AcnhDecFishCompanion({
    this.id = const Value.absent(),
  });
  AcnhDecFishCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhDecFishData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhDecFishCompanion copyWith({Value<int?>? id}) {
    return AcnhDecFishCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhDecFishCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhDecFish extends Table with TableInfo<AcnhDecFish, AcnhDecFishData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhDecFish(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_dec_fish';
  @override
  String get actualTableName => 'acnh_dec_fish';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhDecFishData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhDecFishData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhDecFishData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhDecFish createAlias(String alias) {
    return AcnhDecFish(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhFlooringData extends DataClass
    implements Insertable<AcnhFlooringData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhFlooringData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhFlooringData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhFlooringData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhFlooringCompanion toCompanion(bool nullToAbsent) {
    return AcnhFlooringCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhFlooringData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhFlooringData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhFlooringData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhFlooringData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhFlooringData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhFlooringData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhFlooringCompanion extends UpdateCompanion<AcnhFlooringData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhFlooringCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhFlooringCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhFlooringData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhFlooringCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhFlooringCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhFlooringCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhFlooring extends Table
    with TableInfo<AcnhFlooring, AcnhFlooringData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhFlooring(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_flooring';
  @override
  String get actualTableName => 'acnh_flooring';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhFlooringData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhFlooringData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhFlooringData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhFlooring createAlias(String alias) {
    return AcnhFlooring(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhFossilData extends DataClass implements Insertable<AcnhFossilData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? from;
  AcnhFossilData({this.index, this.selected, this.name, this.price, this.from});
  factory AcnhFossilData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhFossilData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhFossilCompanion toCompanion(bool nullToAbsent) {
    return AcnhFossilCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhFossilData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhFossilData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhFossilData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? from}) =>
      AcnhFossilData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhFossilData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, price, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhFossilData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.from == this.from);
}

class AcnhFossilCompanion extends UpdateCompanion<AcnhFossilData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> from;
  const AcnhFossilCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhFossilCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhFossilData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
    });
  }

  AcnhFossilCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? from}) {
    return AcnhFossilCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhFossilCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhFossil extends Table with TableInfo<AcnhFossil, AcnhFossilData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhFossil(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, price, from];
  @override
  String get aliasedName => _alias ?? 'acnh_fossil';
  @override
  String get actualTableName => 'acnh_fossil';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhFossilData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhFossilData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhFossilData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhFossil createAlias(String alias) {
    return AcnhFossil(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhHeadwearData extends DataClass
    implements Insertable<AcnhHeadwearData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhHeadwearData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhHeadwearData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhHeadwearData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhHeadwearCompanion toCompanion(bool nullToAbsent) {
    return AcnhHeadwearCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhHeadwearData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhHeadwearData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhHeadwearData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhHeadwearData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhHeadwearData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhHeadwearData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhHeadwearCompanion extends UpdateCompanion<AcnhHeadwearData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhHeadwearCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhHeadwearCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhHeadwearData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhHeadwearCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhHeadwearCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhHeadwearCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhHeadwear extends Table
    with TableInfo<AcnhHeadwear, AcnhHeadwearData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhHeadwear(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_headwear';
  @override
  String get actualTableName => 'acnh_headwear';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhHeadwearData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhHeadwearData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhHeadwearData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhHeadwear createAlias(String alias) {
    return AcnhHeadwear(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhHousewareData extends DataClass
    implements Insertable<AcnhHousewareData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhHousewareData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhHousewareData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhHousewareData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhHousewareCompanion toCompanion(bool nullToAbsent) {
    return AcnhHousewareCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhHousewareData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhHousewareData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhHousewareData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhHousewareData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhHousewareData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhHousewareData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhHousewareCompanion extends UpdateCompanion<AcnhHousewareData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhHousewareCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhHousewareCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhHousewareData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhHousewareCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhHousewareCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhHousewareCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhHouseware extends Table
    with TableInfo<AcnhHouseware, AcnhHousewareData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhHouseware(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_houseware';
  @override
  String get actualTableName => 'acnh_houseware';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhHousewareData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhHousewareData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhHousewareData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhHouseware createAlias(String alias) {
    return AcnhHouseware(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhMiscData extends DataClass implements Insertable<AcnhMiscData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhMiscData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhMiscData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhMiscData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhMiscCompanion toCompanion(bool nullToAbsent) {
    return AcnhMiscCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhMiscData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhMiscData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhMiscData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhMiscData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhMiscData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhMiscData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhMiscCompanion extends UpdateCompanion<AcnhMiscData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhMiscCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhMiscCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhMiscData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhMiscCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhMiscCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhMiscCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhMisc extends Table with TableInfo<AcnhMisc, AcnhMiscData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhMisc(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_misc';
  @override
  String get actualTableName => 'acnh_misc';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhMiscData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhMiscData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhMiscData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhMisc createAlias(String alias) {
    return AcnhMisc(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhWallMountedData extends DataClass
    implements Insertable<AcnhWallMountedData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhWallMountedData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhWallMountedData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhWallMountedData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhWallMountedCompanion toCompanion(bool nullToAbsent) {
    return AcnhWallMountedCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhWallMountedData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhWallMountedData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhWallMountedData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhWallMountedData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhWallMountedData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhWallMountedData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhWallMountedCompanion extends UpdateCompanion<AcnhWallMountedData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhWallMountedCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhWallMountedCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhWallMountedData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhWallMountedCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhWallMountedCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhWallMountedCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhWallMounted extends Table
    with TableInfo<AcnhWallMounted, AcnhWallMountedData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhWallMounted(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_wall_mounted';
  @override
  String get actualTableName => 'acnh_wall_mounted';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhWallMountedData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhWallMountedData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhWallMountedData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhWallMounted createAlias(String alias) {
    return AcnhWallMounted(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhCeilingData extends DataClass implements Insertable<AcnhCeilingData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhCeilingData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhCeilingData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhCeilingData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhCeilingCompanion toCompanion(bool nullToAbsent) {
    return AcnhCeilingCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhCeilingData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhCeilingData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhCeilingData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhCeilingData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhCeilingData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhCeilingData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhCeilingCompanion extends UpdateCompanion<AcnhCeilingData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhCeilingCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhCeilingCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhCeilingData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhCeilingCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhCeilingCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhCeilingCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhCeiling extends Table with TableInfo<AcnhCeiling, AcnhCeilingData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhCeiling(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_ceiling';
  @override
  String get actualTableName => 'acnh_ceiling';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhCeilingData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhCeilingData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhCeilingData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhCeiling createAlias(String alias) {
    return AcnhCeiling(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhInteriorData extends DataClass
    implements Insertable<AcnhInteriorData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhInteriorData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhInteriorData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhInteriorData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhInteriorCompanion toCompanion(bool nullToAbsent) {
    return AcnhInteriorCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhInteriorData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhInteriorData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhInteriorData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhInteriorData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhInteriorData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhInteriorData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhInteriorCompanion extends UpdateCompanion<AcnhInteriorData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhInteriorCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhInteriorCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhInteriorData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhInteriorCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhInteriorCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhInteriorCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhInterior extends Table
    with TableInfo<AcnhInterior, AcnhInteriorData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhInterior(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_interior';
  @override
  String get actualTableName => 'acnh_interior';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhInteriorData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhInteriorData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhInteriorData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhInterior createAlias(String alias) {
    return AcnhInterior(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhGyroidData extends DataClass implements Insertable<AcnhGyroidData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  AcnhGyroidData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from});
  factory AcnhGyroidData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhGyroidData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhGyroidCompanion toCompanion(bool nullToAbsent) {
    return AcnhGyroidCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhGyroidData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhGyroidData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhGyroidData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from}) =>
      AcnhGyroidData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhGyroidData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, price, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhGyroidData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from);
}

class AcnhGyroidCompanion extends UpdateCompanion<AcnhGyroidData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  const AcnhGyroidCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhGyroidCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhGyroidData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
    });
  }

  AcnhGyroidCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from}) {
    return AcnhGyroidCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhGyroidCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhGyroid extends Table with TableInfo<AcnhGyroid, AcnhGyroidData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhGyroid(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from];
  @override
  String get aliasedName => _alias ?? 'acnh_gyroid';
  @override
  String get actualTableName => 'acnh_gyroid';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhGyroidData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhGyroidData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhGyroidData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhGyroid createAlias(String alias) {
    return AcnhGyroid(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhHybridData extends DataClass implements Insertable<AcnhHybridData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnhHybridData({this.index, this.selected, this.name, this.from});
  factory AcnhHybridData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhHybridData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhHybridCompanion toCompanion(bool nullToAbsent) {
    return AcnhHybridCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhHybridData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhHybridData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhHybridData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnhHybridData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhHybridData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhHybridData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnhHybridCompanion extends UpdateCompanion<AcnhHybridData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnhHybridCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhHybridCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhHybridData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnhHybridCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnhHybridCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhHybridCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhHybrid extends Table with TableInfo<AcnhHybrid, AcnhHybridData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhHybrid(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnh_hybrid';
  @override
  String get actualTableName => 'acnh_hybrid';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhHybridData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhHybridData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhHybridData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhHybrid createAlias(String alias) {
    return AcnhHybrid(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhInsectData extends DataClass implements Insertable<AcnhInsectData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? from;
  final String? weather;
  final String? times;
  AcnhInsectData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.from,
      this.weather,
      this.times});
  factory AcnhInsectData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhInsectData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      weather: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Weather']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || weather != null) {
      map['Weather'] = Variable<String?>(weather);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcnhInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhInsectCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      weather: weather == null && nullToAbsent
          ? const Value.absent()
          : Value(weather),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcnhInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhInsectData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      weather: serializer.fromJson<String?>(json['Weather']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Weather': serializer.toJson<String?>(weather),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcnhInsectData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? from,
          String? weather,
          String? times}) =>
      AcnhInsectData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        from: from ?? this.from,
        weather: weather ?? this.weather,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhInsectData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('weather: $weather, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, from, weather, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhInsectData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.from == this.from &&
          other.weather == this.weather &&
          other.times == this.times);
}

class AcnhInsectCompanion extends UpdateCompanion<AcnhInsectData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> weather;
  final Value<String?> times;
  const AcnhInsectCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.weather = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcnhInsectCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.weather = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcnhInsectData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? weather,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (weather != null) 'Weather': weather,
      if (times != null) 'Times': times,
    });
  }

  AcnhInsectCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? weather,
      Value<String?>? times}) {
    return AcnhInsectCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      from: from ?? this.from,
      weather: weather ?? this.weather,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (weather.present) {
      map['Weather'] = Variable<String?>(weather.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhInsectCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('weather: $weather, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcnhInsect extends Table with TableInfo<AcnhInsect, AcnhInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _weatherMeta = const VerificationMeta('weather');
  late final GeneratedColumn<String?> weather = GeneratedColumn<String?>(
      'Weather', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, from, weather, times];
  @override
  String get aliasedName => _alias ?? 'acnh_insect';
  @override
  String get actualTableName => 'acnh_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Weather')) {
      context.handle(_weatherMeta,
          weather.isAcceptableOrUnknown(data['Weather']!, _weatherMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhInsect createAlias(String alias) {
    return AcnhInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJanInsectData extends DataClass
    implements Insertable<AcnhJanInsectData> {
  final int? id;
  AcnhJanInsectData({this.id});
  factory AcnhJanInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJanInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJanInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhJanInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJanInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJanInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJanInsectData copyWith({int? id}) => AcnhJanInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJanInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJanInsectData && other.id == this.id);
}

class AcnhJanInsectCompanion extends UpdateCompanion<AcnhJanInsectData> {
  final Value<int?> id;
  const AcnhJanInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhJanInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJanInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJanInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhJanInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJanInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJanInsect extends Table
    with TableInfo<AcnhJanInsect, AcnhJanInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJanInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jan_insect';
  @override
  String get actualTableName => 'acnh_jan_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhJanInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJanInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJanInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJanInsect createAlias(String alias) {
    return AcnhJanInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhFebInsectData extends DataClass
    implements Insertable<AcnhFebInsectData> {
  final int? id;
  AcnhFebInsectData({this.id});
  factory AcnhFebInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhFebInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhFebInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhFebInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhFebInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhFebInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhFebInsectData copyWith({int? id}) => AcnhFebInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhFebInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhFebInsectData && other.id == this.id);
}

class AcnhFebInsectCompanion extends UpdateCompanion<AcnhFebInsectData> {
  final Value<int?> id;
  const AcnhFebInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhFebInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhFebInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhFebInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhFebInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhFebInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhFebInsect extends Table
    with TableInfo<AcnhFebInsect, AcnhFebInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhFebInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_feb_insect';
  @override
  String get actualTableName => 'acnh_feb_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhFebInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhFebInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhFebInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhFebInsect createAlias(String alias) {
    return AcnhFebInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhMarInsectData extends DataClass
    implements Insertable<AcnhMarInsectData> {
  final int? id;
  AcnhMarInsectData({this.id});
  factory AcnhMarInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhMarInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhMarInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhMarInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhMarInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhMarInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhMarInsectData copyWith({int? id}) => AcnhMarInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhMarInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhMarInsectData && other.id == this.id);
}

class AcnhMarInsectCompanion extends UpdateCompanion<AcnhMarInsectData> {
  final Value<int?> id;
  const AcnhMarInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhMarInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhMarInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhMarInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhMarInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhMarInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhMarInsect extends Table
    with TableInfo<AcnhMarInsect, AcnhMarInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhMarInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_mar_insect';
  @override
  String get actualTableName => 'acnh_mar_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhMarInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhMarInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhMarInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhMarInsect createAlias(String alias) {
    return AcnhMarInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAprInsectData extends DataClass
    implements Insertable<AcnhAprInsectData> {
  final int? id;
  AcnhAprInsectData({this.id});
  factory AcnhAprInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAprInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAprInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhAprInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAprInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAprInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAprInsectData copyWith({int? id}) => AcnhAprInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAprInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAprInsectData && other.id == this.id);
}

class AcnhAprInsectCompanion extends UpdateCompanion<AcnhAprInsectData> {
  final Value<int?> id;
  const AcnhAprInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhAprInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAprInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAprInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhAprInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAprInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAprInsect extends Table
    with TableInfo<AcnhAprInsect, AcnhAprInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAprInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_apr_insect';
  @override
  String get actualTableName => 'acnh_apr_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhAprInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAprInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAprInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAprInsect createAlias(String alias) {
    return AcnhAprInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhMayInsectData extends DataClass
    implements Insertable<AcnhMayInsectData> {
  final int? id;
  AcnhMayInsectData({this.id});
  factory AcnhMayInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhMayInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhMayInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhMayInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhMayInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhMayInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhMayInsectData copyWith({int? id}) => AcnhMayInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhMayInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhMayInsectData && other.id == this.id);
}

class AcnhMayInsectCompanion extends UpdateCompanion<AcnhMayInsectData> {
  final Value<int?> id;
  const AcnhMayInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhMayInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhMayInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhMayInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhMayInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhMayInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhMayInsect extends Table
    with TableInfo<AcnhMayInsect, AcnhMayInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhMayInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_may_insect';
  @override
  String get actualTableName => 'acnh_may_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhMayInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhMayInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhMayInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhMayInsect createAlias(String alias) {
    return AcnhMayInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJunInsectData extends DataClass
    implements Insertable<AcnhJunInsectData> {
  final int? id;
  AcnhJunInsectData({this.id});
  factory AcnhJunInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJunInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJunInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhJunInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJunInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJunInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJunInsectData copyWith({int? id}) => AcnhJunInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJunInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJunInsectData && other.id == this.id);
}

class AcnhJunInsectCompanion extends UpdateCompanion<AcnhJunInsectData> {
  final Value<int?> id;
  const AcnhJunInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhJunInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJunInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJunInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhJunInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJunInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJunInsect extends Table
    with TableInfo<AcnhJunInsect, AcnhJunInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJunInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jun_insect';
  @override
  String get actualTableName => 'acnh_jun_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhJunInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJunInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJunInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJunInsect createAlias(String alias) {
    return AcnhJunInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJulInsectData extends DataClass
    implements Insertable<AcnhJulInsectData> {
  final int? id;
  AcnhJulInsectData({this.id});
  factory AcnhJulInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJulInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJulInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhJulInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJulInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJulInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJulInsectData copyWith({int? id}) => AcnhJulInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJulInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJulInsectData && other.id == this.id);
}

class AcnhJulInsectCompanion extends UpdateCompanion<AcnhJulInsectData> {
  final Value<int?> id;
  const AcnhJulInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhJulInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJulInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJulInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhJulInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJulInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJulInsect extends Table
    with TableInfo<AcnhJulInsect, AcnhJulInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJulInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jul_insect';
  @override
  String get actualTableName => 'acnh_jul_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhJulInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJulInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJulInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJulInsect createAlias(String alias) {
    return AcnhJulInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAug1InsectData extends DataClass
    implements Insertable<AcnhAug1InsectData> {
  final int? id;
  AcnhAug1InsectData({this.id});
  factory AcnhAug1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAug1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAug1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhAug1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAug1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAug1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAug1InsectData copyWith({int? id}) => AcnhAug1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAug1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAug1InsectData && other.id == this.id);
}

class AcnhAug1InsectCompanion extends UpdateCompanion<AcnhAug1InsectData> {
  final Value<int?> id;
  const AcnhAug1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhAug1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAug1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAug1InsectCompanion copyWith({Value<int?>? id}) {
    return AcnhAug1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAug1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAug1Insect extends Table
    with TableInfo<AcnhAug1Insect, AcnhAug1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAug1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_aug1_insect';
  @override
  String get actualTableName => 'acnh_aug1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhAug1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAug1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAug1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAug1Insect createAlias(String alias) {
    return AcnhAug1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAug2InsectData extends DataClass
    implements Insertable<AcnhAug2InsectData> {
  final int? id;
  AcnhAug2InsectData({this.id});
  factory AcnhAug2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAug2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAug2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhAug2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAug2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAug2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAug2InsectData copyWith({int? id}) => AcnhAug2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAug2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAug2InsectData && other.id == this.id);
}

class AcnhAug2InsectCompanion extends UpdateCompanion<AcnhAug2InsectData> {
  final Value<int?> id;
  const AcnhAug2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhAug2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAug2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAug2InsectCompanion copyWith({Value<int?>? id}) {
    return AcnhAug2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAug2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAug2Insect extends Table
    with TableInfo<AcnhAug2Insect, AcnhAug2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAug2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_aug2_insect';
  @override
  String get actualTableName => 'acnh_aug2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhAug2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAug2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAug2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAug2Insect createAlias(String alias) {
    return AcnhAug2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSep1InsectData extends DataClass
    implements Insertable<AcnhSep1InsectData> {
  final int? id;
  AcnhSep1InsectData({this.id});
  factory AcnhSep1InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSep1InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhSep1InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhSep1InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhSep1InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSep1InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhSep1InsectData copyWith({int? id}) => AcnhSep1InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSep1InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSep1InsectData && other.id == this.id);
}

class AcnhSep1InsectCompanion extends UpdateCompanion<AcnhSep1InsectData> {
  final Value<int?> id;
  const AcnhSep1InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhSep1InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhSep1InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhSep1InsectCompanion copyWith({Value<int?>? id}) {
    return AcnhSep1InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSep1InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhSep1Insect extends Table
    with TableInfo<AcnhSep1Insect, AcnhSep1InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSep1Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_sep1_insect';
  @override
  String get actualTableName => 'acnh_sep1_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhSep1InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSep1InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhSep1InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSep1Insect createAlias(String alias) {
    return AcnhSep1Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSep2InsectData extends DataClass
    implements Insertable<AcnhSep2InsectData> {
  final int? id;
  AcnhSep2InsectData({this.id});
  factory AcnhSep2InsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSep2InsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhSep2InsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhSep2InsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhSep2InsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSep2InsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhSep2InsectData copyWith({int? id}) => AcnhSep2InsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSep2InsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSep2InsectData && other.id == this.id);
}

class AcnhSep2InsectCompanion extends UpdateCompanion<AcnhSep2InsectData> {
  final Value<int?> id;
  const AcnhSep2InsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhSep2InsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhSep2InsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhSep2InsectCompanion copyWith({Value<int?>? id}) {
    return AcnhSep2InsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSep2InsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhSep2Insect extends Table
    with TableInfo<AcnhSep2Insect, AcnhSep2InsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSep2Insect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_sep2_insect';
  @override
  String get actualTableName => 'acnh_sep2_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhSep2InsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSep2InsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhSep2InsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSep2Insect createAlias(String alias) {
    return AcnhSep2Insect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhOctInsectData extends DataClass
    implements Insertable<AcnhOctInsectData> {
  final int? id;
  AcnhOctInsectData({this.id});
  factory AcnhOctInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhOctInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhOctInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhOctInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhOctInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhOctInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhOctInsectData copyWith({int? id}) => AcnhOctInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhOctInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhOctInsectData && other.id == this.id);
}

class AcnhOctInsectCompanion extends UpdateCompanion<AcnhOctInsectData> {
  final Value<int?> id;
  const AcnhOctInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhOctInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhOctInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhOctInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhOctInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhOctInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhOctInsect extends Table
    with TableInfo<AcnhOctInsect, AcnhOctInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhOctInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_oct_insect';
  @override
  String get actualTableName => 'acnh_oct_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhOctInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhOctInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhOctInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhOctInsect createAlias(String alias) {
    return AcnhOctInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhNovInsectData extends DataClass
    implements Insertable<AcnhNovInsectData> {
  final int? id;
  AcnhNovInsectData({this.id});
  factory AcnhNovInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhNovInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhNovInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhNovInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhNovInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhNovInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhNovInsectData copyWith({int? id}) => AcnhNovInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhNovInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhNovInsectData && other.id == this.id);
}

class AcnhNovInsectCompanion extends UpdateCompanion<AcnhNovInsectData> {
  final Value<int?> id;
  const AcnhNovInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhNovInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhNovInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhNovInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhNovInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhNovInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhNovInsect extends Table
    with TableInfo<AcnhNovInsect, AcnhNovInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhNovInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_nov_insect';
  @override
  String get actualTableName => 'acnh_nov_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhNovInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhNovInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhNovInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhNovInsect createAlias(String alias) {
    return AcnhNovInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhDecInsectData extends DataClass
    implements Insertable<AcnhDecInsectData> {
  final int? id;
  AcnhDecInsectData({this.id});
  factory AcnhDecInsectData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhDecInsectData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhDecInsectCompanion toCompanion(bool nullToAbsent) {
    return AcnhDecInsectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhDecInsectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhDecInsectData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhDecInsectData copyWith({int? id}) => AcnhDecInsectData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhDecInsectData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhDecInsectData && other.id == this.id);
}

class AcnhDecInsectCompanion extends UpdateCompanion<AcnhDecInsectData> {
  final Value<int?> id;
  const AcnhDecInsectCompanion({
    this.id = const Value.absent(),
  });
  AcnhDecInsectCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhDecInsectData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhDecInsectCompanion copyWith({Value<int?>? id}) {
    return AcnhDecInsectCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhDecInsectCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhDecInsect extends Table
    with TableInfo<AcnhDecInsect, AcnhDecInsectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhDecInsect(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_dec_insect';
  @override
  String get actualTableName => 'acnh_dec_insect';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhDecInsectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhDecInsectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhDecInsectData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhDecInsect createAlias(String alias) {
    return AcnhDecInsect(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhPhotoData extends DataClass implements Insertable<AcnhPhotoData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnhPhotoData({this.index, this.selected, this.name, this.from});
  factory AcnhPhotoData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhPhotoData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhPhotoCompanion toCompanion(bool nullToAbsent) {
    return AcnhPhotoCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhPhotoData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhPhotoData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhPhotoData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnhPhotoData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhPhotoData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhPhotoData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnhPhotoCompanion extends UpdateCompanion<AcnhPhotoData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnhPhotoCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhPhotoCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhPhotoData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnhPhotoCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnhPhotoCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhPhotoCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhPhoto extends Table with TableInfo<AcnhPhoto, AcnhPhotoData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhPhoto(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnh_photo';
  @override
  String get actualTableName => 'acnh_photo';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhPhotoData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhPhotoData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhPhotoData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhPhoto createAlias(String alias) {
    return AcnhPhoto(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhPosterData extends DataClass implements Insertable<AcnhPosterData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnhPosterData({this.index, this.selected, this.name, this.from});
  factory AcnhPosterData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhPosterData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhPosterCompanion toCompanion(bool nullToAbsent) {
    return AcnhPosterCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhPosterData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhPosterData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhPosterData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnhPosterData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhPosterData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhPosterData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnhPosterCompanion extends UpdateCompanion<AcnhPosterData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnhPosterCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhPosterCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhPosterData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnhPosterCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnhPosterCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhPosterCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhPoster extends Table with TableInfo<AcnhPoster, AcnhPosterData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhPoster(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnh_poster';
  @override
  String get actualTableName => 'acnh_poster';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhPosterData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhPosterData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhPosterData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhPoster createAlias(String alias) {
    return AcnhPoster(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhRecipeData extends DataClass implements Insertable<AcnhRecipeData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? materials;
  final String? from;
  AcnhRecipeData(
      {this.index, this.selected, this.name, this.materials, this.from});
  factory AcnhRecipeData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhRecipeData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      materials: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Materials']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || materials != null) {
      map['Materials'] = Variable<String?>(materials);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhRecipeCompanion toCompanion(bool nullToAbsent) {
    return AcnhRecipeCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      materials: materials == null && nullToAbsent
          ? const Value.absent()
          : Value(materials),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhRecipeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhRecipeData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      materials: serializer.fromJson<String?>(json['Materials']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Materials': serializer.toJson<String?>(materials),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhRecipeData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? materials,
          String? from}) =>
      AcnhRecipeData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        materials: materials ?? this.materials,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhRecipeData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('materials: $materials, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, materials, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhRecipeData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.materials == this.materials &&
          other.from == this.from);
}

class AcnhRecipeCompanion extends UpdateCompanion<AcnhRecipeData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> materials;
  final Value<String?> from;
  const AcnhRecipeCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.materials = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhRecipeCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.materials = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhRecipeData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? materials,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (materials != null) 'Materials': materials,
      if (from != null) 'From': from,
    });
  }

  AcnhRecipeCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? materials,
      Value<String?>? from}) {
    return AcnhRecipeCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      materials: materials ?? this.materials,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (materials.present) {
      map['Materials'] = Variable<String?>(materials.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhRecipeCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('materials: $materials, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhRecipe extends Table with TableInfo<AcnhRecipe, AcnhRecipeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhRecipe(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _materialsMeta = const VerificationMeta('materials');
  late final GeneratedColumn<String?> materials = GeneratedColumn<String?>(
      'Materials', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, materials, from];
  @override
  String get aliasedName => _alias ?? 'acnh_recipe';
  @override
  String get actualTableName => 'acnh_recipe';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhRecipeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Materials')) {
      context.handle(_materialsMeta,
          materials.isAcceptableOrUnknown(data['Materials']!, _materialsMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhRecipeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhRecipeData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhRecipe createAlias(String alias) {
    return AcnhRecipe(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhRugData extends DataClass implements Insertable<AcnhRugData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhRugData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhRugData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhRugData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhRugCompanion toCompanion(bool nullToAbsent) {
    return AcnhRugCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhRugData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhRugData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhRugData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhRugData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhRugData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhRugData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhRugCompanion extends UpdateCompanion<AcnhRugData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhRugCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhRugCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhRugData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhRugCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhRugCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhRugCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhRug extends Table with TableInfo<AcnhRug, AcnhRugData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhRug(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_rug';
  @override
  String get actualTableName => 'acnh_rug';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhRugData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhRugData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhRugData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhRug createAlias(String alias) {
    return AcnhRug(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhShoeData extends DataClass implements Insertable<AcnhShoeData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhShoeData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhShoeData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhShoeData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhShoeCompanion toCompanion(bool nullToAbsent) {
    return AcnhShoeCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhShoeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhShoeData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhShoeData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhShoeData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhShoeData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhShoeData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhShoeCompanion extends UpdateCompanion<AcnhShoeData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhShoeCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhShoeCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhShoeData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhShoeCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhShoeCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhShoeCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhShoe extends Table with TableInfo<AcnhShoe, AcnhShoeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhShoe(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_shoe';
  @override
  String get actualTableName => 'acnh_shoe';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhShoeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhShoeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhShoeData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhShoe createAlias(String alias) {
    return AcnhShoe(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSockData extends DataClass implements Insertable<AcnhSockData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhSockData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhSockData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSockData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhSockCompanion toCompanion(bool nullToAbsent) {
    return AcnhSockCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhSockData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSockData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhSockData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhSockData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSockData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSockData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhSockCompanion extends UpdateCompanion<AcnhSockData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhSockCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhSockCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhSockData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhSockCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhSockCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSockCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhSock extends Table with TableInfo<AcnhSock, AcnhSockData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSock(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_sock';
  @override
  String get actualTableName => 'acnh_sock';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhSockData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSockData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhSockData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSock createAlias(String alias) {
    return AcnhSock(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSongData extends DataClass implements Insertable<AcnhSongData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? from;
  AcnhSongData({this.index, this.selected, this.name, this.status, this.from});
  factory AcnhSongData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSongData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhSongCompanion toCompanion(bool nullToAbsent) {
    return AcnhSongCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhSongData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSongData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhSongData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? from}) =>
      AcnhSongData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSongData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSongData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.from == this.from);
}

class AcnhSongCompanion extends UpdateCompanion<AcnhSongData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> from;
  const AcnhSongCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhSongCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhSongData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (from != null) 'From': from,
    });
  }

  AcnhSongCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? from}) {
    return AcnhSongCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSongCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhSong extends Table with TableInfo<AcnhSong, AcnhSongData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSong(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, status, from];
  @override
  String get aliasedName => _alias ?? 'acnh_song';
  @override
  String get actualTableName => 'acnh_song';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhSongData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSongData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhSongData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSong createAlias(String alias) {
    return AcnhSong(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhToolData extends DataClass implements Insertable<AcnhToolData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? from;
  AcnhToolData({this.index, this.selected, this.name, this.from});
  factory AcnhToolData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhToolData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhToolCompanion toCompanion(bool nullToAbsent) {
    return AcnhToolCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhToolData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhToolData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhToolData copyWith(
          {int? index, int? selected, String? name, String? from}) =>
      AcnhToolData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhToolData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhToolData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.from == this.from);
}

class AcnhToolCompanion extends UpdateCompanion<AcnhToolData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> from;
  const AcnhToolCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhToolCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhToolData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (from != null) 'From': from,
    });
  }

  AcnhToolCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? from}) {
    return AcnhToolCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhToolCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhTool extends Table with TableInfo<AcnhTool, AcnhToolData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhTool(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [index, selected, name, from];
  @override
  String get aliasedName => _alias ?? 'acnh_tool';
  @override
  String get actualTableName => 'acnh_tool';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhToolData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhToolData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhToolData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhTool createAlias(String alias) {
    return AcnhTool(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhTopData extends DataClass implements Insertable<AcnhTopData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhTopData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhTopData.fromData(Map<String, dynamic> data, {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhTopData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhTopCompanion toCompanion(bool nullToAbsent) {
    return AcnhTopCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhTopData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhTopData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhTopData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhTopData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhTopData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhTopData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhTopCompanion extends UpdateCompanion<AcnhTopData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhTopCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhTopCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhTopData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhTopCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhTopCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhTopCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhTop extends Table with TableInfo<AcnhTop, AcnhTopData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhTop(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_top';
  @override
  String get actualTableName => 'acnh_top';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhTopData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhTopData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhTopData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhTop createAlias(String alias) {
    return AcnhTop(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhUmbrellaData extends DataClass
    implements Insertable<AcnhUmbrellaData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  AcnhUmbrellaData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from});
  factory AcnhUmbrellaData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhUmbrellaData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    return map;
  }

  AcnhUmbrellaCompanion toCompanion(bool nullToAbsent) {
    return AcnhUmbrellaCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
    );
  }

  factory AcnhUmbrellaData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhUmbrellaData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
    };
  }

  AcnhUmbrellaData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from}) =>
      AcnhUmbrellaData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhUmbrellaData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(index, selected, name, status, price, from);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhUmbrellaData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from);
}

class AcnhUmbrellaCompanion extends UpdateCompanion<AcnhUmbrellaData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  const AcnhUmbrellaCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  AcnhUmbrellaCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
  });
  static Insertable<AcnhUmbrellaData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
    });
  }

  AcnhUmbrellaCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from}) {
    return AcnhUmbrellaCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhUmbrellaCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from')
          ..write(')'))
        .toString();
  }
}

class AcnhUmbrella extends Table
    with TableInfo<AcnhUmbrella, AcnhUmbrellaData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhUmbrella(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from];
  @override
  String get aliasedName => _alias ?? 'acnh_umbrella';
  @override
  String get actualTableName => 'acnh_umbrella';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhUmbrellaData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhUmbrellaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhUmbrellaData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhUmbrella createAlias(String alias) {
    return AcnhUmbrella(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhWallpaperData extends DataClass
    implements Insertable<AcnhWallpaperData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? concept1;
  final String? concept2;
  final String? series;
  AcnhWallpaperData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.concept1,
      this.concept2,
      this.series});
  factory AcnhWallpaperData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhWallpaperData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      concept1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept1']),
      concept2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Concept2']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || concept1 != null) {
      map['Concept1'] = Variable<String?>(concept1);
    }
    if (!nullToAbsent || concept2 != null) {
      map['Concept2'] = Variable<String?>(concept2);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    return map;
  }

  AcnhWallpaperCompanion toCompanion(bool nullToAbsent) {
    return AcnhWallpaperCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      concept1: concept1 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept1),
      concept2: concept2 == null && nullToAbsent
          ? const Value.absent()
          : Value(concept2),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
    );
  }

  factory AcnhWallpaperData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhWallpaperData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      concept1: serializer.fromJson<String?>(json['Concept1']),
      concept2: serializer.fromJson<String?>(json['Concept2']),
      series: serializer.fromJson<String?>(json['Series']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Concept1': serializer.toJson<String?>(concept1),
      'Concept2': serializer.toJson<String?>(concept2),
      'Series': serializer.toJson<String?>(series),
    };
  }

  AcnhWallpaperData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? concept1,
          String? concept2,
          String? series}) =>
      AcnhWallpaperData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        concept1: concept1 ?? this.concept1,
        concept2: concept2 ?? this.concept2,
        series: series ?? this.series,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhWallpaperData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      index, selected, name, status, price, from, concept1, concept2, series);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhWallpaperData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.concept1 == this.concept1 &&
          other.concept2 == this.concept2 &&
          other.series == this.series);
}

class AcnhWallpaperCompanion extends UpdateCompanion<AcnhWallpaperData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> concept1;
  final Value<String?> concept2;
  final Value<String?> series;
  const AcnhWallpaperCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  AcnhWallpaperCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.concept1 = const Value.absent(),
    this.concept2 = const Value.absent(),
    this.series = const Value.absent(),
  });
  static Insertable<AcnhWallpaperData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? concept1,
    Expression<String?>? concept2,
    Expression<String?>? series,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (concept1 != null) 'Concept1': concept1,
      if (concept2 != null) 'Concept2': concept2,
      if (series != null) 'Series': series,
    });
  }

  AcnhWallpaperCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? concept1,
      Value<String?>? concept2,
      Value<String?>? series}) {
    return AcnhWallpaperCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      concept1: concept1 ?? this.concept1,
      concept2: concept2 ?? this.concept2,
      series: series ?? this.series,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (concept1.present) {
      map['Concept1'] = Variable<String?>(concept1.value);
    }
    if (concept2.present) {
      map['Concept2'] = Variable<String?>(concept2.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhWallpaperCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('concept1: $concept1, ')
          ..write('concept2: $concept2, ')
          ..write('series: $series')
          ..write(')'))
        .toString();
  }
}

class AcnhWallpaper extends Table
    with TableInfo<AcnhWallpaper, AcnhWallpaperData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhWallpaper(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept1Meta = const VerificationMeta('concept1');
  late final GeneratedColumn<String?> concept1 = GeneratedColumn<String?>(
      'Concept1', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _concept2Meta = const VerificationMeta('concept2');
  late final GeneratedColumn<String?> concept2 = GeneratedColumn<String?>(
      'Concept2', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, concept1, concept2, series];
  @override
  String get aliasedName => _alias ?? 'acnh_wallpaper';
  @override
  String get actualTableName => 'acnh_wallpaper';
  @override
  VerificationContext validateIntegrity(Insertable<AcnhWallpaperData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Concept1')) {
      context.handle(_concept1Meta,
          concept1.isAcceptableOrUnknown(data['Concept1']!, _concept1Meta));
    }
    if (data.containsKey('Concept2')) {
      context.handle(_concept2Meta,
          concept2.isAcceptableOrUnknown(data['Concept2']!, _concept2Meta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhWallpaperData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhWallpaperData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhWallpaper createAlias(String alias) {
    return AcnhWallpaper(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcgcFurnitureData extends DataClass
    implements Insertable<AcgcFurnitureData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? from;
  final String? series;
  final String? color;
  AcgcFurnitureData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.from,
      this.series,
      this.color});
  factory AcgcFurnitureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcgcFurnitureData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      series: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Series']),
      color: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Color']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || series != null) {
      map['Series'] = Variable<String?>(series);
    }
    if (!nullToAbsent || color != null) {
      map['Color'] = Variable<String?>(color);
    }
    return map;
  }

  AcgcFurnitureCompanion toCompanion(bool nullToAbsent) {
    return AcgcFurnitureCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      series:
          series == null && nullToAbsent ? const Value.absent() : Value(series),
      color:
          color == null && nullToAbsent ? const Value.absent() : Value(color),
    );
  }

  factory AcgcFurnitureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcgcFurnitureData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      series: serializer.fromJson<String?>(json['Series']),
      color: serializer.fromJson<String?>(json['Color']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Series': serializer.toJson<String?>(series),
      'Color': serializer.toJson<String?>(color),
    };
  }

  AcgcFurnitureData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? from,
          String? series,
          String? color}) =>
      AcgcFurnitureData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        from: from ?? this.from,
        series: series ?? this.series,
        color: color ?? this.color,
      );
  @override
  String toString() {
    return (StringBuffer('AcgcFurnitureData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('series: $series, ')
          ..write('color: $color')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, from, series, color);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcgcFurnitureData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.from == this.from &&
          other.series == this.series &&
          other.color == this.color);
}

class AcgcFurnitureCompanion extends UpdateCompanion<AcgcFurnitureData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> series;
  final Value<String?> color;
  const AcgcFurnitureCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.series = const Value.absent(),
    this.color = const Value.absent(),
  });
  AcgcFurnitureCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.series = const Value.absent(),
    this.color = const Value.absent(),
  });
  static Insertable<AcgcFurnitureData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? series,
    Expression<String?>? color,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (series != null) 'Series': series,
      if (color != null) 'Color': color,
    });
  }

  AcgcFurnitureCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? series,
      Value<String?>? color}) {
    return AcgcFurnitureCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      from: from ?? this.from,
      series: series ?? this.series,
      color: color ?? this.color,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (series.present) {
      map['Series'] = Variable<String?>(series.value);
    }
    if (color.present) {
      map['Color'] = Variable<String?>(color.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcgcFurnitureCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('series: $series, ')
          ..write('color: $color')
          ..write(')'))
        .toString();
  }
}

class AcgcFurniture extends Table
    with TableInfo<AcgcFurniture, AcgcFurnitureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcgcFurniture(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _seriesMeta = const VerificationMeta('series');
  late final GeneratedColumn<String?> series = GeneratedColumn<String?>(
      'Series', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _colorMeta = const VerificationMeta('color');
  late final GeneratedColumn<String?> color = GeneratedColumn<String?>(
      'Color', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, from, series, color];
  @override
  String get aliasedName => _alias ?? 'acgc_furniture';
  @override
  String get actualTableName => 'acgc_furniture';
  @override
  VerificationContext validateIntegrity(Insertable<AcgcFurnitureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Series')) {
      context.handle(_seriesMeta,
          series.isAcceptableOrUnknown(data['Series']!, _seriesMeta));
    }
    if (data.containsKey('Color')) {
      context.handle(
          _colorMeta, color.isAcceptableOrUnknown(data['Color']!, _colorMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcgcFurnitureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcgcFurnitureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcgcFurniture createAlias(String alias) {
    return AcgcFurniture(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhOtherClothingData extends DataClass
    implements Insertable<AcnhOtherClothingData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? status;
  final String? price;
  final String? from;
  final String? style;
  AcnhOtherClothingData(
      {this.index,
      this.selected,
      this.name,
      this.status,
      this.price,
      this.from,
      this.style});
  factory AcnhOtherClothingData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhOtherClothingData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      status: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Status']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      from: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}From']),
      style: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Style']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || status != null) {
      map['Status'] = Variable<String?>(status);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || from != null) {
      map['From'] = Variable<String?>(from);
    }
    if (!nullToAbsent || style != null) {
      map['Style'] = Variable<String?>(style);
    }
    return map;
  }

  AcnhOtherClothingCompanion toCompanion(bool nullToAbsent) {
    return AcnhOtherClothingCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      from: from == null && nullToAbsent ? const Value.absent() : Value(from),
      style:
          style == null && nullToAbsent ? const Value.absent() : Value(style),
    );
  }

  factory AcnhOtherClothingData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhOtherClothingData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      status: serializer.fromJson<String?>(json['Status']),
      price: serializer.fromJson<String?>(json['Price']),
      from: serializer.fromJson<String?>(json['From']),
      style: serializer.fromJson<String?>(json['Style']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Status': serializer.toJson<String?>(status),
      'Price': serializer.toJson<String?>(price),
      'From': serializer.toJson<String?>(from),
      'Style': serializer.toJson<String?>(style),
    };
  }

  AcnhOtherClothingData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? status,
          String? price,
          String? from,
          String? style}) =>
      AcnhOtherClothingData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        status: status ?? this.status,
        price: price ?? this.price,
        from: from ?? this.from,
        style: style ?? this.style,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhOtherClothingData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, status, price, from, style);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhOtherClothingData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.status == this.status &&
          other.price == this.price &&
          other.from == this.from &&
          other.style == this.style);
}

class AcnhOtherClothingCompanion
    extends UpdateCompanion<AcnhOtherClothingData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> status;
  final Value<String?> price;
  final Value<String?> from;
  final Value<String?> style;
  const AcnhOtherClothingCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  AcnhOtherClothingCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.price = const Value.absent(),
    this.from = const Value.absent(),
    this.style = const Value.absent(),
  });
  static Insertable<AcnhOtherClothingData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? status,
    Expression<String?>? price,
    Expression<String?>? from,
    Expression<String?>? style,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
      if (price != null) 'Price': price,
      if (from != null) 'From': from,
      if (style != null) 'Style': style,
    });
  }

  AcnhOtherClothingCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? status,
      Value<String?>? price,
      Value<String?>? from,
      Value<String?>? style}) {
    return AcnhOtherClothingCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      status: status ?? this.status,
      price: price ?? this.price,
      from: from ?? this.from,
      style: style ?? this.style,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (status.present) {
      map['Status'] = Variable<String?>(status.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (from.present) {
      map['From'] = Variable<String?>(from.value);
    }
    if (style.present) {
      map['Style'] = Variable<String?>(style.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhOtherClothingCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('price: $price, ')
          ..write('from: $from, ')
          ..write('style: $style')
          ..write(')'))
        .toString();
  }
}

class AcnhOtherClothing extends Table
    with TableInfo<AcnhOtherClothing, AcnhOtherClothingData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhOtherClothing(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String?> status = GeneratedColumn<String?>(
      'Status', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _fromMeta = const VerificationMeta('from');
  late final GeneratedColumn<String?> from = GeneratedColumn<String?>(
      'From', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _styleMeta = const VerificationMeta('style');
  late final GeneratedColumn<String?> style = GeneratedColumn<String?>(
      'Style', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, status, price, from, style];
  @override
  String get aliasedName => _alias ?? 'acnh_other_clothing';
  @override
  String get actualTableName => 'acnh_other_clothing';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhOtherClothingData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['Status']!, _statusMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('From')) {
      context.handle(
          _fromMeta, from.isAcceptableOrUnknown(data['From']!, _fromMeta));
    }
    if (data.containsKey('Style')) {
      context.handle(
          _styleMeta, style.isAcceptableOrUnknown(data['Style']!, _styleMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhOtherClothingData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhOtherClothingData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhOtherClothing createAlias(String alias) {
    return AcnhOtherClothing(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSeaCreatureData extends DataClass
    implements Insertable<AcnhSeaCreatureData> {
  final int? index;
  final int? selected;
  final String? name;
  final String? price;
  final String? shadow;
  final String? catchesToUnlock;
  final String? times;
  AcnhSeaCreatureData(
      {this.index,
      this.selected,
      this.name,
      this.price,
      this.shadow,
      this.catchesToUnlock,
      this.times});
  factory AcnhSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSeaCreatureData(
      index: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Index']),
      selected: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Selected']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Name']),
      price: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Price']),
      shadow: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Shadow']),
      catchesToUnlock: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Catches to Unlock']),
      times: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}Times']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || index != null) {
      map['Index'] = Variable<int?>(index);
    }
    if (!nullToAbsent || selected != null) {
      map['Selected'] = Variable<int?>(selected);
    }
    if (!nullToAbsent || name != null) {
      map['Name'] = Variable<String?>(name);
    }
    if (!nullToAbsent || price != null) {
      map['Price'] = Variable<String?>(price);
    }
    if (!nullToAbsent || shadow != null) {
      map['Shadow'] = Variable<String?>(shadow);
    }
    if (!nullToAbsent || catchesToUnlock != null) {
      map['Catches to Unlock'] = Variable<String?>(catchesToUnlock);
    }
    if (!nullToAbsent || times != null) {
      map['Times'] = Variable<String?>(times);
    }
    return map;
  }

  AcnhSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhSeaCreatureCompanion(
      index:
          index == null && nullToAbsent ? const Value.absent() : Value(index),
      selected: selected == null && nullToAbsent
          ? const Value.absent()
          : Value(selected),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      shadow:
          shadow == null && nullToAbsent ? const Value.absent() : Value(shadow),
      catchesToUnlock: catchesToUnlock == null && nullToAbsent
          ? const Value.absent()
          : Value(catchesToUnlock),
      times:
          times == null && nullToAbsent ? const Value.absent() : Value(times),
    );
  }

  factory AcnhSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSeaCreatureData(
      index: serializer.fromJson<int?>(json['Index']),
      selected: serializer.fromJson<int?>(json['Selected']),
      name: serializer.fromJson<String?>(json['Name']),
      price: serializer.fromJson<String?>(json['Price']),
      shadow: serializer.fromJson<String?>(json['Shadow']),
      catchesToUnlock: serializer.fromJson<String?>(json['Catches to Unlock']),
      times: serializer.fromJson<String?>(json['Times']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'Index': serializer.toJson<int?>(index),
      'Selected': serializer.toJson<int?>(selected),
      'Name': serializer.toJson<String?>(name),
      'Price': serializer.toJson<String?>(price),
      'Shadow': serializer.toJson<String?>(shadow),
      'Catches to Unlock': serializer.toJson<String?>(catchesToUnlock),
      'Times': serializer.toJson<String?>(times),
    };
  }

  AcnhSeaCreatureData copyWith(
          {int? index,
          int? selected,
          String? name,
          String? price,
          String? shadow,
          String? catchesToUnlock,
          String? times}) =>
      AcnhSeaCreatureData(
        index: index ?? this.index,
        selected: selected ?? this.selected,
        name: name ?? this.name,
        price: price ?? this.price,
        shadow: shadow ?? this.shadow,
        catchesToUnlock: catchesToUnlock ?? this.catchesToUnlock,
        times: times ?? this.times,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSeaCreatureData(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('shadow: $shadow, ')
          ..write('catchesToUnlock: $catchesToUnlock, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(index, selected, name, price, shadow, catchesToUnlock, times);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSeaCreatureData &&
          other.index == this.index &&
          other.selected == this.selected &&
          other.name == this.name &&
          other.price == this.price &&
          other.shadow == this.shadow &&
          other.catchesToUnlock == this.catchesToUnlock &&
          other.times == this.times);
}

class AcnhSeaCreatureCompanion extends UpdateCompanion<AcnhSeaCreatureData> {
  final Value<int?> index;
  final Value<int?> selected;
  final Value<String?> name;
  final Value<String?> price;
  final Value<String?> shadow;
  final Value<String?> catchesToUnlock;
  final Value<String?> times;
  const AcnhSeaCreatureCompanion({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.shadow = const Value.absent(),
    this.catchesToUnlock = const Value.absent(),
    this.times = const Value.absent(),
  });
  AcnhSeaCreatureCompanion.insert({
    this.index = const Value.absent(),
    this.selected = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.shadow = const Value.absent(),
    this.catchesToUnlock = const Value.absent(),
    this.times = const Value.absent(),
  });
  static Insertable<AcnhSeaCreatureData> custom({
    Expression<int?>? index,
    Expression<int?>? selected,
    Expression<String?>? name,
    Expression<String?>? price,
    Expression<String?>? shadow,
    Expression<String?>? catchesToUnlock,
    Expression<String?>? times,
  }) {
    return RawValuesInsertable({
      if (index != null) 'Index': index,
      if (selected != null) 'Selected': selected,
      if (name != null) 'Name': name,
      if (price != null) 'Price': price,
      if (shadow != null) 'Shadow': shadow,
      if (catchesToUnlock != null) 'Catches to Unlock': catchesToUnlock,
      if (times != null) 'Times': times,
    });
  }

  AcnhSeaCreatureCompanion copyWith(
      {Value<int?>? index,
      Value<int?>? selected,
      Value<String?>? name,
      Value<String?>? price,
      Value<String?>? shadow,
      Value<String?>? catchesToUnlock,
      Value<String?>? times}) {
    return AcnhSeaCreatureCompanion(
      index: index ?? this.index,
      selected: selected ?? this.selected,
      name: name ?? this.name,
      price: price ?? this.price,
      shadow: shadow ?? this.shadow,
      catchesToUnlock: catchesToUnlock ?? this.catchesToUnlock,
      times: times ?? this.times,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (index.present) {
      map['Index'] = Variable<int?>(index.value);
    }
    if (selected.present) {
      map['Selected'] = Variable<int?>(selected.value);
    }
    if (name.present) {
      map['Name'] = Variable<String?>(name.value);
    }
    if (price.present) {
      map['Price'] = Variable<String?>(price.value);
    }
    if (shadow.present) {
      map['Shadow'] = Variable<String?>(shadow.value);
    }
    if (catchesToUnlock.present) {
      map['Catches to Unlock'] = Variable<String?>(catchesToUnlock.value);
    }
    if (times.present) {
      map['Times'] = Variable<String?>(times.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSeaCreatureCompanion(')
          ..write('index: $index, ')
          ..write('selected: $selected, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('shadow: $shadow, ')
          ..write('catchesToUnlock: $catchesToUnlock, ')
          ..write('times: $times')
          ..write(')'))
        .toString();
  }
}

class AcnhSeaCreature extends Table
    with TableInfo<AcnhSeaCreature, AcnhSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _indexMeta = const VerificationMeta('index');
  late final GeneratedColumn<int?> index = GeneratedColumn<int?>(
      'Index', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _selectedMeta = const VerificationMeta('selected');
  late final GeneratedColumn<int?> selected = GeneratedColumn<int?>(
      'Selected', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
      'Name', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<String?> price = GeneratedColumn<String?>(
      'Price', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _shadowMeta = const VerificationMeta('shadow');
  late final GeneratedColumn<String?> shadow = GeneratedColumn<String?>(
      'Shadow', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  final VerificationMeta _catchesToUnlockMeta =
      const VerificationMeta('catchesToUnlock');
  late final GeneratedColumn<String?> catchesToUnlock =
      GeneratedColumn<String?>('Catches to Unlock', aliasedName, true,
          type: const StringType(),
          requiredDuringInsert: false,
          $customConstraints: '');
  final VerificationMeta _timesMeta = const VerificationMeta('times');
  late final GeneratedColumn<String?> times = GeneratedColumn<String?>(
      'Times', aliasedName, true,
      type: const StringType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [index, selected, name, price, shadow, catchesToUnlock, times];
  @override
  String get aliasedName => _alias ?? 'acnh_sea_creature';
  @override
  String get actualTableName => 'acnh_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('Index')) {
      context.handle(
          _indexMeta, index.isAcceptableOrUnknown(data['Index']!, _indexMeta));
    }
    if (data.containsKey('Selected')) {
      context.handle(_selectedMeta,
          selected.isAcceptableOrUnknown(data['Selected']!, _selectedMeta));
    }
    if (data.containsKey('Name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['Name']!, _nameMeta));
    }
    if (data.containsKey('Price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['Price']!, _priceMeta));
    }
    if (data.containsKey('Shadow')) {
      context.handle(_shadowMeta,
          shadow.isAcceptableOrUnknown(data['Shadow']!, _shadowMeta));
    }
    if (data.containsKey('Catches to Unlock')) {
      context.handle(
          _catchesToUnlockMeta,
          catchesToUnlock.isAcceptableOrUnknown(
              data['Catches to Unlock']!, _catchesToUnlockMeta));
    }
    if (data.containsKey('Times')) {
      context.handle(
          _timesMeta, times.isAcceptableOrUnknown(data['Times']!, _timesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSeaCreature createAlias(String alias) {
    return AcnhSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJanSeaCreatureData extends DataClass
    implements Insertable<AcnhJanSeaCreatureData> {
  final int? id;
  AcnhJanSeaCreatureData({this.id});
  factory AcnhJanSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJanSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJanSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhJanSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJanSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJanSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJanSeaCreatureData copyWith({int? id}) => AcnhJanSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJanSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJanSeaCreatureData && other.id == this.id);
}

class AcnhJanSeaCreatureCompanion
    extends UpdateCompanion<AcnhJanSeaCreatureData> {
  final Value<int?> id;
  const AcnhJanSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhJanSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJanSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJanSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhJanSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJanSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJanSeaCreature extends Table
    with TableInfo<AcnhJanSeaCreature, AcnhJanSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJanSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jan_sea_creature';
  @override
  String get actualTableName => 'acnh_jan_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhJanSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJanSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJanSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJanSeaCreature createAlias(String alias) {
    return AcnhJanSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhFebSeaCreatureData extends DataClass
    implements Insertable<AcnhFebSeaCreatureData> {
  final int? id;
  AcnhFebSeaCreatureData({this.id});
  factory AcnhFebSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhFebSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhFebSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhFebSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhFebSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhFebSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhFebSeaCreatureData copyWith({int? id}) => AcnhFebSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhFebSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhFebSeaCreatureData && other.id == this.id);
}

class AcnhFebSeaCreatureCompanion
    extends UpdateCompanion<AcnhFebSeaCreatureData> {
  final Value<int?> id;
  const AcnhFebSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhFebSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhFebSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhFebSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhFebSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhFebSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhFebSeaCreature extends Table
    with TableInfo<AcnhFebSeaCreature, AcnhFebSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhFebSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_feb_sea_creature';
  @override
  String get actualTableName => 'acnh_feb_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhFebSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhFebSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhFebSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhFebSeaCreature createAlias(String alias) {
    return AcnhFebSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhMarSeaCreatureData extends DataClass
    implements Insertable<AcnhMarSeaCreatureData> {
  final int? id;
  AcnhMarSeaCreatureData({this.id});
  factory AcnhMarSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhMarSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhMarSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhMarSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhMarSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhMarSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhMarSeaCreatureData copyWith({int? id}) => AcnhMarSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhMarSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhMarSeaCreatureData && other.id == this.id);
}

class AcnhMarSeaCreatureCompanion
    extends UpdateCompanion<AcnhMarSeaCreatureData> {
  final Value<int?> id;
  const AcnhMarSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhMarSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhMarSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhMarSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhMarSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhMarSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhMarSeaCreature extends Table
    with TableInfo<AcnhMarSeaCreature, AcnhMarSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhMarSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_mar_sea_creature';
  @override
  String get actualTableName => 'acnh_mar_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhMarSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhMarSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhMarSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhMarSeaCreature createAlias(String alias) {
    return AcnhMarSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAprSeaCreatureData extends DataClass
    implements Insertable<AcnhAprSeaCreatureData> {
  final int? id;
  AcnhAprSeaCreatureData({this.id});
  factory AcnhAprSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAprSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAprSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhAprSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAprSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAprSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAprSeaCreatureData copyWith({int? id}) => AcnhAprSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAprSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAprSeaCreatureData && other.id == this.id);
}

class AcnhAprSeaCreatureCompanion
    extends UpdateCompanion<AcnhAprSeaCreatureData> {
  final Value<int?> id;
  const AcnhAprSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhAprSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAprSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAprSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhAprSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAprSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAprSeaCreature extends Table
    with TableInfo<AcnhAprSeaCreature, AcnhAprSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAprSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_apr_sea_creature';
  @override
  String get actualTableName => 'acnh_apr_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhAprSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAprSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhAprSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAprSeaCreature createAlias(String alias) {
    return AcnhAprSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhMaySeaCreatureData extends DataClass
    implements Insertable<AcnhMaySeaCreatureData> {
  final int? id;
  AcnhMaySeaCreatureData({this.id});
  factory AcnhMaySeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhMaySeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhMaySeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhMaySeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhMaySeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhMaySeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhMaySeaCreatureData copyWith({int? id}) => AcnhMaySeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhMaySeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhMaySeaCreatureData && other.id == this.id);
}

class AcnhMaySeaCreatureCompanion
    extends UpdateCompanion<AcnhMaySeaCreatureData> {
  final Value<int?> id;
  const AcnhMaySeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhMaySeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhMaySeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhMaySeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhMaySeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhMaySeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhMaySeaCreature extends Table
    with TableInfo<AcnhMaySeaCreature, AcnhMaySeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhMaySeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_may_sea_creature';
  @override
  String get actualTableName => 'acnh_may_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhMaySeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhMaySeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhMaySeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhMaySeaCreature createAlias(String alias) {
    return AcnhMaySeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJunSeaCreatureData extends DataClass
    implements Insertable<AcnhJunSeaCreatureData> {
  final int? id;
  AcnhJunSeaCreatureData({this.id});
  factory AcnhJunSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJunSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJunSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhJunSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJunSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJunSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJunSeaCreatureData copyWith({int? id}) => AcnhJunSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJunSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJunSeaCreatureData && other.id == this.id);
}

class AcnhJunSeaCreatureCompanion
    extends UpdateCompanion<AcnhJunSeaCreatureData> {
  final Value<int?> id;
  const AcnhJunSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhJunSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJunSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJunSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhJunSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJunSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJunSeaCreature extends Table
    with TableInfo<AcnhJunSeaCreature, AcnhJunSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJunSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jun_sea_creature';
  @override
  String get actualTableName => 'acnh_jun_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhJunSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJunSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJunSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJunSeaCreature createAlias(String alias) {
    return AcnhJunSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhJulSeaCreatureData extends DataClass
    implements Insertable<AcnhJulSeaCreatureData> {
  final int? id;
  AcnhJulSeaCreatureData({this.id});
  factory AcnhJulSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhJulSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhJulSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhJulSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhJulSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhJulSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhJulSeaCreatureData copyWith({int? id}) => AcnhJulSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhJulSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhJulSeaCreatureData && other.id == this.id);
}

class AcnhJulSeaCreatureCompanion
    extends UpdateCompanion<AcnhJulSeaCreatureData> {
  final Value<int?> id;
  const AcnhJulSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhJulSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhJulSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhJulSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhJulSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhJulSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhJulSeaCreature extends Table
    with TableInfo<AcnhJulSeaCreature, AcnhJulSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhJulSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_jul_sea_creature';
  @override
  String get actualTableName => 'acnh_jul_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhJulSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhJulSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhJulSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhJulSeaCreature createAlias(String alias) {
    return AcnhJulSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAug1SeaCreatureData extends DataClass
    implements Insertable<AcnhAug1SeaCreatureData> {
  final int? id;
  AcnhAug1SeaCreatureData({this.id});
  factory AcnhAug1SeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAug1SeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAug1SeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhAug1SeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAug1SeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAug1SeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAug1SeaCreatureData copyWith({int? id}) => AcnhAug1SeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAug1SeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAug1SeaCreatureData && other.id == this.id);
}

class AcnhAug1SeaCreatureCompanion
    extends UpdateCompanion<AcnhAug1SeaCreatureData> {
  final Value<int?> id;
  const AcnhAug1SeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhAug1SeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAug1SeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAug1SeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhAug1SeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAug1SeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAug1SeaCreature extends Table
    with TableInfo<AcnhAug1SeaCreature, AcnhAug1SeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAug1SeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_aug1_sea_creature';
  @override
  String get actualTableName => 'acnh_aug1_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhAug1SeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAug1SeaCreatureData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    return AcnhAug1SeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAug1SeaCreature createAlias(String alias) {
    return AcnhAug1SeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhAug2SeaCreatureData extends DataClass
    implements Insertable<AcnhAug2SeaCreatureData> {
  final int? id;
  AcnhAug2SeaCreatureData({this.id});
  factory AcnhAug2SeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhAug2SeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhAug2SeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhAug2SeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhAug2SeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhAug2SeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhAug2SeaCreatureData copyWith({int? id}) => AcnhAug2SeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhAug2SeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhAug2SeaCreatureData && other.id == this.id);
}

class AcnhAug2SeaCreatureCompanion
    extends UpdateCompanion<AcnhAug2SeaCreatureData> {
  final Value<int?> id;
  const AcnhAug2SeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhAug2SeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhAug2SeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhAug2SeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhAug2SeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhAug2SeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhAug2SeaCreature extends Table
    with TableInfo<AcnhAug2SeaCreature, AcnhAug2SeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhAug2SeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_aug2_sea_creature';
  @override
  String get actualTableName => 'acnh_aug2_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhAug2SeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhAug2SeaCreatureData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    return AcnhAug2SeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhAug2SeaCreature createAlias(String alias) {
    return AcnhAug2SeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSep1SeaCreatureData extends DataClass
    implements Insertable<AcnhSep1SeaCreatureData> {
  final int? id;
  AcnhSep1SeaCreatureData({this.id});
  factory AcnhSep1SeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSep1SeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhSep1SeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhSep1SeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhSep1SeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSep1SeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhSep1SeaCreatureData copyWith({int? id}) => AcnhSep1SeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSep1SeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSep1SeaCreatureData && other.id == this.id);
}

class AcnhSep1SeaCreatureCompanion
    extends UpdateCompanion<AcnhSep1SeaCreatureData> {
  final Value<int?> id;
  const AcnhSep1SeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhSep1SeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhSep1SeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhSep1SeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhSep1SeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSep1SeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhSep1SeaCreature extends Table
    with TableInfo<AcnhSep1SeaCreature, AcnhSep1SeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSep1SeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_sep1_sea_creature';
  @override
  String get actualTableName => 'acnh_sep1_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhSep1SeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSep1SeaCreatureData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    return AcnhSep1SeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSep1SeaCreature createAlias(String alias) {
    return AcnhSep1SeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhSep2SeaCreatureData extends DataClass
    implements Insertable<AcnhSep2SeaCreatureData> {
  final int? id;
  AcnhSep2SeaCreatureData({this.id});
  factory AcnhSep2SeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhSep2SeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhSep2SeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhSep2SeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhSep2SeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhSep2SeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhSep2SeaCreatureData copyWith({int? id}) => AcnhSep2SeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhSep2SeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhSep2SeaCreatureData && other.id == this.id);
}

class AcnhSep2SeaCreatureCompanion
    extends UpdateCompanion<AcnhSep2SeaCreatureData> {
  final Value<int?> id;
  const AcnhSep2SeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhSep2SeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhSep2SeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhSep2SeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhSep2SeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhSep2SeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhSep2SeaCreature extends Table
    with TableInfo<AcnhSep2SeaCreature, AcnhSep2SeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhSep2SeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_sep2_sea_creature';
  @override
  String get actualTableName => 'acnh_sep2_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhSep2SeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhSep2SeaCreatureData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    return AcnhSep2SeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhSep2SeaCreature createAlias(String alias) {
    return AcnhSep2SeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhOctSeaCreatureData extends DataClass
    implements Insertable<AcnhOctSeaCreatureData> {
  final int? id;
  AcnhOctSeaCreatureData({this.id});
  factory AcnhOctSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhOctSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhOctSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhOctSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhOctSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhOctSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhOctSeaCreatureData copyWith({int? id}) => AcnhOctSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhOctSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhOctSeaCreatureData && other.id == this.id);
}

class AcnhOctSeaCreatureCompanion
    extends UpdateCompanion<AcnhOctSeaCreatureData> {
  final Value<int?> id;
  const AcnhOctSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhOctSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhOctSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhOctSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhOctSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhOctSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhOctSeaCreature extends Table
    with TableInfo<AcnhOctSeaCreature, AcnhOctSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhOctSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_oct_sea_creature';
  @override
  String get actualTableName => 'acnh_oct_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhOctSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhOctSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhOctSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhOctSeaCreature createAlias(String alias) {
    return AcnhOctSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhNovSeaCreatureData extends DataClass
    implements Insertable<AcnhNovSeaCreatureData> {
  final int? id;
  AcnhNovSeaCreatureData({this.id});
  factory AcnhNovSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhNovSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhNovSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhNovSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhNovSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhNovSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhNovSeaCreatureData copyWith({int? id}) => AcnhNovSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhNovSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhNovSeaCreatureData && other.id == this.id);
}

class AcnhNovSeaCreatureCompanion
    extends UpdateCompanion<AcnhNovSeaCreatureData> {
  final Value<int?> id;
  const AcnhNovSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhNovSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhNovSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhNovSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhNovSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhNovSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhNovSeaCreature extends Table
    with TableInfo<AcnhNovSeaCreature, AcnhNovSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhNovSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_nov_sea_creature';
  @override
  String get actualTableName => 'acnh_nov_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhNovSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhNovSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhNovSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhNovSeaCreature createAlias(String alias) {
    return AcnhNovSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AcnhDecSeaCreatureData extends DataClass
    implements Insertable<AcnhDecSeaCreatureData> {
  final int? id;
  AcnhDecSeaCreatureData({this.id});
  factory AcnhDecSeaCreatureData.fromData(Map<String, dynamic> data,
      {String? prefix}) {
    final effectivePrefix = prefix ?? '';
    return AcnhDecSeaCreatureData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int?>(id);
    }
    return map;
  }

  AcnhDecSeaCreatureCompanion toCompanion(bool nullToAbsent) {
    return AcnhDecSeaCreatureCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
    );
  }

  factory AcnhDecSeaCreatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AcnhDecSeaCreatureData(
      id: serializer.fromJson<int?>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
    };
  }

  AcnhDecSeaCreatureData copyWith({int? id}) => AcnhDecSeaCreatureData(
        id: id ?? this.id,
      );
  @override
  String toString() {
    return (StringBuffer('AcnhDecSeaCreatureData(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AcnhDecSeaCreatureData && other.id == this.id);
}

class AcnhDecSeaCreatureCompanion
    extends UpdateCompanion<AcnhDecSeaCreatureData> {
  final Value<int?> id;
  const AcnhDecSeaCreatureCompanion({
    this.id = const Value.absent(),
  });
  AcnhDecSeaCreatureCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<AcnhDecSeaCreatureData> custom({
    Expression<int?>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  AcnhDecSeaCreatureCompanion copyWith({Value<int?>? id}) {
    return AcnhDecSeaCreatureCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int?>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AcnhDecSeaCreatureCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class AcnhDecSeaCreature extends Table
    with TableInfo<AcnhDecSeaCreature, AcnhDecSeaCreatureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AcnhDecSeaCreature(this.attachedDatabase, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int?> id = GeneratedColumn<int?>(
      'id', aliasedName, true,
      type: const IntType(),
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? 'acnh_dec_sea_creature';
  @override
  String get actualTableName => 'acnh_dec_sea_creature';
  @override
  VerificationContext validateIntegrity(
      Insertable<AcnhDecSeaCreatureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  AcnhDecSeaCreatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    return AcnhDecSeaCreatureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  AcnhDecSeaCreature createAlias(String alias) {
    return AcnhDecSeaCreature(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

abstract class _$MyDatabase extends GeneratedDatabase {
  _$MyDatabase(QueryExecutor e) : super(SqlTypeSystem.defaultInstance, e);
  late final AcgcCarpet acgcCarpet = AcgcCarpet(this);
  late final AcgcWallpaper acgcWallpaper = AcgcWallpaper(this);
  late final AcgcFish acgcFish = AcgcFish(this);
  late final AcgcFossil acgcFossil = AcgcFossil(this);
  late final AcgcGyroid acgcGyroid = AcgcGyroid(this);
  late final AcgcInsect acgcInsect = AcgcInsect(this);
  late final AcgcShirt acgcShirt = AcgcShirt(this);
  late final AcgcSong acgcSong = AcgcSong(this);
  late final AcgcStationery acgcStationery = AcgcStationery(this);
  late final AcgcTool acgcTool = AcgcTool(this);
  late final AcwwAccessory acwwAccessory = AcwwAccessory(this);
  late final AcwwCarpet acwwCarpet = AcwwCarpet(this);
  late final AcwwFish acwwFish = AcwwFish(this);
  late final AcwwFossil acwwFossil = AcwwFossil(this);
  late final AcwwFurniture acwwFurniture = AcwwFurniture(this);
  late final AcwwGyroid acwwGyroid = AcwwGyroid(this);
  late final AcwwInsect acwwInsect = AcwwInsect(this);
  late final AcwwShirt acwwShirt = AcwwShirt(this);
  late final AcwwSong acwwSong = AcwwSong(this);
  late final AcwwStationery acwwStationery = AcwwStationery(this);
  late final AcwwTool acwwTool = AcwwTool(this);
  late final AcwwWallpaper acwwWallpaper = AcwwWallpaper(this);
  late final AccfAccessory accfAccessory = AccfAccessory(this);
  late final AccfCarpet accfCarpet = AccfCarpet(this);
  late final AccfFossil accfFossil = AccfFossil(this);
  late final AccfFish accfFish = AccfFish(this);
  late final AccfFurniture accfFurniture = AccfFurniture(this);
  late final AccfGyroid accfGyroid = AccfGyroid(this);
  late final AccfInsect accfInsect = AccfInsect(this);
  late final AccfPainting accfPainting = AccfPainting(this);
  late final AccfShirt accfShirt = AccfShirt(this);
  late final AccfSong accfSong = AccfSong(this);
  late final AccfStationery accfStationery = AccfStationery(this);
  late final AccfTool accfTool = AccfTool(this);
  late final AccfWallpaper accfWallpaper = AccfWallpaper(this);
  late final AcnlAccessory acnlAccessory = AcnlAccessory(this);
  late final AcnlArt acnlArt = AcnlArt(this);
  late final AcnlBottom acnlBottom = AcnlBottom(this);
  late final AcnlCarpet acnlCarpet = AcnlCarpet(this);
  late final AcnlDlc acnlDlc = AcnlDlc(this);
  late final AcnlDress acnlDress = AcnlDress(this);
  late final AcnlFeet acnlFeet = AcnlFeet(this);
  late final AcnlFish acnlFish = AcnlFish(this);
  late final AcnlFossil acnlFossil = AcnlFossil(this);
  late final AcnlFossilModel acnlFossilModel = AcnlFossilModel(this);
  late final AcnlFurniture acnlFurniture = AcnlFurniture(this);
  late final AcnlGyroid acnlGyroid = AcnlGyroid(this);
  late final AcnlHat acnlHat = AcnlHat(this);
  late final AcnlInsect acnlInsect = AcnlInsect(this);
  late final AcnlMusicBox acnlMusicBox = AcnlMusicBox(this);
  late final AcnlSeafood acnlSeafood = AcnlSeafood(this);
  late final AcnlShirt acnlShirt = AcnlShirt(this);
  late final AcnlSong acnlSong = AcnlSong(this);
  late final AcnlStationery acnlStationery = AcnlStationery(this);
  late final AcnlTool acnlTool = AcnlTool(this);
  late final AcnlVillagerPicture acnlVillagerPicture =
      AcnlVillagerPicture(this);
  late final AcnlWallpaper acnlWallpaper = AcnlWallpaper(this);
  late final AcnlWetSuit acnlWetSuit = AcnlWetSuit(this);
  late final AcgcJanFish acgcJanFish = AcgcJanFish(this);
  late final AcgcFebFish acgcFebFish = AcgcFebFish(this);
  late final AcgcMarFish acgcMarFish = AcgcMarFish(this);
  late final AcgcAprFish acgcAprFish = AcgcAprFish(this);
  late final AcgcMayFish acgcMayFish = AcgcMayFish(this);
  late final AcgcJunFish acgcJunFish = AcgcJunFish(this);
  late final AcgcJulFish acgcJulFish = AcgcJulFish(this);
  late final AcgcAug1Fish acgcAug1Fish = AcgcAug1Fish(this);
  late final AcgcAug2Fish acgcAug2Fish = AcgcAug2Fish(this);
  late final AcgcSep1Fish acgcSep1Fish = AcgcSep1Fish(this);
  late final AcgcSep2Fish acgcSep2Fish = AcgcSep2Fish(this);
  late final AcgcOctFish acgcOctFish = AcgcOctFish(this);
  late final AcgcNovFish acgcNovFish = AcgcNovFish(this);
  late final AcgcDecFish acgcDecFish = AcgcDecFish(this);
  late final AcgcJanInsect acgcJanInsect = AcgcJanInsect(this);
  late final AcgcFebInsect acgcFebInsect = AcgcFebInsect(this);
  late final AcgcMarInsect acgcMarInsect = AcgcMarInsect(this);
  late final AcgcAprInsect acgcAprInsect = AcgcAprInsect(this);
  late final AcgcMayInsect acgcMayInsect = AcgcMayInsect(this);
  late final AcgcJunInsect acgcJunInsect = AcgcJunInsect(this);
  late final AcgcJulInsect acgcJulInsect = AcgcJulInsect(this);
  late final AcgcAug1Insect acgcAug1Insect = AcgcAug1Insect(this);
  late final AcgcAug2Insect acgcAug2Insect = AcgcAug2Insect(this);
  late final AcgcSep1Insect acgcSep1Insect = AcgcSep1Insect(this);
  late final AcgcSep2Insect acgcSep2Insect = AcgcSep2Insect(this);
  late final AcgcOctInsect acgcOctInsect = AcgcOctInsect(this);
  late final AcgcNovInsect acgcNovInsect = AcgcNovInsect(this);
  late final AcgcDecInsect acgcDecInsect = AcgcDecInsect(this);
  late final AcwwJanFish acwwJanFish = AcwwJanFish(this);
  late final AcwwFebFish acwwFebFish = AcwwFebFish(this);
  late final AcwwMarFish acwwMarFish = AcwwMarFish(this);
  late final AcwwAprFish acwwAprFish = AcwwAprFish(this);
  late final AcwwMayFish acwwMayFish = AcwwMayFish(this);
  late final AcwwJunFish acwwJunFish = AcwwJunFish(this);
  late final AcwwJulFish acwwJulFish = AcwwJulFish(this);
  late final AcwwAug1Fish acwwAug1Fish = AcwwAug1Fish(this);
  late final AcwwAug2Fish acwwAug2Fish = AcwwAug2Fish(this);
  late final AcwwSep1Fish acwwSep1Fish = AcwwSep1Fish(this);
  late final AcwwSep2Fish acwwSep2Fish = AcwwSep2Fish(this);
  late final AcwwOctFish acwwOctFish = AcwwOctFish(this);
  late final AcwwNovFish acwwNovFish = AcwwNovFish(this);
  late final AcwwDecFish acwwDecFish = AcwwDecFish(this);
  late final AcwwJanInsect acwwJanInsect = AcwwJanInsect(this);
  late final AcwwFebInsect acwwFebInsect = AcwwFebInsect(this);
  late final AcwwMarInsect acwwMarInsect = AcwwMarInsect(this);
  late final AcwwAprInsect acwwAprInsect = AcwwAprInsect(this);
  late final AcwwMayInsect acwwMayInsect = AcwwMayInsect(this);
  late final AcwwJunInsect acwwJunInsect = AcwwJunInsect(this);
  late final AcwwJulInsect acwwJulInsect = AcwwJulInsect(this);
  late final AcwwAug1Insect acwwAug1Insect = AcwwAug1Insect(this);
  late final AcwwAug2Insect acwwAug2Insect = AcwwAug2Insect(this);
  late final AcwwSep1Insect acwwSep1Insect = AcwwSep1Insect(this);
  late final AcwwSep2Insect acwwSep2Insect = AcwwSep2Insect(this);
  late final AcwwOctInsect acwwOctInsect = AcwwOctInsect(this);
  late final AcwwNovInsect acwwNovInsect = AcwwNovInsect(this);
  late final AcwwDecInsect acwwDecInsect = AcwwDecInsect(this);
  late final AccfJanFish accfJanFish = AccfJanFish(this);
  late final AccfFebFish accfFebFish = AccfFebFish(this);
  late final AccfMarFish accfMarFish = AccfMarFish(this);
  late final AccfAprFish accfAprFish = AccfAprFish(this);
  late final AccfMayFish accfMayFish = AccfMayFish(this);
  late final AccfJunFish accfJunFish = AccfJunFish(this);
  late final AccfJulFish accfJulFish = AccfJulFish(this);
  late final AccfAug1Fish accfAug1Fish = AccfAug1Fish(this);
  late final AccfAug2Fish accfAug2Fish = AccfAug2Fish(this);
  late final AccfSep1Fish accfSep1Fish = AccfSep1Fish(this);
  late final AccfSep2Fish accfSep2Fish = AccfSep2Fish(this);
  late final AccfOctFish accfOctFish = AccfOctFish(this);
  late final AccfNovFish accfNovFish = AccfNovFish(this);
  late final AccfDecFish accfDecFish = AccfDecFish(this);
  late final AccfJanInsect accfJanInsect = AccfJanInsect(this);
  late final AccfFebInsect accfFebInsect = AccfFebInsect(this);
  late final AccfMarInsect accfMarInsect = AccfMarInsect(this);
  late final AccfAprInsect accfAprInsect = AccfAprInsect(this);
  late final AccfMayInsect accfMayInsect = AccfMayInsect(this);
  late final AccfJunInsect accfJunInsect = AccfJunInsect(this);
  late final AccfJulInsect accfJulInsect = AccfJulInsect(this);
  late final AccfAug1Insect accfAug1Insect = AccfAug1Insect(this);
  late final AccfAug2Insect accfAug2Insect = AccfAug2Insect(this);
  late final AccfSep1Insect accfSep1Insect = AccfSep1Insect(this);
  late final AccfSep2Insect accfSep2Insect = AccfSep2Insect(this);
  late final AccfOctInsect accfOctInsect = AccfOctInsect(this);
  late final AccfNovInsect accfNovInsect = AccfNovInsect(this);
  late final AccfDecInsect accfDecInsect = AccfDecInsect(this);
  late final AcnlJanFish acnlJanFish = AcnlJanFish(this);
  late final AcnlFebFish acnlFebFish = AcnlFebFish(this);
  late final AcnlMarFish acnlMarFish = AcnlMarFish(this);
  late final AcnlAprFish acnlAprFish = AcnlAprFish(this);
  late final AcnlMayFish acnlMayFish = AcnlMayFish(this);
  late final AcnlJunFish acnlJunFish = AcnlJunFish(this);
  late final AcnlJulFish acnlJulFish = AcnlJulFish(this);
  late final AcnlAug1Fish acnlAug1Fish = AcnlAug1Fish(this);
  late final AcnlAug2Fish acnlAug2Fish = AcnlAug2Fish(this);
  late final AcnlSep1Fish acnlSep1Fish = AcnlSep1Fish(this);
  late final AcnlSep2Fish acnlSep2Fish = AcnlSep2Fish(this);
  late final AcnlOctFish acnlOctFish = AcnlOctFish(this);
  late final AcnlNovFish acnlNovFish = AcnlNovFish(this);
  late final AcnlDecFish acnlDecFish = AcnlDecFish(this);
  late final AcnlJanInsect acnlJanInsect = AcnlJanInsect(this);
  late final AcnlFebInsect acnlFebInsect = AcnlFebInsect(this);
  late final AcnlMarInsect acnlMarInsect = AcnlMarInsect(this);
  late final AcnlAprInsect acnlAprInsect = AcnlAprInsect(this);
  late final AcnlMayInsect acnlMayInsect = AcnlMayInsect(this);
  late final AcnlJunInsect acnlJunInsect = AcnlJunInsect(this);
  late final AcnlJulInsect acnlJulInsect = AcnlJulInsect(this);
  late final AcnlAug1Insect acnlAug1Insect = AcnlAug1Insect(this);
  late final AcnlAug2Insect acnlAug2Insect = AcnlAug2Insect(this);
  late final AcnlSep1Insect acnlSep1Insect = AcnlSep1Insect(this);
  late final AcnlSep2Insect acnlSep2Insect = AcnlSep2Insect(this);
  late final AcnlOctInsect acnlOctInsect = AcnlOctInsect(this);
  late final AcnlNovInsect acnlNovInsect = AcnlNovInsect(this);
  late final AcnlDecInsect acnlDecInsect = AcnlDecInsect(this);
  late final AcnlJanSeafood acnlJanSeafood = AcnlJanSeafood(this);
  late final AcnlFebSeafood acnlFebSeafood = AcnlFebSeafood(this);
  late final AcnlMarSeafood acnlMarSeafood = AcnlMarSeafood(this);
  late final AcnlAprSeafood acnlAprSeafood = AcnlAprSeafood(this);
  late final AcnlMaySeafood acnlMaySeafood = AcnlMaySeafood(this);
  late final AcnlJunSeafood acnlJunSeafood = AcnlJunSeafood(this);
  late final AcnlJulSeafood acnlJulSeafood = AcnlJulSeafood(this);
  late final AcnlAug1Seafood acnlAug1Seafood = AcnlAug1Seafood(this);
  late final AcnlAug2Seafood acnlAug2Seafood = AcnlAug2Seafood(this);
  late final AcnlSep1Seafood acnlSep1Seafood = AcnlSep1Seafood(this);
  late final AcnlSep2Seafood acnlSep2Seafood = AcnlSep2Seafood(this);
  late final AcnlOctSeafood acnlOctSeafood = AcnlOctSeafood(this);
  late final AcnlNovSeafood acnlNovSeafood = AcnlNovSeafood(this);
  late final AcnlDecSeafood acnlDecSeafood = AcnlDecSeafood(this);
  late final AcgcTable acgcTable = AcgcTable(this);
  late final AcwwTable acwwTable = AcwwTable(this);
  late final AccfTable accfTable = AccfTable(this);
  late final AcnlTable acnlTable = AcnlTable(this);
  late final AcnhTable acnhTable = AcnhTable(this);
  late final AcnhAccessory acnhAccessory = AcnhAccessory(this);
  late final AcnhArt acnhArt = AcnhArt(this);
  late final AcnhBag acnhBag = AcnhBag(this);
  late final AcnhBottom acnhBottom = AcnhBottom(this);
  late final AcnhDress acnhDress = AcnhDress(this);
  late final AcnhFencing acnhFencing = AcnhFencing(this);
  late final AcnhFish acnhFish = AcnhFish(this);
  late final AcnhJanFish acnhJanFish = AcnhJanFish(this);
  late final AcnhFebFish acnhFebFish = AcnhFebFish(this);
  late final AcnhMarFish acnhMarFish = AcnhMarFish(this);
  late final AcnhAprFish acnhAprFish = AcnhAprFish(this);
  late final AcnhMayFish acnhMayFish = AcnhMayFish(this);
  late final AcnhJunFish acnhJunFish = AcnhJunFish(this);
  late final AcnhJulFish acnhJulFish = AcnhJulFish(this);
  late final AcnhAug1Fish acnhAug1Fish = AcnhAug1Fish(this);
  late final AcnhAug2Fish acnhAug2Fish = AcnhAug2Fish(this);
  late final AcnhSep1Fish acnhSep1Fish = AcnhSep1Fish(this);
  late final AcnhSep2Fish acnhSep2Fish = AcnhSep2Fish(this);
  late final AcnhOctFish acnhOctFish = AcnhOctFish(this);
  late final AcnhNovFish acnhNovFish = AcnhNovFish(this);
  late final AcnhDecFish acnhDecFish = AcnhDecFish(this);
  late final AcnhFlooring acnhFlooring = AcnhFlooring(this);
  late final AcnhFossil acnhFossil = AcnhFossil(this);
  late final AcnhHeadwear acnhHeadwear = AcnhHeadwear(this);
  late final AcnhHouseware acnhHouseware = AcnhHouseware(this);
  late final AcnhMisc acnhMisc = AcnhMisc(this);
  late final AcnhWallMounted acnhWallMounted = AcnhWallMounted(this);
  late final AcnhCeiling acnhCeiling = AcnhCeiling(this);
  late final AcnhInterior acnhInterior = AcnhInterior(this);
  late final AcnhGyroid acnhGyroid = AcnhGyroid(this);
  late final AcnhHybrid acnhHybrid = AcnhHybrid(this);
  late final AcnhInsect acnhInsect = AcnhInsect(this);
  late final AcnhJanInsect acnhJanInsect = AcnhJanInsect(this);
  late final AcnhFebInsect acnhFebInsect = AcnhFebInsect(this);
  late final AcnhMarInsect acnhMarInsect = AcnhMarInsect(this);
  late final AcnhAprInsect acnhAprInsect = AcnhAprInsect(this);
  late final AcnhMayInsect acnhMayInsect = AcnhMayInsect(this);
  late final AcnhJunInsect acnhJunInsect = AcnhJunInsect(this);
  late final AcnhJulInsect acnhJulInsect = AcnhJulInsect(this);
  late final AcnhAug1Insect acnhAug1Insect = AcnhAug1Insect(this);
  late final AcnhAug2Insect acnhAug2Insect = AcnhAug2Insect(this);
  late final AcnhSep1Insect acnhSep1Insect = AcnhSep1Insect(this);
  late final AcnhSep2Insect acnhSep2Insect = AcnhSep2Insect(this);
  late final AcnhOctInsect acnhOctInsect = AcnhOctInsect(this);
  late final AcnhNovInsect acnhNovInsect = AcnhNovInsect(this);
  late final AcnhDecInsect acnhDecInsect = AcnhDecInsect(this);
  late final AcnhPhoto acnhPhoto = AcnhPhoto(this);
  late final AcnhPoster acnhPoster = AcnhPoster(this);
  late final AcnhRecipe acnhRecipe = AcnhRecipe(this);
  late final AcnhRug acnhRug = AcnhRug(this);
  late final AcnhShoe acnhShoe = AcnhShoe(this);
  late final AcnhSock acnhSock = AcnhSock(this);
  late final AcnhSong acnhSong = AcnhSong(this);
  late final AcnhTool acnhTool = AcnhTool(this);
  late final AcnhTop acnhTop = AcnhTop(this);
  late final AcnhUmbrella acnhUmbrella = AcnhUmbrella(this);
  late final AcnhWallpaper acnhWallpaper = AcnhWallpaper(this);
  late final AcgcFurniture acgcFurniture = AcgcFurniture(this);
  late final AcnhOtherClothing acnhOtherClothing = AcnhOtherClothing(this);
  late final AcnhSeaCreature acnhSeaCreature = AcnhSeaCreature(this);
  late final AcnhJanSeaCreature acnhJanSeaCreature = AcnhJanSeaCreature(this);
  late final AcnhFebSeaCreature acnhFebSeaCreature = AcnhFebSeaCreature(this);
  late final AcnhMarSeaCreature acnhMarSeaCreature = AcnhMarSeaCreature(this);
  late final AcnhAprSeaCreature acnhAprSeaCreature = AcnhAprSeaCreature(this);
  late final AcnhMaySeaCreature acnhMaySeaCreature = AcnhMaySeaCreature(this);
  late final AcnhJunSeaCreature acnhJunSeaCreature = AcnhJunSeaCreature(this);
  late final AcnhJulSeaCreature acnhJulSeaCreature = AcnhJulSeaCreature(this);
  late final AcnhAug1SeaCreature acnhAug1SeaCreature =
      AcnhAug1SeaCreature(this);
  late final AcnhAug2SeaCreature acnhAug2SeaCreature =
      AcnhAug2SeaCreature(this);
  late final AcnhSep1SeaCreature acnhSep1SeaCreature =
      AcnhSep1SeaCreature(this);
  late final AcnhSep2SeaCreature acnhSep2SeaCreature =
      AcnhSep2SeaCreature(this);
  late final AcnhOctSeaCreature acnhOctSeaCreature = AcnhOctSeaCreature(this);
  late final AcnhNovSeaCreature acnhNovSeaCreature = AcnhNovSeaCreature(this);
  late final AcnhDecSeaCreature acnhDecSeaCreature = AcnhDecSeaCreature(this);
  @override
  Iterable<TableInfo> get allTables => allSchemaEntities.whereType<TableInfo>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        acgcCarpet,
        acgcWallpaper,
        acgcFish,
        acgcFossil,
        acgcGyroid,
        acgcInsect,
        acgcShirt,
        acgcSong,
        acgcStationery,
        acgcTool,
        acwwAccessory,
        acwwCarpet,
        acwwFish,
        acwwFossil,
        acwwFurniture,
        acwwGyroid,
        acwwInsect,
        acwwShirt,
        acwwSong,
        acwwStationery,
        acwwTool,
        acwwWallpaper,
        accfAccessory,
        accfCarpet,
        accfFossil,
        accfFish,
        accfFurniture,
        accfGyroid,
        accfInsect,
        accfPainting,
        accfShirt,
        accfSong,
        accfStationery,
        accfTool,
        accfWallpaper,
        acnlAccessory,
        acnlArt,
        acnlBottom,
        acnlCarpet,
        acnlDlc,
        acnlDress,
        acnlFeet,
        acnlFish,
        acnlFossil,
        acnlFossilModel,
        acnlFurniture,
        acnlGyroid,
        acnlHat,
        acnlInsect,
        acnlMusicBox,
        acnlSeafood,
        acnlShirt,
        acnlSong,
        acnlStationery,
        acnlTool,
        acnlVillagerPicture,
        acnlWallpaper,
        acnlWetSuit,
        acgcJanFish,
        acgcFebFish,
        acgcMarFish,
        acgcAprFish,
        acgcMayFish,
        acgcJunFish,
        acgcJulFish,
        acgcAug1Fish,
        acgcAug2Fish,
        acgcSep1Fish,
        acgcSep2Fish,
        acgcOctFish,
        acgcNovFish,
        acgcDecFish,
        acgcJanInsect,
        acgcFebInsect,
        acgcMarInsect,
        acgcAprInsect,
        acgcMayInsect,
        acgcJunInsect,
        acgcJulInsect,
        acgcAug1Insect,
        acgcAug2Insect,
        acgcSep1Insect,
        acgcSep2Insect,
        acgcOctInsect,
        acgcNovInsect,
        acgcDecInsect,
        acwwJanFish,
        acwwFebFish,
        acwwMarFish,
        acwwAprFish,
        acwwMayFish,
        acwwJunFish,
        acwwJulFish,
        acwwAug1Fish,
        acwwAug2Fish,
        acwwSep1Fish,
        acwwSep2Fish,
        acwwOctFish,
        acwwNovFish,
        acwwDecFish,
        acwwJanInsect,
        acwwFebInsect,
        acwwMarInsect,
        acwwAprInsect,
        acwwMayInsect,
        acwwJunInsect,
        acwwJulInsect,
        acwwAug1Insect,
        acwwAug2Insect,
        acwwSep1Insect,
        acwwSep2Insect,
        acwwOctInsect,
        acwwNovInsect,
        acwwDecInsect,
        accfJanFish,
        accfFebFish,
        accfMarFish,
        accfAprFish,
        accfMayFish,
        accfJunFish,
        accfJulFish,
        accfAug1Fish,
        accfAug2Fish,
        accfSep1Fish,
        accfSep2Fish,
        accfOctFish,
        accfNovFish,
        accfDecFish,
        accfJanInsect,
        accfFebInsect,
        accfMarInsect,
        accfAprInsect,
        accfMayInsect,
        accfJunInsect,
        accfJulInsect,
        accfAug1Insect,
        accfAug2Insect,
        accfSep1Insect,
        accfSep2Insect,
        accfOctInsect,
        accfNovInsect,
        accfDecInsect,
        acnlJanFish,
        acnlFebFish,
        acnlMarFish,
        acnlAprFish,
        acnlMayFish,
        acnlJunFish,
        acnlJulFish,
        acnlAug1Fish,
        acnlAug2Fish,
        acnlSep1Fish,
        acnlSep2Fish,
        acnlOctFish,
        acnlNovFish,
        acnlDecFish,
        acnlJanInsect,
        acnlFebInsect,
        acnlMarInsect,
        acnlAprInsect,
        acnlMayInsect,
        acnlJunInsect,
        acnlJulInsect,
        acnlAug1Insect,
        acnlAug2Insect,
        acnlSep1Insect,
        acnlSep2Insect,
        acnlOctInsect,
        acnlNovInsect,
        acnlDecInsect,
        acnlJanSeafood,
        acnlFebSeafood,
        acnlMarSeafood,
        acnlAprSeafood,
        acnlMaySeafood,
        acnlJunSeafood,
        acnlJulSeafood,
        acnlAug1Seafood,
        acnlAug2Seafood,
        acnlSep1Seafood,
        acnlSep2Seafood,
        acnlOctSeafood,
        acnlNovSeafood,
        acnlDecSeafood,
        acgcTable,
        acwwTable,
        accfTable,
        acnlTable,
        acnhTable,
        acnhAccessory,
        acnhArt,
        acnhBag,
        acnhBottom,
        acnhDress,
        acnhFencing,
        acnhFish,
        acnhJanFish,
        acnhFebFish,
        acnhMarFish,
        acnhAprFish,
        acnhMayFish,
        acnhJunFish,
        acnhJulFish,
        acnhAug1Fish,
        acnhAug2Fish,
        acnhSep1Fish,
        acnhSep2Fish,
        acnhOctFish,
        acnhNovFish,
        acnhDecFish,
        acnhFlooring,
        acnhFossil,
        acnhHeadwear,
        acnhHouseware,
        acnhMisc,
        acnhWallMounted,
        acnhCeiling,
        acnhInterior,
        acnhGyroid,
        acnhHybrid,
        acnhInsect,
        acnhJanInsect,
        acnhFebInsect,
        acnhMarInsect,
        acnhAprInsect,
        acnhMayInsect,
        acnhJunInsect,
        acnhJulInsect,
        acnhAug1Insect,
        acnhAug2Insect,
        acnhSep1Insect,
        acnhSep2Insect,
        acnhOctInsect,
        acnhNovInsect,
        acnhDecInsect,
        acnhPhoto,
        acnhPoster,
        acnhRecipe,
        acnhRug,
        acnhShoe,
        acnhSock,
        acnhSong,
        acnhTool,
        acnhTop,
        acnhUmbrella,
        acnhWallpaper,
        acgcFurniture,
        acnhOtherClothing,
        acnhSeaCreature,
        acnhJanSeaCreature,
        acnhFebSeaCreature,
        acnhMarSeaCreature,
        acnhAprSeaCreature,
        acnhMaySeaCreature,
        acnhJunSeaCreature,
        acnhJulSeaCreature,
        acnhAug1SeaCreature,
        acnhAug2SeaCreature,
        acnhSep1SeaCreature,
        acnhSep2SeaCreature,
        acnhOctSeaCreature,
        acnhNovSeaCreature,
        acnhDecSeaCreature
      ];
}
